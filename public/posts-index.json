{
  "posts": [
    {
      "slug": "01-ai-journey-start",
      "title": "AI 개발 방법론 1 - AI와의 첫 만남, 그리고 시작",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "description": "2023년 ChatGPT 해커톤 1등부터 2025년 Cursor까지. AI 개발 도구와 함께한 여정의 시작",
      "tags": [
        "ai-first",
        "chatgpt",
        "cursor",
        "claude",
        "gemini"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "02-ai-first-wall-complexity",
      "title": "AI 개발 방법론 2 - 첫 번째 벽, 복잡성",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "description": "업무에서는 완벽했던 AI가 내 프로젝트에서는 왜 이상한 코드를 만들어낼까? 복잡성이라는 첫 번째 벽을 마주하다",
      "tags": [
        "ai-first",
        "cursor",
        "claude",
        "complexity",
        "fallingo"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "03-ai-second-wall-consistency",
      "title": "AI 개발 방법론 3 - 두 번째 벽, 일관성",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "description": "수십 장의 문서, 수십 번의 리셋. 일관성이 무너지는 AI와 싸우며 찾은 해답들",
      "tags": [
        "ai-first",
        "claude",
        "gemini",
        "consistency",
        "mcp",
        "hi-ai"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "04-ai-breakthrough-sequential",
      "title": "AI 개발 방법론 4 - 돌파구, 순차적 문서 작성",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "description": "5단계 순차적 문서 작성과 교차 검증. 수십 번의 실패 끝에 찾은 AI와 협업하는 방법",
      "tags": [
        "ai-first",
        "methodology",
        "sequential",
        "documentation"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "05-ai-completion-speckit",
      "title": "AI 개발 방법론 5 - 완성, SpecKit과 그 너머",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "description": "SpecKit 발견, 그리고 나만의 바이브 코딩 프레임워크를 만들기까지. AI 개발 방법론의 완성",
      "tags": [
        "ai-first",
        "speckit",
        "vibe-coding",
        "framework",
        "methodology"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-vibe-01",
      "title": "Vibe: SPEC 주도 AI 코딩 프레임워크로 바이브 코딩을 더 쉽게",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "tech",
      "description": "자연어를 프로덕션 코드로. EARS 기반 명세 작성부터 작업 분해까지, 38개 MCP 도구와 7개 전문 에이전트가 함께하는 체계적인 AI 개발 프레임워크",
      "tags": [
        "vibe",
        "ai-coding",
        "spec-driven",
        "mcp",
        "claude-code",
        "framework"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0034",
      "title": "fallingo 개발일지 - eca8e83..f985f12 (35개 커밋)",
      "date": "2025-11-16T00:00:00.000Z",
      "category": "dev-log",
      "description": "피드 등록 프로세스 재정의, AI/API 연동 및 백엔드/프론트엔드 코드 품질 개선 작업 진행",
      "tags": [
        "fallingo",
        "개발일지",
        "피드",
        "OCR",
        "AI",
        "FastAPI",
        "Flutter",
        "리팩토링"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-hi-ai-05",
      "title": "hi-ai MCP v1.3.0: Smithery 품질 점수 17% 향상과 4개 핵심 라이브러리",
      "date": "2025-11-16T00:00:00.000Z",
      "category": "tech",
      "description": "도구 메타데이터 추가, 패키지 정보 개선, 아이콘 제작으로 품질 점수 54→63점 달성. 4개 핵심 라이브러리로 성능 최적화",
      "tags": [
        "hi-ai",
        "mcp",
        "smithery",
        "performance",
        "typescript",
        "release"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-auto-devlog",
      "title": "GitHub Actions + Gemini API로 커밋 20개마다 개발 일지 자동 생성하기",
      "date": "2025-11-11T00:00:00.000Z",
      "category": "tech",
      "description": "개발에만 집중하세요. 커밋 20개가 쌓이면 Gemini가 자동으로 개발 일지를 작성하고 배포까지 완료합니다.",
      "tags": [
        "github-actions",
        "gemini-api",
        "automation",
        "devops",
        "fallingo"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-01-google-dream",
      "title": "나의 꿈은 구글이니까 - 기술스택을 100% 구글로 결정한 이유",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "story",
      "description": "갈 수 없을 것 같은 꿈. 그래서 모든 기술을 구글로 만들기로 했다",
      "tags": [
        "fallingo",
        "google-cloud",
        "dev-journey",
        "dream"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-02-google-for-startups",
      "title": "Google for Startups Cloud Program 승인받기 - $2,000 크레딧 획득 여정",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "story",
      "description": "fallingo의 Google for Startups Cloud Program 신청부터 승인까지. 웹사이트 검증 요청, fallingo.app/about.html 페이지 작성, 그리고 Start Tier $2,000 크레딧 승인까지의 실제 과정",
      "tags": [
        "google-cloud",
        "startup",
        "cloud-credits",
        "fallingo"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-03-why-fallingo",
      "title": "왜 fallingo를 만들게 됐나 - 가짜 리뷰를 없애고 싶었다",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "story",
      "description": "위치 기반 검증으로 진짜 음식 경험만 공유되는 플랫폼. 그리고 처음부터 글로벌을 목표로 한 이유",
      "tags": [
        "fallingo",
        "vision",
        "startup",
        "food-tech"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0033",
      "title": "fallingo 개발일지 - 2025-11-10 (9개 커밋)",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "dev-log",
      "description": "블로그 자동화 시스템 완전 재구성",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-hi-ai-01",
      "title": "hi-ai MCP: 개발자를 위한 34개 도구의 똑똑한 AI 비서",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "description": "키워드 기반 자연어로 작동하는 MCP 1.0 표준 개발 도구 - 100ms 이하 응답, 50MB 이하 메모리",
      "tags": [
        "mcp",
        "ai-tools",
        "typescript",
        "developer-tools",
        "hi-ai"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-hi-ai-02",
      "title": "hi-ai MCP v1.0.4-6: AST 기반 코드 분석과 자연어 실행 시스템 도입",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "description": "ts-morph 기반 AST 코드 분석, 프롬프트 최적화, 다국어 키워드 지원 - 31개 도구로 확장된 MCP 서버",
      "tags": [
        "hi-ai",
        "mcp",
        "ast",
        "code-analysis",
        "typescript",
        "release"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-hi-ai-03",
      "title": "hi-ai MCP v1.1.0: 시맨틱 코드 분석으로 코드 이해도 향상",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "description": "find_symbol, find_references 도구 추가 - 코드 탐색과 리팩토링을 위한 시맨틱 분석 기능 강화",
      "tags": [
        "hi-ai",
        "mcp",
        "semantic-analysis",
        "code-navigation",
        "typescript",
        "release"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-hi-ai-04",
      "title": "hi-ai MCP v1.2.0: UI 미리보기 시스템으로 개발 워크플로우 혁신",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "description": "ASCII 아트 기반 UI 미리보기 - 6가지 레이아웃 타입 지원으로 터미널에서 즉시 확인 가능한 시각화 시스템",
      "tags": [
        "hi-ai",
        "mcp",
        "ui-preview",
        "ascii-art",
        "developer-tools",
        "release"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-redis-optimization",
      "title": "[기술 심화] Redis 캐싱으로 API 응답속도 76% 개선하기 - 실전 최적화 가이드",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "description": "GCP Memorystore Redis를 활용한 FastAPI 백엔드 성능 최적화. 실제 성능 측정 데이터와 함께하는 캐싱 전략 완벽 가이드",
      "tags": [
        "fallingo",
        "redis",
        "caching",
        "performance",
        "fastapi",
        "gcp",
        "optimization",
        "technical"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0031",
      "title": "fallingo 개발일지 - 2025-11-07 ~ 2025-11-09 (20개 커밋)",
      "date": "2025-11-09T00:00:00.000Z",
      "category": "dev-log",
      "description": "Redis 캐싱 및 BackgroundTasks로 76% 성능 개선",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0032",
      "title": "fallingo 개발일지 - 2025-11-09 (20개 커밋)",
      "date": "2025-11-09T00:00:00.000Z",
      "category": "dev-log",
      "description": "낙관적 업데이트 구현 및 대규모 코드 품질 개선",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0030",
      "title": "fallingo 개발일지 - 2025-11-06 ~ 2025-11-07 (20개 커밋)",
      "date": "2025-11-07T00:00:00.000Z",
      "category": "dev-log",
      "description": "전체 화면 API 연동 및 FCM 푸시 알림 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0029",
      "title": "fallingo 개발일지 - 2025-10-29 ~ 2025-11-06 (20개 커밋)",
      "date": "2025-11-06T00:00:00.000Z",
      "category": "dev-log",
      "description": "성능 최적화, Google for Startups 랜딩 페이지, 프리미엄 기능 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0028",
      "title": "fallingo 개발일지 - 2025-10-28 ~ 2025-10-29 (20개 커밋)",
      "date": "2025-10-29T00:00:00.000Z",
      "category": "dev-log",
      "description": "Trailing slash 문제 해결 및 광고 시스템 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0027",
      "title": "fallingo 개발일지 - 2025-10-27 ~ 2025-10-28 (20개 커밋)",
      "date": "2025-10-28T00:00:00.000Z",
      "category": "dev-log",
      "description": "CORS 및 API 경로 문제 집중 해결",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0026",
      "title": "fallingo 개발일지 - 2025-10-25 ~ 2025-10-27 (20개 커밋)",
      "date": "2025-10-27T00:00:00.000Z",
      "category": "dev-log",
      "description": "테스트 데이터 시딩 및 Flutter 프론트엔드 배포",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0025",
      "title": "fallingo 개발일지 - 2025-10-25 (20개 커밋)",
      "date": "2025-10-25T00:00:00.000Z",
      "category": "dev-log",
      "description": "Cloud Run 배포 최적화 및 169개 API 엔드포인트 정상화",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0024",
      "title": "fallingo 개발일지 - 2025-10-22 ~ 2025-10-24 (20개 커밋)",
      "date": "2025-10-24T00:00:00.000Z",
      "category": "dev-log",
      "description": "배포 안정화 및 Spec-kit 코드 품질 관리 도입",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0022",
      "title": "fallingo 개발일지 - 2025-10-17 ~ 2025-10-22 (20개 커밋)",
      "date": "2025-10-22T00:00:00.000Z",
      "category": "dev-log",
      "description": "소셜 로그인, AI 콘텐츠 검수, GCP 프로젝트 마이그레이션",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0023",
      "title": "fallingo 개발일지 - 2025-10-22 (20개 커밋)",
      "date": "2025-10-22T00:00:00.000Z",
      "category": "dev-log",
      "description": "프로덕션 Dockerfile 및 Cloud Run 배포 최적화",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0021",
      "title": "fallingo 개발일지 - 2025-10-01 ~ 2025-10-17 (20개 커밋)",
      "date": "2025-10-17T00:00:00.000Z",
      "category": "dev-log",
      "description": "백엔드 145 엔드포인트 완성 및 Flutter 프론트엔드 본격 개발",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0020",
      "title": "fallingo 개발일지 - 2025-09-10 ~ 2025-10-01 (20개 커밋)",
      "date": "2025-10-01T00:00:00.000Z",
      "category": "dev-log",
      "description": "리셋 후 백엔드 완전 재구축 및 코드 품질 개선",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0019",
      "title": "fallingo 개발일지 - 2025-09-09 ~ 2025-09-10 (20개 커밋)",
      "date": "2025-09-10T00:00:00.000Z",
      "category": "dev-log",
      "description": "전체 API 통합 완료 및 NoneType 에러 집중 수정",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0018",
      "title": "fallingo 개발일지 - 2025-09-04 ~ 2025-09-09 (20개 커밋)",
      "date": "2025-09-09T00:00:00.000Z",
      "category": "dev-log",
      "description": "Cloud Run 배포 문제 해결 및 단계별 통합 테스트",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0017",
      "title": "fallingo 개발일지 - 2025-08-26 ~ 2025-09-04 (20개 커밋)",
      "date": "2025-09-04T00:00:00.000Z",
      "category": "dev-log",
      "description": "완전한 API 문서화 및 백엔드 핵심 기능 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0016",
      "title": "fallingo 개발일지 - 2025-08-13 ~ 2025-08-25 (20개 커밋)",
      "date": "2025-08-25T00:00:00.000Z",
      "category": "dev-log",
      "description": "개발 중단 및 데이터베이스 문서화 집중",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0015",
      "title": "fallingo 개발일지 - 2025-08-12 ~ 2025-08-13 (20개 커밋)",
      "date": "2025-08-13T00:00:00.000Z",
      "category": "dev-log",
      "description": "주요 API 완성 및 백엔드 전면 재작성",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0011",
      "title": "fallingo 개발일지 - 2025-08-09 ~ 2025-08-12 (20개 커밋)",
      "date": "2025-08-12T00:00:00.000Z",
      "category": "dev-log",
      "description": "Phase 1 백엔드 완료 및 Identity Platform 인증 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0012",
      "title": "fallingo 개발일지 - 2025-08-12 (20개 커밋)",
      "date": "2025-08-12T00:00:00.000Z",
      "category": "dev-log",
      "description": "대규모 리팩토링 및 프로젝트 정리",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0013",
      "title": "fallingo 개발일지 - 2025-08-12 (20개 커밋)",
      "date": "2025-08-12T00:00:00.000Z",
      "category": "dev-log",
      "description": "Python 버전 시행착오 및 Cloud Run 배포 안정화",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0014",
      "title": "fallingo 개발일지 - 2025-08-12 (20개 커밋)",
      "date": "2025-08-12T00:00:00.000Z",
      "category": "dev-log",
      "description": "Redis 제거, 보안 강화 및 대규모 리팩토링",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0009",
      "title": "fallingo 개발일지 - 2025-07-14 ~ 2025-08-09 (20개 커밋)",
      "date": "2025-08-09T00:00:00.000Z",
      "category": "dev-log",
      "description": "프로젝트 초기 설정 및 프론트엔드 개발 시작",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0010",
      "title": "fallingo 개발일지 - 2025-08-09 (20개 커밋)",
      "date": "2025-08-09T00:00:00.000Z",
      "category": "dev-log",
      "description": "하루 동안 20개 버그 픽스 및 배포 안정화",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0008",
      "title": "fallingo 개발일지 - 2025-06-18 ~ 2025-07-14 (20개 커밋)",
      "date": "2025-07-14T00:00:00.000Z",
      "category": "dev-log",
      "description": "반복된 리셋과 Step 기반 개발 완료",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0007",
      "title": "fallingo 개발일지 - 2025-06-15 ~ 2025-06-16 (20개 커밋)",
      "date": "2025-06-16T00:00:00.000Z",
      "category": "dev-log",
      "description": "Phase 0~4 완료 및 프로젝트 리셋",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0006",
      "title": "fallingo 개발일지 - 2025-06-04 ~ 2025-06-15 (20개 커밋)",
      "date": "2025-06-15T00:00:00.000Z",
      "category": "dev-log",
      "description": "fallingo 프로젝트 초기 개발 및 Part 0~1 완료",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0005",
      "title": "fallingo 개발일지 - 2025-06-05 (2개 커밋)",
      "date": "2025-06-05T00:00:00.000Z",
      "category": "dev-log",
      "description": "README 최종 업데이트",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0004",
      "title": "fallingo 개발일지 - 2025-05-31 ~ 2025-06-02 (20개 커밋)",
      "date": "2025-06-02T00:00:00.000Z",
      "category": "dev-log",
      "description": "README 대폭 개선 및 개발 시작 준비",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0002",
      "title": "fallingo 개발일지 - 2025-05-29 ~ 2025-05-31 (20개 커밋)",
      "date": "2025-05-31T00:00:00.000Z",
      "category": "dev-log",
      "description": "기획 문서 개선 및 서비스 소개 문서 작성",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0003",
      "title": "fallingo 개발일지 - 2025-05-31 (20개 커밋)",
      "date": "2025-05-31T00:00:00.000Z",
      "category": "dev-log",
      "description": "문서 구조 개편 및 파일명 정리",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-devlog-0001",
      "title": "fallingo 개발일지 - 2025-05-28 ~ 2025-05-29 (20개 커밋)",
      "date": "2025-05-29T00:00:00.000Z",
      "category": "dev-log",
      "description": "fallingo 프로젝트 초기 설정 및 기획 문서 작성",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "lang": "ko"
    }
  ],
  "totalCount": 50,
  "lastUpdated": "2025-11-17T09:35:56.789Z",
  "fullPosts": [
    {
      "slug": "01-ai-journey-start",
      "title": "AI 개발 방법론 1 - AI와의 첫 만남, 그리고 시작",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "content": "# AI와의 첫 만남, 그리고 시작\n\n## 2023년 6월, ChatGPT 해커톤\n\n2023년 6월, 당시 재직 중이던 회사에서 ChatGPT 해커톤이 열렸습니다. \"AI가 어떻게 진짜 일을 해?\" 하는 생각에 솔직히 별로 관심이 없었습니다. 하지만 회사에서 1등 서비스는 사업으로 전환을 적극 검토한다고 하더군요. 그 말에 귀가 솔깃해서 3명의 팀원을 직접 섭외해 참여했습니다.\n\n### Trust Go! (믿고!)\n\n여행 플랜을 만들어주는 서비스를 만들었습니다. 사용자에게 하고 싶은 여행과 예산을 문답식으로 받고, GPT에 요청해서 답변을 받은 뒤, 회사 사이트에서 판매 중인 숙박 시설과 연결하는 구조였습니다. [GitHub 저장소](https://github.com/trust-go/gpt)\n\n결과는 1등이었고, 상품으로 PS5도 받았습니다. 하지만... 사업 전환은 되지 않았습니다.\n\n---\n\n## JetBrains AI Assistant\n\n그 후 회사가 AI 도입에 적극적으로 변했습니다. JetBrains AI Assistant 라이선스를 사용 희망자에게만 구독해주었고, 저도 신청해서 써봤습니다. 결과는... 실무에서 쓰기 어려울 수준이었습니다. 거의 사용하지 않았고, \"역시, AI는 아직 한참 멀었구나\"라는 생각만 했습니다.\n\n---\n\n## 2025년 1월, 새로운 세계\n\n퇴사를 하고 이직 준비를 할 때였습니다. 그때쯤 AI가 엄청난 열풍이었습니다. 바이브 코딩이라는 용어도 생기고, 프롬프트 엔지니어라는 신종 직종도 생기는 중이었습니다. 면접을 다니면서 AI 사용에 대한 질문을 많이 받았고, 이제 진지하게 알아봐야겠다 싶어 유튜브와 블로그를 찾아보기 시작했습니다.\n\n---\n\n## 2025년 4월 21일, Cursor\n\n지금 회사에 출근하는 날이었습니다. 상급자에게 \"AI 사용해보고 싶은데 지원해주세요\"라고 요청했고, 승인이 떨어져 그날부터 Cursor를 사용하기 시작했습니다.\n\n### 처음 며칠\n\n유튜브와 블로그를 찾아봤습니다. 당시 엄청난 열풍이었기에 다양하고 많은 채널에서 Cursor를 소개하고 있었습니다. 하지만 사실 잘 모르겠었습니다. 그래도 VSCode 기반이라 에디터로 사용하는 데는 어려움이 없었습니다.\n\n### 업무를 시작하면서\n\n그러다 업무를 시작하게 되면서 제대로 경험하게 되었습니다. AI가 나의 업무에 얼마나 도움이 되는지, 또 나의 시간을 얼마나 줄여주는지를 말입니다.\n\n---\n\n## 인수인계 자료가 없었다\n\n첫 출근했을 때 이전 담당자는 없었고, 업무 인수인계 자료도 준비된 게 하나도 없었습니다. 그런데 새로운 기능을 추가해야 했습니다. 이제 겨우 AI에게 질문 몇 번 던져보고 채팅하는 재미를 알아가던 차에 업무에 사용하려니 막막했습니다.\n\n소스코드를 분석할 시간도 없이 일을 시작해야 했는데, 그때 물어봤습니다. \"이 프로젝트에 xxx 기능이 사용되는 곳이 있을까?\"\n\n### 신뢰의 시작\n\n이 한 문장이 제가 AI를 신뢰하는 시작점이 되었습니다. 소스코드 전체에서 제가 요청했던 컴포넌트와 로직을 딱! 분석해서 알려줬습니다. 1주일 걸릴 작업을 3일에 완료했습니다.\n\n---\n\n## 간단한 질문에는 완벽한 답변\n\n처음엔 컴포넌트 하나, 함수 하나 이런 위주의 질문을 했습니다. 이럴 때는 AI 답변에 실수가 없었습니다.\n\n### 복잡해지면 무너진다\n\n하지만 요구사항이 복잡해질수록 AI 답변이 의도와 멀어지는 것을 경험했습니다. 그럴 때는 작업하던 내용을 다 버리고 다시 처음부터 시작했습니다. 요구사항을 단계별로 나눠서 질문하니 다시 적절한 답변을 주었습니다.\n\n---\n\n## 규칙을 만들다\n\n간헐적으로 더 나은 코드 스타일이 있는데 레거시한 스타일로 작성해줄 때가 있었습니다. 그때마다 코드 수정을 요청하는 과정을 반복하다 보니, Cursor에는 룰을 만들어서 답변할 때 참고하도록 할 수 있는 기능이 있다는 걸 알게 되었습니다. 좋은 규칙을 만들기 위해 AI와 엄청난 대화와 검토를 했고, 최종적으로 [Cursor Rules](https://gist.github.com/su-record/a9715fc36d7bc92b2ba359aad362b699)를 만들었습니다.\n\n### 규칙의 한계\n\n하지만 이것도 생각처럼 잘 안 될 때가 많았습니다. 세션마다 규칙을 읽고 시작하는 게 항상 균일하지 못했고, 규칙을 읽더라도 어느 순간 잊어버리기도 했습니다. 그래서 \"규칙을 준수하고 있지?\" 하고 수시로 확인하는 습관을 갖게 되었습니다.\n\n---\n\n## 업무에서의 성공\n\nAI를 업무에 활용하는 패턴이 생겼습니다. 전체 프로젝트에서 관련 코드를 찾아 소스코드를 분석하고, 이미 구현된 기능이 있는지 확인한 뒤, 없으면 새로 개발하고 있으면 재사용 가능하도록 리팩토링하는 방식이었습니다. 이런 과정으로 업무를 하게 되니, 새로운 페이지 개발 정도는 1-2시간이면 완료되었습니다.\n\n### 주변 반응\n\n\"원래 AI 사용을 했던 거죠?\" 회사에서 저만 AI로 업무를 하고 있었고, 일 처리도 빠르다 보니 사원들이나 팀장님들이 묻는 질문이었습니다. 저는 지금 회사에 와서 처음으로 제대로 사용해보는 중이었는데, 주변에서는 엄청 신기하게 여겼습니다.\n\n---\n\n## 2025년 5월, \"내 앱을 만들 수 있지 않을까?\"\n\n어느 날 출근길에 Gemini와 채팅을 하고 있었습니다. 문득, 내 앱을 가지고 싶었던 지난날 기억이 떠올랐습니다. \"AI는 분명 나보다 훨씬 많은 지식을 가지고 있는데, 할 수 있는 거 아닌가?\" Gemini에게 물어봤고, 당연하게도 할 수 있다는 답변을 받았습니다. 출근 시간 동안 Gemini와 기획서 초안을 만들었습니다.\n\n---\n\n## 2016년의 아이디어\n\n2016년 1월에 구상했던 아이템이 있었습니다.\n\n### 위치 기반 실시간 인증 SNS\n\n제가 생각하는 SNS의 콘텐츠는 '인증'이었습니다. 그 인증하는 방식을 '오직 실시간'으로 제한을 두는 SNS였습니다. 친구끼리 위치를 공유하고, 피드에 위치가 자동으로 기록되며, 지도에서 내 위치 기준 인근 피드를 확인할 수 있는 구조였습니다.\n\n낯선 나라에 여행을 갔을 때 같은 시간, 같은 공간에 누군가 있다는 생각을 가짐으로써 덜 외로울 수 있습니다. 아이를 해외에 여행 보낸 부모는 위치를 확인할 수 있어서 좀 더 안심할 수 있습니다.\n\n### FlavorPoint → fallingo\n\n이 위치 기반 인증을 새로운 앱에 포함하기로 했습니다. 포함이라기보다는 당시의 아이디어를 더 확장한 것이었습니다. 처음 이름은 FlavorPoint였다가, 도메인을 구매하는 시점에 \"falling in go\"의 의미로 fallingo로 명칭을 변경했습니다. 위치 기반으로 음식 메뉴를 추천하는 SNS입니다.\n\n---\n\n## 한 장짜리 문서\n\n마크다운 한 장짜리 문서에 위치 기반 음식 추천 SNS에 대한 설명을 작성했습니다. Cursor에 요청했더니 몇십 분 만에 앱의 UI를 로컬에서 확인할 수 있었습니다. 너무 마음에 들어서 동영상으로 촬영까지 했습니다. \"제대로 만들어 봐야겠다.\"\n\n---\n\n## Gemini로 기획하다\n\nfallingo의 모든 기획은 Gemini로 했습니다. 이전 내용을 복사해서 \"이런 걸 논의했고, 좀 더 구체적인 기획서를 만들어야겠다\"로 시작해서 갖가지 기능들과 포함될 만한 사항, 체크되어야 할 사항에 대한 제안도 받았습니다. 기획 문서를 구체적으로 완성하는 데 1주일 정도 걸렸습니다.\n\n---\n\n## Claude를 만나다\n\n이때쯤 Claude를 알게 되었습니다. Cursor도 에이전트를 Auto로 사용 중이었다가, 모델을 선택할 수 있는 것을 알게 되었습니다.\n\n### 새로운 세계\n\nClaude를 처음 사용해본 날... 새로운 세계를 마주하는 것 같았습니다. 요청하는 사항에 대해서 완벽에 가까운 답변을 주었습니다. 이때부터 Claude를 주로 사용하기 시작했고, Claude를 따로 결제하기도 했습니다.\n\n---\n\n## 여정의 시작\n\n9년 전 포기했던 꿈을 2025년 AI와 함께 다시 꺼냈습니다. 하지만 이제부터가 진짜 여정의 시작이었습니다. AI는 간단한 요청에는 완벽하지만, 복잡해지면 무너졌습니다. 이것을 어떻게 극복할 것인가?\n\n---\n\n> 다음 편: [AI 개발 방법론 2 - 첫 번째 벽, 복잡성](02-ai-first-wall-complexity.md)",
      "description": "2023년 ChatGPT 해커톤 1등부터 2025년 Cursor까지. AI 개발 도구와 함께한 여정의 시작",
      "tags": [
        "ai-first",
        "chatgpt",
        "cursor",
        "claude",
        "gemini"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/01-ai-journey-start.md"
    },
    {
      "slug": "02-ai-first-wall-complexity",
      "title": "AI 개발 방법론 2 - 첫 번째 벽, 복잡성",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "content": "# 첫 번째 벽, 복잡성\r\n\r\n> 이전 편: [AI 개발 방법론 1 - AI와의 첫 만남, 그리고 시작](01-ai-journey-start.md)\r\n\r\n## 업무에서 확인한 AI의 능력\r\n\r\n2025년 4월 21일, 회사에서 Cursor를 사용하기 시작했습니다. 처음 며칠간은 유튜브와 블로그를 찾아봤습니다. 당시 AI 개발 도구가 엄청난 열풍이었기에 수많은 채널에서 Cursor를 소개하고 있었습니다. 하지만 솔직히 잘 모르겠었습니다. VSCode 기반이라 에디터로 사용하는 데는 어려움이 없었지만, \"어떻게 써야 잘 쓰는 건지\"는 막연했습니다.\r\n\r\n그러다 업무를 시작하면서 제대로 경험하게 되었습니다. AI가 나의 업무에 얼마나 도움이 되는지, 또 나의 시간을 얼마나 줄여주는지를 말입니다.\r\n\r\n### 인수인계 자료가 없었다\r\n\r\n첫 출근했을 때 이전 담당자는 없었고, 업무 인수인계 자료도 준비된 게 하나도 없었습니다. 그런데 새로운 기능을 추가해야 했습니다. 이제 겨우 AI에게 질문 몇 번 던져보고 채팅하는 재미를 알아가던 차에 업무에 사용하려니 막막했습니다.\r\n\r\n소스코드를 분석할 시간도 없이 일을 시작해야 했는데, 그때 물어봤습니다. \"이 프로젝트에 xxx 기능이 사용되는 곳이 있을까?\" 이 한 문장이 제가 AI를 신뢰하는 시작점이 되었습니다. 소스코드 전체에서 제가 요청했던 컴포넌트와 로직을 딱! 분석해서 알려줬습니다. 1주일 걸릴 작업을 3일 만에 완료했습니다.\r\n\r\n### 간단한 질문에는 완벽한 답변\r\n\r\n처음엔 컴포넌트 하나, 함수 하나 이런 위주의 질문을 했습니다. 이럴 때는 AI 답변에 실수가 없었습니다. \"이 컴포넌트를 리팩토링해줘\", \"이 함수 성능을 개선해줘\" 같은 단순하고 명확한 요청에는 완벽에 가까운 답변을 주었습니다.\r\n\r\n### 복잡해질수록 무너지는 AI\r\n\r\n하지만 요구사항이 복잡해질수록 AI 답변이 의도와 멀어지는 것을 경험했습니다. 그럴 때는 작업하던 내용을 다 버리고 다시 처음부터 시작했습니다. 요구사항을 단계별로 나눠서 질문하니 다시 적절한 답변을 주었습니다.\r\n\r\n### 규칙을 만들다\r\n\r\n간헐적으로 더 나은 코드 스타일이 있는데 레거시한 스타일로 작성해줄 때가 있었습니다. 그때마다 코드 수정을 요청하는 과정을 반복하다 보니, Cursor에는 룰을 만들어서 답변할 때 참고하도록 할 수 있는 기능이 있다는 걸 알게 되었습니다. 좋은 규칙을 만들기 위해 AI와 엄청난 대화와 검토를 했고, 최종적으로 [Cursor Rules for React/TypeScript](https://gist.github.com/su-record/a9715fc36d7bc92b2ba359aad362b699)를 만들었습니다.\r\n\r\n하지만 이것도 생각처럼 잘 안 될 때가 많았습니다. 세션마다 규칙을 읽고 시작하는 게 항상 균일하지 못했고, 규칙을 읽더라도 어느 순간 잊어버리기도 했습니다. 그래서 \"규칙을 준수하고 있지?\" 하고 수시로 확인하는 습관을 갖게 되었습니다.\r\n\r\n### 업무에서의 성공\r\n\r\nAI를 업무에 활용하는 패턴이 생겼습니다. 전체 프로젝트에서 관련 코드를 찾아 소스코드를 분석하고, 이미 구현된 기능이 있는지 확인한 뒤, 없으면 새로 개발하고 있으면 재사용 가능하도록 리팩토링하는 방식이었습니다. 이런 과정으로 업무를 하게 되니, 새로운 페이지 개발 정도는 1-2시간이면 완료되었습니다.\r\n\r\n\"원래 AI 사용을 했던 거죠?\" 회사에서 저만 AI로 업무를 하고 있었고, 일 처리도 빠르다 보니 사원들이나 팀장님들이 묻는 질문이었습니다. 저는 지금 회사에 와서 처음으로 제대로 사용해보는 중이었는데, 주변에서는 엄청 신기하게 여겼습니다.\r\n\r\n---\r\n\r\n## \"혹시 내 앱을 만들 수 있지 않을까?\"\r\n\r\n2025년 5월 어느 날 출근길에 Gemini와 채팅을 하고 있었습니다. 문득, 내 앱을 가지고 싶었던 지난날 기억이 떠올랐습니다. AI는 분명 나보다 훨씬 많은 지식을 가지고 있는데, 할 수 있는 거 아닌가? Gemini에게 물어봤고, 당연히 할 수 있다는 답변을 받았습니다. 출근 시간 동안 Gemini와 기획서 초안을 만들었습니다.\r\n\r\n### 2016년의 아이디어\r\n\r\n위치 기반 앱은 2016년 1월에 제가 구상했던 아이템이었습니다. 제가 생각하는 SNS의 콘텐츠는 '인증'이었고, 그 인증하는 방식을 '오직 실시간'으로 제한을 두는 SNS를 생각했었습니다. 친구끼리 위치를 공유하고, 피드에 위치가 자동으로 기록되며, 지도에서 내 위치 기준 인근 피드를 확인할 수 있는 구조였습니다.\r\n\r\n낯선 나라에 여행을 갔을 때 같은 시간, 같은 공간에 누군가 있다는 생각을 가짐으로써 덜 외로울 수 있습니다. 아이를 해외에 여행 보낸 부모는 위치를 확인할 수 있어서 좀 더 안심할 수 있습니다. 이 위치 기반 인증을 새로운 앱에 포함하기로 했습니다. 포함이라기보다는 당시의 아이디어를 더 확장한 것이 지금의 fallingo가 되었습니다.\r\n\r\n### 한 장짜리 문서로 시작\r\n\r\n마크다운 한 장짜리 문서에 위치 기반으로 음식 메뉴를 추천하는 SNS에 대한 설명을 만들었습니다. Cursor에 요청했더니 몇십 분 만에 앱의 UI를 로컬에서 확인할 수 있었습니다. 너무 마음에 들어서 동영상으로 동작하는 것을 촬영까지 했습니다. \"제대로 만들어 봐야겠다.\"\r\n\r\n---\r\n\r\n## Claude를 만나다\r\n\r\nfallingo의 모든 기획은 Gemini로 했습니다. 이전 내용을 복사해서 \"이런 걸 논의했고, 좀 더 구체적인 기획서를 만들어야겠다\"로 시작해서 갖가지 기능들과 포함될 만한 사항, 체크되어야 할 사항에 대한 제안도 받았습니다. 기획 문서를 구체적으로 완성하는 데 1주일 정도 걸렸습니다.\r\n\r\n이때쯤 Claude를 알게 되었습니다. Cursor도 에이전트를 Auto로 사용 중이었다가, 모델을 선택할 수 있는 것을 알게 되었습니다.\r\n\r\n### 새로운 세계\r\n\r\nClaude를 처음 사용해본 날... 새로운 세계를 마주하는 것 같았습니다. 요청하는 사항에 대해서 완벽에 가까운 답변을 주었습니다. 이때부터 Claude를 주로 사용하기 시작했고, Claude를 따로 결제하기도 했습니다.\r\n\r\n### 첫 번째 배신\r\n\r\n새로운 모델, 제게 엄청난 신뢰를 받고 있는 Claude에게 기획서를 읽고 개발을 시작하라고 했습니다. 2번째 개발을 시작했습니다. 결과는... 그럴싸하지만, 모자란 그런 결과물이 나왔습니다. 요청 사항에 항상 정답을 주던 Claude에게 배신감도 느꼈습니다.\r\n\r\n---\r\n\r\n## 개발 문서가 필요하다\r\n\r\n고민한 끝에 결론을 내렸습니다. \"AI가 개발을 할 수 있는 개발 문서를 만들자.\" 물론, 개발 문서도 AI가 작성했습니다. \"이 기획서로 개발을 하기 위한 문서가 필요해. AI가 코딩을 하는 가이드 문서야.\"\r\n\r\n### 왜 문서가 필요한가\r\n\r\nAI는 세션이 종료되면 이전에 하던 작업을 모릅니다. 문서가 잘 준비되어 있으면, 세션이 바뀌어도 계속해서 작업을 이어갈 수 있을 것이라 생각했습니다. 일종의 작업 지시서였습니다. 작업자(세션)가 바뀌어도 작업 지시서가 명확하면 계속 개발을 이어갈 수 있을 테니까요.\r\n\r\n### 토큰의 벽\r\n\r\n이때부터 토큰 부족에 시달리게 되었습니다. 문서를 작업하는 것은 꽤 많은 토큰을 소모했습니다. 더 많은 토큰을 확보하려다 보니 Claude Pro를 구독하게 되었습니다.\r\n\r\n### 무너지는 일관성\r\n\r\n하지만 생각대로 쉽게 진행되지 않았습니다. 기획 문서를 개발 가이드로 작성하다 보니, 수십 장의 문서가 만들어졌습니다. 처음 개발 문서가 준비되고 개발을 시작하려 했습니다. 세션이 종료되고, 새 세션이 시작되면서 기획 문서를 참조해서 개발 가이드를 이어서 작성하게 했습니다.\r\n\r\n문제가 발생했습니다. 개발 가이드의 내용에 일관성이 없었습니다. 똑같은 기획서를 참조해서 문서 작성을 이어 갔지만, 일관성은 유지되지 않았습니다.\r\n\r\n---\r\n\r\n## 복잡성이라는 벽\r\n\r\n업무에서는 완벽했던 AI였습니다. 컴포넌트 하나, 함수 하나를 만들 때는 실수가 없었습니다. 하지만 프로젝트 전체를 만들려고 하니 무너졌습니다. 단순한 요청에는 완벽한 답변을 주지만, 복잡한 요구사항에는 일관성을 잃었습니다. 이것이 첫 번째 벽, 복잡성이었습니다.\r\n\r\n---\r\n\r\n> 다음 편: [AI 개발 방법론 3 - 두 번째 벽, 일관성](03-ai-second-wall-consistency.md)",
      "description": "업무에서는 완벽했던 AI가 내 프로젝트에서는 왜 이상한 코드를 만들어낼까? 복잡성이라는 첫 번째 벽을 마주하다",
      "tags": [
        "ai-first",
        "cursor",
        "claude",
        "complexity",
        "fallingo"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/02-ai-first-wall-complexity.md"
    },
    {
      "slug": "03-ai-second-wall-consistency",
      "title": "AI 개발 방법론 3 - 두 번째 벽, 일관성",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "content": "# 두 번째 벽, 일관성\r\n\r\n> 이전 편: [AI 개발 방법론 2 - 첫 번째 벽, 복잡성](02-ai-first-wall-complexity.md)\r\n\r\n## 수십 번의 리셋\r\n\r\n일관성이 틀어진 문서를 처음엔 아까워서 수정을 해보려 했습니다. 안 되었습니다. 수정하는 것보다 새롭게 하는 게 더 빠르고 정확할 가능성이 높았습니다. 다시 시작했습니다. 또 일관성이 무너졌습니다. 다시 시작했습니다. 수십 번을 반복했습니다.\r\n\r\n### 프롬프팅에 대한 고민\r\n\r\n이 과정 중에 프롬프팅에 대해 고민하게 되었습니다. 역으로 AI에게 물어봤습니다. \"어떤 식으로 질문을 해야 잘 이해할 수 있어?\" 보통 AI는 이전 대화를 기반으로 답변을 하려고 하기 때문에 종종 전혀 상관없는 답변을 들어야 했습니다. 어떻게 질문을 해야 하나를 고민하고 AI와 대화한 끝에 [프롬프팅 가이드](https://gist.github.com/su-record/70f75be7041420e59bcd92bf91719d47)를 만들었습니다.\r\n\r\n### 포기하려던 순간\r\n\r\n항상 새롭게 시작하는 것을 10번을 넘어서부터는 그만해야겠다 싶었습니다. 6월 말부터 7월까지 한 달 이상을 계속 반복하고 있었습니다. 결국 안 되는구나 싶었습니다. 제 생각에 문서가 훌륭하다 싶었지만, 개발에서 어긋나버리면 제가 소스코드를 수정할 수가 없었습니다.\r\n\r\n### 기술 스택 결정의 이유\r\n\r\n앱을 개발하면서 바이브 코딩으로 완성해 내고 싶었습니다. 어차피 백엔드는 전혀 지식이 없는 상태였습니다. Google Cloud 환경에서 배포할 예정이었고, AI가 제안한 FastAPI를 채택했으며, DB는 Cloud SQL을 사용하기로 했습니다. 프론트엔드는 익숙한 React Native 대신 Flutter를 선택했습니다.\r\n\r\n프론트엔드 개발자인 저조차 Flutter 코드를 모릅니다. 그래서 소스코드에서 오류가 발생하면, 제가 임의로 코드를 분석하고 오류를 수정할 수준이 안 되었습니다. 그러다 보니 항상 다시 시작할 수밖에 없었습니다.\r\n\r\n---\r\n\r\n## hi-ai MCP를 만들다\r\n\r\n이때쯤 MCP를 만들어보자는 생각을 했습니다. 바이브 코딩에 최적화된 통합 MCP였습니다. 특정한 키워드가 입력되면 메모리에 대화를 저장하고, 세션에서 인사말을 입력하면 이전 기록을 불러와서 세션을 시작하는 MCP였습니다. 그렇게 설계하면서 여러 가지 기능 도구들이 추가된 것이 지금의 [hi-ai](https://github.com/su-record/hi-ai)입니다.\r\n\r\n### 프로젝트와 젬\r\n\r\nClaude의 프로젝트와 Gemini의 젬을 도입해서 사용했습니다. 미리 참조할 문서와 지침을 정해두면 일관성을 가질 것이라 생각했습니다. 하지만... 여전히 일관성은 무너졌습니다.\r\n\r\n---\r\n\r\n## 원인을 찾다\r\n\r\n이 부분을 정말 많이 고민했습니다. 어떻게 해야 되나... Claude의 프로젝트, Gemini의 젬도 결국 정답은 아니었습니다. 이것은 제가 해결할 수 없는, AI의 세션당 처리 가능한 토큰의 문제인 듯싶었습니다. 기술적인 한계랄까요? 극복해낼 방법이 필요했습니다.\r\n\r\n### AI와의 대화\r\n\r\n문제를 해결하려면 좀 더 세분화된 작업이 필요하지 않을까 하는 생각을 했습니다. 기획 문서 → 개발 가이드의 과정에서 단계를 추가하기로 했습니다. 이 부분은 AI와 대화를 통해서 결론을 얻었습니다.\r\n\r\n---\r\n\r\n## 돌파구: 순차적 문서 작성\r\n\r\n다음과 같은 단계를 거쳐서 문서를 완성해 가기로 했습니다. 기획서 → 엔티티 추출 → ERD, 데이터 모델 → 데이터베이스, 비즈니스 로직 → API. 순차적으로, 단계별로 진행하기로 했습니다.\r\n\r\n### 교차 검증\r\n\r\n한 번만 하는 게 아니었습니다. 여러 세션을 열어두고 동일하게 작업을 하도록 했습니다. 각각의 세션마다 서로 다른 문서를 작성했지만, 일부분씩 공통적으로 동일한 부분들이 발생함을 알 수 있었습니다. 그래서 그 부분들을 취합하고, 취합한 내용을 포함해서 다시 작성하게 하는 과정을 무수히 반복했습니다. 어느 순간 표현은 다르지만, 일관성을 갖게 되었습니다.\r\n\r\n### AI는 너무 유능해서 문제다\r\n\r\n그리고 왜 일관성이 무너졌는지를 이때가 되어서야 명확하게 알 수 있었습니다. \"AI는 기본적으로 사용자의 요구사항을 다양한 각도로 계산과 고민하고 결과를 도출합니다.\" 이 얘기는 제가 A를 요구하면 AI는 A의 답변이 더 완성도를 가질 수 있도록 B와 C를 붙여서 ABC로 답변을 하는 것이었습니다. 즉, 너무 유능했기 때문에 발생하는 이슈였습니다.\r\n\r\n### 핵심 규칙\r\n\r\n5가지 과정을 반복하면서 AI에게 항상 요청했습니다. \"문서에 있는 내용에 누락이 없어야 하고, 문서에 없는 내용을 임의로 추가하지 말 것.\" 그 결과 개발을 시작할 수준의 문서를 완성할 수 있었습니다.\r\n\r\n---\r\n\r\n## 백엔드 우선 전략\r\n\r\n개발하는 방법도 변경했습니다. 기존에는 백엔드와 프론트를 동시에 개발하거나, 백엔드 먼저, 또는 프론트엔드 먼저 등 순서가 일정하지 않았습니다. 항상 백엔드 우선으로 방향을 정했습니다.\r\n\r\n### 왜 백엔드 우선인가\r\n\r\n개발된 제품이 제 기능을 수행하기 위한 최소한의 조건이 백엔드라고 생각했습니다. 데이터베이스와 데이터를 핸들링하는 API가 탄탄하면, 프론트엔드는 사실 큰 무리가 없으니까요.\r\n\r\n---\r\n\r\n## 실전 적용\r\n\r\n이 방법으로 업무에서 새로운 프로젝트에도 적용했습니다. 전체 볼륨이 fallingo보다 훨씬 작은 회의실 예약 서비스였는데, 꽤 괜찮게 완성했습니다. 이후로도 계속 업무에 적용해서 사용 중입니다.\r\n\r\n---\r\n\r\n## 여전히 남은 문제\r\n\r\n순차적 문서 작성과 교차 검증으로 많이 개선되었습니다. 하지만 여전히 문제가 있었습니다. 문서가 흩어져 있어 관리가 어렵고, 일관성 체크를 수동으로 해야 하며, 문서에 빠진 부분이 있는지 확인하기 어려웠습니다. 더 나은 방법이 필요했습니다.\r\n\r\n---\r\n\r\n> 다음 편: [AI 개발 방법론 4 - 돌파구, 순차적 문서 작성](04-ai-breakthrough-sequential.md)",
      "description": "수십 장의 문서, 수십 번의 리셋. 일관성이 무너지는 AI와 싸우며 찾은 해답들",
      "tags": [
        "ai-first",
        "claude",
        "gemini",
        "consistency",
        "mcp",
        "hi-ai"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/03-ai-second-wall-consistency.md"
    },
    {
      "slug": "04-ai-breakthrough-sequential",
      "title": "AI 개발 방법론 4 - 돌파구, 순차적 문서 작성",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "content": "# 돌파구, 순차적 문서 작성\r\n\r\n> 이전 편: [AI 개발 방법론 3 - 두 번째 벽, 일관성](03-ai-second-wall-consistency.md)\r\n\r\n## 5단계 문서 작성 프로세스\r\n\r\n수십 번의 실패 끝에 정립한 방법입니다.\r\n\r\n### 1단계: 기획서\r\n\r\n모든 것의 시작으로, \"무엇을 만들 것인가\"를 정의합니다. 서비스 목적, 핵심 기능, 사용자 플로우, 기대 효과를 작성합니다. 이 단계에서는 기술적인 내용을 배제하고 순수하게 \"만들고 싶은 것\"만 작성합니다.\r\n\r\n### 2단계: 엔티티 추출\r\n\r\n기획서에서 핵심 개념들을 추출합니다. 예를 들어 fallingo의 경우 User (사용자), Feed (피드), Restaurant (식당), Comment (댓글), Like (좋아요), Location (위치) 등입니다. 각 엔티티가 어떤 속성을 가져야 하는지 정의하고, 이때 관계도 함께 정의합니다. User는 여러 Feed를 가지고, Feed는 하나의 Restaurant에 속하며, Feed는 여러 Comment를 가지는 식입니다.\r\n\r\n### 3단계: ERD, 데이터 모델\r\n\r\n엔티티를 기반으로 실제 데이터베이스 스키마를 설계합니다. 테이블 구조, 컬럼 타입, 인덱스, 제약 조건, 관계 설정을 정의하고, 이 단계에서 정규화도 고려합니다.\r\n\r\n### 4단계: 데이터베이스, 비즈니스 로직\r\n\r\n데이터 모델을 기반으로 비즈니스 로직을 설계합니다. CRUD 연산, 데이터 검증 규칙, 권한 체크, 트랜잭션 처리 등 \"어떻게 데이터를 다룰 것인가\"를 정의합니다.\r\n\r\n### 5단계: API\r\n\r\n비즈니스 로직을 기반으로 API 명세를 작성합니다. 엔드포인트, 요청/응답 스키마, 상태 코드, 에러 처리 등 \"어떻게 프론트엔드와 통신할 것인가\"를 정의합니다.\r\n\r\n---\r\n\r\n## 교차 검증 프로세스\r\n\r\n단계별로 문서를 작성하되, 한 번만 하지 않습니다.\r\n\r\n### 다중 세션 작업\r\n\r\n여러 세션을 열어두고 동일하게 작업합니다. 예를 들어 엔티티 추출 단계에서 세션 A, B, C 각각 독립적으로 엔티티 추출 작업을 진행합니다.\r\n\r\n### 공통점 찾기\r\n\r\n각 세션의 결과물을 비교하여 공통적으로 나온 부분들을 추출합니다. 예를 들어 세션 A는 User, Feed, Restaurant, Comment, Like를, 세션 B는 User, Post, Restaurant, Reply, Reaction을, 세션 C는 Member, Feed, Place, Comment, Like를 도출했다면, 공통점은 User/Member (사용자), Feed/Post (피드), Restaurant/Place (장소), Comment/Reply (댓글), Like/Reaction (반응)입니다. 용어는 다르지만 개념은 동일합니다.\r\n\r\n### 취합 및 재작성\r\n\r\n공통점을 취합하고, 이를 포함해서 다시 작성하게 합니다. \"다음 엔티티들을 기반으로 문서를 작성해줘: User (사용자), Feed (피드), Restaurant (식당), Comment (댓글), Like (좋아요). 문서에 있는 내용에 누락이 없어야 하고, 문서에 없는 내용을 임의로 추가하지 말 것.\"\r\n\r\n### 반복\r\n\r\n이 과정을 무수히 반복합니다. 처음에는 세션마다 결과가 달랐지만, 반복할수록 표현은 다르지만 일관성을 갖게 됩니다.\r\n\r\n---\r\n\r\n## 핵심 규칙\r\n\r\n### 규칙 1: 누락 금지\r\n\r\n\"문서에 있는 내용에 누락이 없어야 한다.\" AI는 종종 \"이 정도는 당연하니까\"라고 판단해서 일부 내용을 생략합니다. 하지만 모든 내용을 빠짐없이 포함해야 합니다.\r\n\r\n### 규칙 2: 추가 금지\r\n\r\n\"문서에 없는 내용을 임의로 추가하지 말 것.\" 이것이 가장 중요한 규칙입니다. AI는 기본적으로 사용자의 요구사항을 다양한 각도로 계산하고 결과를 도출합니다. 제가 A를 요구하면 AI는 \"A만으로는 부족하다. B와 C를 추가하면 더 좋겠다\"고 판단해서 ABC를 만듭니다. 이것이 바로 일관성이 무너지는 원인이었습니다.\r\n\r\n### 규칙 3: 순차 진행\r\n\r\n\"이전 단계가 완료되기 전에 다음 단계로 넘어가지 말 것.\" 기획서가 완성되지 않았는데 엔티티를 추출하면 안 되고, 엔티티가 확정되지 않았는데 ERD를 만들면 안 됩니다. 순차적으로, 단계별로 진행합니다.\r\n\r\n---\r\n\r\n## 백엔드 우선 전략\r\n\r\n문서가 완성되면 개발을 시작합니다. 항상 백엔드부터 시작합니다.\r\n\r\n### 왜 백엔드 우선인가\r\n\r\n프론트엔드는 데이터를 보여주는 역할이고, 백엔드는 데이터를 다루는 역할입니다. 데이터를 다루는 로직이 탄탄하면, 보여주는 건 상대적으로 쉽습니다.\r\n\r\n### 최소 기능 단위로 개발\r\n\r\n백엔드를 개발할 때도 단계별로 진행합니다. 데이터베이스 스키마 구현, CRUD 기본 API 구현, 비즈니스 로직 추가, 권한 체크 추가, 에러 핸들링 추가 순서로 한 번에 모든 걸 구현하지 않습니다.\r\n\r\n---\r\n\r\n## 실전 적용 사례\r\n\r\n### 업무: 회의실 예약 서비스\r\n\r\nfallingo보다 훨씬 작은 프로젝트였지만 동일한 방법을 적용했습니다. 결과는 성공이었습니다. 1주일 만에 백엔드 + 프론트엔드를 완성했습니다.\r\n\r\n### fallingo: 백엔드 완성\r\n\r\n순차적 문서 작성 방법으로 백엔드를 완성했습니다. 145개 API 엔드포인트, FastAPI + Cloud SQL, Redis 캐싱, FCM 푸시 알림, 소셜 로그인 (Google, Apple) 모두 AI와 함께 만들었습니다.\r\n\r\n---\r\n\r\n## 여전히 남은 과제\r\n\r\n순차적 문서 작성으로 많이 개선되었지만, 여전히 문제가 있었습니다.\r\n\r\n### 문제 1: 문서 관리\r\n\r\n문서가 기획서.md, 엔티티.md, ERD.md, 비즈니스로직.md, API명세.md 등으로 흩어져 있어서 어떤 문서가 최신인지 알기 어렵습니다.\r\n\r\n### 문제 2: 일관성 검증\r\n\r\n교차 검증을 수동으로 해야 합니다. 자동화할 방법이 없을까?\r\n\r\n### 문제 3: 변경 관리\r\n\r\n기능을 수정하면 모든 문서를 업데이트해야 합니다. 하나라도 놓치면 문서와 코드가 어긋납니다. 이것을 자동으로 체크할 방법이 없을까?\r\n\r\n---\r\n\r\n## 그래도 발전했다\r\n\r\n수십 번 리셋하던 때에 비하면 엄청난 발전이었습니다. 이제는 프로젝트를 완성할 수 있게 되었습니다. 하지만 더 나은 방법이 있을 것 같았습니다. 구조적으로 일관성을 보장하는 시스템, 그런 게 있다면...\r\n\r\n---\r\n\r\n> 다음 편: [AI 개발 방법론 5 - 완성, SpecKit과 그 너머](05-ai-completion-speckit.md)",
      "description": "5단계 순차적 문서 작성과 교차 검증. 수십 번의 실패 끝에 찾은 AI와 협업하는 방법",
      "tags": [
        "ai-first",
        "methodology",
        "sequential",
        "documentation"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/04-ai-breakthrough-sequential.md"
    },
    {
      "slug": "05-ai-completion-speckit",
      "title": "AI 개발 방법론 5 - 완성, SpecKit과 그 너머",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "methodology",
      "content": "# 완성, SpecKit과 그 너머\r\n\r\n> 이전 편: [AI 개발 방법론 4 - 돌파구, 순차적 문서 작성](04-ai-breakthrough-sequential.md)\r\n\r\n## 2025년 10월 22일 오전\r\n\r\n지인으로부터 연락이 왔습니다. \"SpecKit 써봤어? 진짜 편해.\" SpecKit? 처음 듣는 이름이었습니다. 지인도 적용해서 만들고 있는데 확실히 편리한 점이 많다고 했습니다. 즉시 찾아봤습니다.\r\n\r\n---\r\n\r\n## SpecKit을 만나다\r\n\r\n[SpecKit](https://github.com/AnthusAI/SpecKit)은 AI 개발을 위한 구조화된 문서 시스템이었습니다. 살펴본 후 확신했습니다. \"이거다.\" 제가 그토록 고민해왔던 일관성 유지를 정말 구조적으로 도와주는 시스템이었습니다.\r\n\r\n### SpecKit의 핵심\r\n\r\nSpecKit은 문답 식으로 스펙을 완성하도록 합니다. `/speckit.specify`로 기능 명세를 작성하고, `/speckit.clarify`로 불명확한 부분을 질문하며, `/speckit.plan`으로 구현 계획을 수립하고, `/speckit.tasks`로 작업 목록을 생성한 뒤, `/speckit.implement`로 구현을 실행합니다. 각 단계가 명확하게 분리되어 있고, 이전 단계의 결과를 다음 단계가 참조합니다.\r\n\r\n---\r\n\r\n## 즉각 도입\r\n\r\n바로 fallingo에 적용했습니다. 기존에 작성했던 문서들을 SpecKit 형식으로 마이그레이션했습니다. 충격적인 사실을 발견했습니다.\r\n\r\n### 문서에 빈틈이 있었다\r\n\r\n제가 \"일관성을 가졌다\"고 생각한 문서가 여전히 빈틈이 있었습니다. SpecKit의 `/speckit.clarify` 명령으로 확인한 결과, 사용자 티어 시스템의 포인트 계산 방식 (피드 작성 시 몇 포인트? 댓글 작성 시 몇 포인트?), 위치 인증의 정확도 기준 (GPS 오차 범위는? 건물 안에서는 어떻게 처리?), 이미지 업로드 제한 (최대 파일 크기는? 지원하는 포맷은?) 등 제가 놓쳤던 부분들이 드러났습니다. 이런 빈틈을 찾아서 문답 식으로 스펙을 완성하도록 하는 시스템이었습니다. 너무 늦게 알게 된 게 아쉬울 정도였습니다.\r\n\r\n---\r\n\r\n## 스펙과 플랜 완성\r\n\r\nSpecKit으로 스펙과 플랜을 완성했습니다. 개발하던 소스코드를 검수했고, 그리고 프론트엔드 개발을 시작했습니다.\r\n\r\n### SpecKit 도입 후 변화\r\n\r\n교차 검증을 하지 않게 되었습니다. SpecKit이 구조적으로 일관성을 보장해줬기 때문입니다. 하지만 여전히 소스코드를 끊임없이 의심했습니다. \"이 코드 설명해줘\", \"이상한 점 있으면 찾아서 수정해줘\"처럼 AI가 작성한 코드라도 반드시 검증했습니다.\r\n\r\n---\r\n\r\n## 여전히 남은 문제\r\n\r\nSpecKit을 도입했지만, 여전히 문제가 있었습니다.\r\n\r\n### 문제 1: AI는 너무 많이 도와주려 한다\r\n\r\n언제나 AI가 너무 많이 도와주려는 게 간헐적으로 문제가 되었습니다. \"A 기능 추가해줘\"라고 하면 AI는 \"A를 추가하려면 B와 C도 필요하겠네요\" 하면서 A + B + C를 구현합니다. 요청하지 않은 B와 C가 일관성을 해칩니다.\r\n\r\n### 문제 2: 문서 업데이트 관리\r\n\r\n가장 큰 문제가 개발된 기능에 수정이 필요할 때입니다. 문서 업데이트를 반드시 챙겨야 합니다. 그렇지 않으면 나중에 문서와 개발 내용이 다르면서 문서 기준으로 다시 재정리할 때가 있습니다.\r\n\r\n### 문제 3: 도구의 한계\r\n\r\nSpecKit은 훌륭합니다. 하지만 초보자가 사용하기에는 진입 장벽이 있습니다. Slash command 이해, 문서 구조 이해, 워크플로우 이해가 필요합니다. \"그냥 쉽게 쓸 수 없을까?\"\r\n\r\n---\r\n\r\n## 바이브 코딩 프레임워크 완성\r\n\r\n그래서 만들었습니다. 바이브 코딩을 더 쉽게 하는 프레임워크, **[Vibe](https://github.com/su-record/vibe)**입니다.\r\n\r\n### 컨셉\r\n\r\nSPEC 주도 AI 코딩 프레임워크입니다. 사용자가 `vibe spec \"소셜 로그인 기능\"`이라고 입력하면 Vibe가 EARS 기반 명세를 작성하고, 기술 계획을 수립하며, Phase별 작업으로 분해한 뒤, AI와 함께 개발하고 구현 결과를 검증합니다. 체계적이고 자동화된 프로세스입니다.\r\n\r\n### 핵심 기능\r\n\r\n**38개 MCP 도구 통합** (hi-ai 포함), **7개 전문 AI 에이전트**, EARS 기반 명세 작성, 자동 작업 분해, 한국어/영어 지원, Claude Code 최적화를 제공합니다.\r\n\r\n### 목표\r\n\r\n누구나 쉽게 바이브 코딩으로 원하는 산출물을 만들어낼 수 있게 도와주는 것입니다. 기술을 몰라도, 개발 경험이 없어도 상상한 것을 AI와 함께 만들 수 있게 하는 것이 목표입니다.\r\n\r\n**자세한 내용**: [Vibe: SPEC 주도 AI 코딩 프레임워크](tech-06-vibe-framework.md)\r\n\r\n---\r\n\r\n## 나의 AI 개발 원칙\r\n\r\n지금까지의 경험을 정리하면 다음과 같습니다.\r\n\r\n### 원칙 1: 요구사항을 최대한 자세하게\r\n\r\n내용이 너무 길다고 여겨지면 단계별로 나눕니다. 한 번에 모든 걸 요청하지 말고, 작은 단위로 나눠서 요청합니다.\r\n\r\n### 원칙 2: 반드시 의심하고 확인\r\n\r\nAI를 맹신하지 않습니다. 항상 결과물을 검증합니다. \"이 코드 설명해줘\", \"문제점 있으면 찾아줘\", \"더 나은 방법 있어?\" 등을 항상 물어봅니다.\r\n\r\n### 원칙 3: 문서 중심 개발\r\n\r\n코드보다 문서가 먼저입니다. 문서가 명확하면 코드는 따라옵니다.\r\n\r\n### 원칙 4: 순차적 진행\r\n\r\n이전 단계가 완료되기 전에 다음 단계로 넘어가지 않습니다. 기획 → 엔티티 → ERD → 비즈니스 로직 → API → 개발 순서를 지킵니다.\r\n\r\n### 원칙 5: 백엔드 우선\r\n\r\n데이터를 다루는 로직이 탄탄하면 UI는 쉽습니다.\r\n\r\n### 원칙 6: 일관성 유지\r\n\r\n문서에 없는 내용을 임의로 추가하지 말 것. 이것이 가장 중요한 규칙입니다.\r\n\r\n---\r\n\r\n## AI 도구 사용 현황\r\n\r\n현재 저는 Claude Code를 주력 개발 도구로, Cursor를 보조 개발 도구로, Gemini를 기획과 문서 작성에 사용합니다. ChatGPT는 코딩을 너무 못해서 배제했습니다. 상황에 따라 도구를 선택합니다. 복잡한 로직은 Claude Code로, 빠른 프로토타입은 Cursor로, 기획과 아이디어는 Gemini로 작업합니다.\r\n\r\n---\r\n\r\n## 초보자를 위한 조언\r\n\r\n### \"잘 쓰려고 할수록 어렵다\"\r\n\r\n간단한 문서, 개발 제품은 너무 잘 만듭니다. 하지만 디테일을 생각하는 순간 해야 할 것들과 챙겨야 할 것들이 엄청 많아집니다. 이때쯤 포기를 선택하는 사람들이 생깁니다. \"지금은 안 되나\", \"AI는 아직 멀었나\" 등등의 얘기로 포장하면서 말입니다.\r\n\r\n### 본질을 직시하자\r\n\r\n그냥, 본질적으로 \"나의 AI 활용 능력이 떨어지는 것\"입니다. 더 잘 써보려는, 더 잘 활용하려는 고민을 해보세요. 혼자 고민만 할 필요 없습니다. 나의 고민을 주변 누군가와 혹은 AI와 상의하는 것도 본인만의 방법을 찾을 수 있는 과정이 될 수 있습니다.\r\n\r\n### 우리는 새로운 시대에 도착했다\r\n\r\n나의 상상력을 개발로 만들어낼 수 있는 시대입니다. 지금은 못하는 시대가 아닌, 안 하는 시대가 되었습니다.\r\n\r\n---\r\n\r\n## 마치며\r\n\r\n9년 전 포기했던 꿈을 2025년 AI와 함께 다시 꺼냈습니다. 수십 번의 리셋과 수백 시간의 고민 끝에, 지금 fallingo는 거의 완성 단계입니다. 백엔드 145개 API 완성, 프론트엔드 주요 기능 구현, Google for Startups 승인 ($2,000 크레딧), 베타 테스트 준비 중입니다. 모두 AI와 함께 만들었습니다. FastAPI도, Flutter도, GCP도 몰랐지만 AI와 함께라면 가능했습니다.\r\n\r\n---\r\n\r\n## AI 개발 방법론 요약\r\n\r\n**1단계: 시작**\r\n- 기술을 몰라도 시도하라 (AI가 있다)\r\n\r\n**2단계: 복잡성**\r\n- 간단한 요청부터 시작\r\n- 복잡해지면 단계를 나눠라\r\n\r\n**3단계: 일관성**\r\n- 문서 중심으로 개발\r\n- 순차적 문서 작성\r\n- 교차 검증\r\n\r\n**4단계: 구조화**\r\n- SpecKit 같은 도구 활용\r\n- 구조적 일관성 보장\r\n\r\n**5단계: 검증**\r\n- AI를 맹신하지 말라\r\n- 끊임없이 질문하라\r\n- 반드시 확인하라\r\n\r\n**6단계: 리셋**\r\n- 일관성이 깨지면 과감히 다시 시작\r\n- 수정하는 것보다 새로 만드는 게 빠르다\r\n\r\n---\r\n\r\n**참고 자료:**\r\n- [Vibe Framework](https://github.com/su-record/vibe) - SPEC 주도 AI 코딩 프레임워크\r\n- [SpecKit](https://github.com/AnthusAI/SpecKit)\r\n- [OpenSpec](https://github.com/Fission-AI/OpenSpec)\r\n- [hi-ai MCP](https://github.com/su-record/hi-ai)\r\n- [Cursor Rules](https://gist.github.com/su-record/a9715fc36d7bc92b2ba359aad362b699)\r\n- [프롬프팅 가이드](https://gist.github.com/su-record/70f75be7041420e59bcd92bf91719d47)\r\n\r\n---\r\n\r\n> 이전 편: [AI 개발 방법론 1 - AI와의 첫 만남, 그리고 시작](01-ai-journey-start.md)\r\n\r\n**fallingo는 지금 이 순간에도 발전하고 있습니다.**",
      "description": "SpecKit 발견, 그리고 나만의 바이브 코딩 프레임워크를 만들기까지. AI 개발 방법론의 완성",
      "tags": [
        "ai-first",
        "speckit",
        "vibe-coding",
        "framework",
        "methodology"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/05-ai-completion-speckit.md"
    },
    {
      "slug": "fallingo-01-google-dream",
      "title": "나의 꿈은 구글이니까 - 기술스택을 100% 구글로 결정한 이유",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "story",
      "content": "# 나의 꿈은 구글이니까\n\n2025년 5월 말, fallingo 앱을 만들기로 결심하고 가장 먼저 한 결정이 있었습니다. 모든 기술 스택을 구글로 정하는 것이었습니다. 감상적인 결정이었다고 말할 수 있겠지만, 저에게는 나름의 이유가 있었습니다.\n\n## 어릴 적부터의 꿈\n\n어릴 적부터 구글은 '도달할 수 없는 꿈'이었습니다. 실리콘밸리, 세계 최고의 기술 기업, 혁신의 아이콘... 이런 거창한 말이 아니라 그냥 단순하게 \"여기서 일하고 싶다\"는 마음이었습니다. 하지만 현실은 냉정했습니다. 나이도 있고, 한국에 있고, 영어도 완벽하지 않습니다. 갈 수 없이 너무 멀리 있는 곳입니다.\n\n그래서 생각했습니다. \"갈 수는 없지만, 구글의 기술로 내 앱을 만들면 되지 않을까?\" 이렇게 하면 적어도 구글의 기술과 함께 일하는 경험은 할 수 있을 것 같았습니다.\n\n## 100% 구글 기술 스택으로 결정\n\n그래서 정했습니다. 모든 기술을 구글로 쓰기로요. 백엔드는 FastAPI와 Python 3.11+를 선택했고, 데이터베이스는 PostgreSQL 15에 PostGIS를 더했습니다. 배포는 Cloud Run으로 하기로 했습니다. 프론트엔드는 Flutter 3.24+를 택했고, 인증은 Firebase Auth를 사용하기로 했습니다.\n\nAI 서비스도 전부 구글입니다. Vision API로 이미지를 분석하고, Gemini로 AI 대화를 처리하며, Document AI로 문서를 다루고, Translate API로 번역을 지원합니다. 인프라 역시 Cloud Run, Cloud Storage, Cloud SQL, Memorystore Redis로 구성했습니다. 지도는 당연히 Google Maps Platform입니다.\n\n백엔드도 모르고, Flutter도 처음이고, 구글 클라우드는 더더욱 몰랐습니다. 하지만 AI와 함께라면 된다고 믿었습니다. 실제로 지난 몇 달간 Claude와 함께 코딩하면서 모르는 기술들을 하나씩 익혀나갔습니다.\n\n## 갈 수 없는 꿈, 다른 방식으로\n\n구글이라는 회사에 들어갈 순 없습니다. 나이도 있고, 한국에 있고, 영어도 완벽하지 않습니다. 하지만 구글의 기술로 내 앱을 만들 수는 있습니다. 이것이 제가 찾은 다른 방식의 꿈이었습니다.\n\n모르는 게 산더미였습니다. FastAPI도, Flutter도, Cloud Run도 전부 처음이었습니다. 하지만 걸음은 이미 시작됐고, AI와 함께라면 내가 모르는 기술도 배우면서 만들 수 있다고 생각했습니다. 그리고 실제로 그렇게 되고 있습니다.\n\n나의 꿈은 구글이니까요.",
      "description": "갈 수 없을 것 같은 꿈. 그래서 모든 기술을 구글로 만들기로 했다",
      "tags": [
        "fallingo",
        "google-cloud",
        "dev-journey",
        "dream"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-01-google-dream.md"
    },
    {
      "slug": "fallingo-02-google-for-startups",
      "title": "Google for Startups Cloud Program 승인받기 - $2,000 크레딧 획득 여정",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "story",
      "content": "# Google for Startups Cloud Program 승인받기\n\nfallingo를 개발하면서 Google Cloud Platform을 전폭적으로 사용하고 있었습니다. Cloud Run, Cloud SQL, Vision API, Gemini AI, Maps Platform까지 여러 서비스를 쓰다 보니 인프라 비용이 생각보다 많이 나가더군요. 아직 테스트만 하는 중인데도 말입니다. 그때 문득 생각난 것이 Google for Startups Cloud Program이었습니다.\n\n## 신청 시작 (10월 27일)\n\nGoogle for Startups Cloud Program 신청 페이지를 찾아 신청서를 작성했습니다. GCP Billing Account ID, Company Name, Company Website, Business Email, Funding Level 등 필요한 항목을 모두 입력하고 제출했습니다. 도메인이 일치하는 비즈니스 이메일이 필수였습니다. 몇 시간 뒤, 첫 메일이 도착했습니다.\n\n## 첫 번째 메일: 신청 접수 확인 (10월 27일)\n\n내용은 간단했습니다. \"신청이 접수되었습니다. 검토 후 연락드리겠습니다\"라는 자동 응답 메일이었습니다. 이제 기다리는 수밖에 없었습니다.\n\n## 두 번째 메일: 1차 조치 필요 (10월 30일)\n\n3일 후, 문제가 발생했습니다. \"웹사이트에 회사 정보가 충분하지 않습니다\"라는 메일이 왔습니다. `fallingo.app`에는 랜딩 페이지만 있었으니까요. 하지만 백엔드는 이미 100% 완성되어 프로덕션에서 돌아가고 있었습니다. API 문서도 공개되어 있었고요.\n\n## 첫 번째 회신: 기술 문서 제출 (10월 31일)\n\n웹사이트는 없었지만 API 문서는 있었습니다. 메일에 이렇게 적었습니다. 백엔드 100% 완료, 145개 API 엔드포인트, 17개 모듈로 구성되어 있으며 GCP Cloud Run과 Cloud SQL PostgreSQL + PostGIS로 프로덕션에 배포 중이라고요. API 문서는 Swagger와 ReDoc으로 공개되어 있고, 상세 문서도 PDF로 첨부했습니다. \"실제로 돌아가는 시스템이 있습니다. 확인해보세요\"라고 썼습니다. 이것으로 될 수는 없을까 하는 기대를 품었습니다.\n\n## 2차 조치 필요: Sašo의 답변 (11월 3일)\n\n4일 후, Sašo로부터 답변이 왔습니다.\n\n**\"신청서를 신중하게 검토했습니다(After carefully reviewing your application).\"**\n\n전담 담당자가 직접 API 문서와 PDF를 검토했습니다. 하지만:\n\n**\"공개 정보가 충분하지 않습니다. 공개 웹사이트가 필요합니다.\"**\n\n필요한 것:\n- Business Description (무엇을 만드는가)\n- Team Information (누가 만드는가)\n- Product Details (현재 개발 단계, 스크린샷, 동영상, 데모)\n\n**사람이 읽을 수 있는 웹페이지**가 필요했습니다.\n\n## 위기: 공개 웹사이트 만들기 (11월 3일 ~ 11월 5일)\n\n선택지는 두 가지였습니다.\n\n1. 포기한다\n2. 웹사이트를 만든다\n\n당연히 2번을 선택했습니다.\n\n어떻게 사이트를 만들어야 할 지 고민한 끝에 `about` 페이지를 만들었습니다.\n\n**주요 구성:**\n- **Mission & Vision**: 가짜 리뷰 제거, 진정성 있는 미식 경험 공유\n- **Why fallingo?**: 3단계 검증 (GPS + Vision API + OCR), 11단계 게이미피케이션\n- **Core Features**: 위치 기반 피드, 티어 시스템, 실시간 메뉴 인식, 스마트 지도\n- **Technology Stack**: 100% Google Cloud Platform\n- **Gamification System**: Tier 1 → Tier 11\n- **API Documentation**: Swagger UI, ReDoc\n- **AI-First Development**: Claude, Cursor를 사용한 문서 주도 개발\n- **Current Status**: 백엔드 100% (99.3% 테스트 성공률) / 프론트엔드 60%\n\n## 두 번째 회신: about 완성 (11월 5일)\n\n새로 만든 `about`을 메일 내용에 포함하여 보냈습니다.\n\n**\"웹사이트를 업데이트했습니다: about\"**\n\n2인 스타트업이 만든 다수의 API 엔드포인트.\nGoogle Cloud 크레딧이 있다면 인프라 비용 걱정 없이 제품에만 집중할 수 있습니다.\n\n회신을 보내고 기다렸습니다.\n\n## 승인 메일: Nancy (11월 7일 저녁 8시)\n\n이틀 후, 메일이 왔습니다.\n\n이번엔 또 어떤 조치사항이 왔을까? 또 조치하라 하면 앱을 스토어에 등록한 후에 회신해야겠다고 생각하며 메일을 확인했습니다.\n\n보낸이가 Sašo가 아닌 Nancy였습니다.\n\n**\"My name is Nancy and I'm supporting Sašo with this request.\"**\n\nNancy와 Sašo가 함께 검토했습니다.\n\n**\"Fantastic news! Start Tier 승인되었습니다!\"**\n\n24-48시간 내에 크레딧이 반영됩니다.\n\n**승인됐습니다!**\n\n45분 후, Welcome 메일이 도착했습니다.\n\n## Welcome Email (11월 7일 저녁 8시 46분)\n\n**$2,000 USD Google Cloud 크레딧**\n**2년간 사용 가능**\n**Start Tier (Self-funded startup)**\n\n**사용 가능한 서비스:**\n- Firebase and Google Cloud Platform Services (BigQuery, Cloud Run, etc.)\n- Select Google Cloud Offerings (Looker 등)\n\n**추가 혜택:**\n- Google Cloud Skills Boost $200 크레딧 (온라인 코스, hands-on labs)\n- MongoDB Atlas $500 크레딧\n- Google Workspace 12개월 무료 (Business Plus)\n- Google Maps Platform $200 월간 무료 사용량\n- Google Cloud Startup Community 가입\n\n## 실제로 얼마나 도움이 될까?\n\nfallingo 월 지불 항목:\n- Cloud Run (FastAPI)\n- Cloud SQL (PostgreSQL)\n- Cloud Memorystore (Redis)\n- Cloud Storage\n- Cloud Load Balancing\n- Vision API\n- Gemini AI\n- Scret Manager\n- FCM (Firebase Cloud Messaging)\n- Maps Platform (월 $200 무료 포함)\n\n**초기 단계 (100명 활성 유저, 하루 3-5개 피드)**\n- 월 총 예상: **$65-85** (거의 고정 인프라 비용만)\n- $2,000으로 **약 24-30개월** 사용 가능\n\n**성장 단계 (1,000명 활성 유저, 하루 30-50개 피드)**\n- 월 총 예상: **$150-220**\n- $2,000으로 **약 9-13개월** 사용 가능\n\n초기 단계에서는 대부분의 API가 무료 tier 안에 들어가고, **인프라 고정 비용만 발생**합니다.\n\n$2,000 크레딧으로 **최소 수개월 혹은 2년까지** 인프라 비용 걱정 없이 제품에만 집중할 수 있게 됐습니다.\n\n## 신청 팁\n\nGoogle for Startups Cloud Program 신청을 고려 중인 스타트업을 위한 조언입니다. 실제로 이 과정을 겪으면서 배운 것들을 공유하고자 합니다.\n\n### 1. 공개 웹사이트는 필수\n\n간단해도 괜찮습니다. About 페이지에 제품 설명과 연락처만 있어도 충분합니다. 앱만 있다면 fallingo.app/about.html처럼 간단한 한 페이지라도 만드세요. Google이 확인하려는 것은 화려한 웹사이트가 아니라 \"실제로 운영 중인 스타트업인지\"입니다.\n\n### 2. 구체적인 정보 제공\n\nGoogle이 확인하는 것은 크게 세 가지입니다. 실제로 운영 중인 스타트업인가, 어떤 제품을 만드는가, 그리고 Google Cloud를 어떻게 사용할 것인가입니다. 막연한 계획보다는 구체적인 사용 계획이 중요합니다. \"AI를 활용한 서비스를 만들 예정입니다\"보다는 \"Gemini API로 리뷰 분석, Vision API로 이미지 검증, Maps Platform으로 위치 서비스를 구현합니다\"처럼 구체적으로 작성하는 것이 좋습니다.\n\n### 3. 빠른 응답\n\n보통 2-3일 내에 회신하는 것이 좋습니다. 추가 요청이 와도 당황하지 마세요. 이것은 정상적인 절차입니다. 오히려 Google이 신청서를 신중하게 검토하고 있다는 의미입니다. 다만 너무 늦으면 신청이 자동 취소될 수 있으니 빠르게 대응하는 것이 중요합니다.\n\n### 4. Bootstrapped 스타트업도 가능\n\nfallingo는 2인 스타트업이고, 투자 없이 자비로 운영하고 있으며, 아직 출시 전입니다. 이런 상태에서도 Start Tier $2,000 크레딧 승인을 받았습니다. 투자 유치 전이라도, 제대로 된 제품과 구체적인 계획이 있다면 충분합니다. Google은 완성된 서비스보다는 진지하게 만들고 있는 스타트업을 지원하고 싶어 합니다.\n\n## 마치며\n\nGoogle for Startups Cloud Program은 **초기 스타트업에게 정말 큰 도움**이 됩니다.\n\n특히 AI, 지도, 인프라가 필요한 서비스라면 더욱 그렇습니다.\n\n신청 과정에서 추가 요청이 와도, 웹사이트를 다시 만들어야 해도, 포기하지 말고 끝까지 대응하면 됩니다.\n\n**나의 꿈은 구글이니까.**\n\n구글이라는 회사에 들어갈 순 없지만, 구글의 기술로 내 앱을 만들 수 있다면 그것으로 충분합니다.\n\n---\n\n**참고 링크:**\n- [Google for Startups Cloud Program](https://cloud.google.com/startup)\n- [fallingo About Page](https://fallingo.app/about.html)",
      "description": "fallingo의 Google for Startups Cloud Program 신청부터 승인까지. 웹사이트 검증 요청, fallingo.app/about.html 페이지 작성, 그리고 Start Tier $2,000 크레딧 승인까지의 실제 과정",
      "tags": [
        "google-cloud",
        "startup",
        "cloud-credits",
        "fallingo"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-02-google-for-startups.md"
    },
    {
      "slug": "fallingo-03-why-fallingo",
      "title": "왜 fallingo를 만들게 됐나 - 가짜 리뷰를 없애고 싶었다",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "story",
      "content": "# 왜 fallingo를 만들게 됐나\n\n2016년, 나는 구글에서 일하는 꿈을 꿨다.\n\n갈 수 없는 꿈이었지만, 구글의 기술로 내 앱을 만들기로 했다.\n\n그리고 2025년 5월, fallingo를 만들기 시작했다.\n\n## 우리가 원하는 건 '맛집'이 아니다\n\n\"맛집을 찾았는데 정작 뭐를 먹어야 할지 모르겠어...\" 이게 진짜 문제였습니다. 우리가 원하는 건 \"강남 맛집 100선\"이 아닙니다. 너무 멀어요. \"이 식당이 유명해요\"도 아닙니다. 뭘 먹어야 하는데요? 우리가 정말 원하는 것은 \"지금 갈 수 있는 거리의 맛있는 메뉴\"입니다.\n\n기존 앱들은 점포 중심이었습니다. 식당이 메인이고, 메뉴는 부가 정보이며, 리뷰는 식당 전체에 대해 작성됩니다. 하지만 fallingo는 메뉴 중심입니다. 메뉴가 메인이고, 식당은 메뉴가 있는 곳이며, 리뷰는 특정 메뉴에 대해 작성됩니다. 이 작은 차이가 사용자 경험을 완전히 바꿉니다.\n\n## 가짜 리뷰를 없애고 싶었다\n\n그리고 또 하나의 문제가 있었습니다. \"이 사람 진짜 여기 갔을까?\" 별점 5개에 칭찬만 가득한 리뷰를 보면 사장님이 쓴 건 아닐까 의심스럽습니다. 별점 1개에 악의적 비난이 담긴 리뷰는 경쟁 업체가 쓴 건 아닐까 싶고요. 사진은 인터넷에서 퍼온 것 같고, 리뷰 내용은 복붙한 것 같습니다. 진짜 경험인지 알 수 없었습니다.\n\n그래서 생각했습니다. \"실제로 그 장소에 가서, 음식을 먹은 사람만 리뷰를 쓸 수 있다면?\"\n\n## 3단계 검증 시스템\n\nfallingo는 세 가지 방식으로 검증합니다. 첫째, GPS 검증입니다. PostGIS로 정확한 위치를 확인하고, 음식점 50m 이내에 있어야만 피드를 작성할 수 있습니다. 둘째, Vision API 음식 감지입니다. 카메라로 찍은 사진이 진짜 음식인지 AI가 확인하고, 인터넷에서 퍼온 사진은 걸러냅니다. 셋째, OCR 영수증 검증입니다. Document AI로 영수증을 인식하고, 24시간 이내 영수증만 인정하며, 메뉴 아이템을 자동으로 매칭합니다.\n\n모든 피드가 검증된 진짜 경험입니다.\n\n## 팔로워가 아닌 노력으로\n\n인스타그램이나 유튜브는 팔로워 수가 곧 영향력입니다. 10만 팔로워가 추천하면 믿고, 100명 팔로워가 추천하면 무시합니다. 하지만 팔로워 수가 맛집을 판단하는 기준이 될 수 있을까요? fallingo는 다릅니다.\n\n**11단계 티어 시스템:**\n\n| 티어 | 이름 | 필요 포인트 | 영향력 범위 | 해금 기능 |\n|------|------|------------|-----------|----------|\n| 1 | 누룽지 | 0 | 5km | 기본 피드 작성 |\n| 2 | 비빔밥 | 100 | 10km | 프로필 이미지 |\n| 3 | 삼겹살 | 200 | 20km | 닉네임 설정 |\n| 4 | 갈비탕 | 500 | 30km | 팔로우 기능 |\n| 5 | 떡볶이 | 1,000 | 50km | 댓글 작성 |\n| 6 | 짜장면 | 2,000 | 100km | 좋아요 기능 |\n| 7 | 된장찌개 | 5,000 | 200km | 북마크 기능 |\n| 8 | 불고기 | 10,000 | 500km | 메시지 기능 |\n| 9 | 한정식 | 20,000 | 1,000km | 추천 알고리즘 우선순위 |\n| 10 | 대장금 | 50,000 | 무제한 | 전체 지역 영향력 |\n| 11 | 대장금⭐⭐⭐ | 100,000 | 무제한 | 전설의 미식가 (전 세계 100-200명) |\n\n포인트는 검증된 피드를 작성하면 10포인트를 받고, 인기 피드는 좋아요와 댓글이 많으면 추가 보너스를 받습니다. 다만 허위 피드로 신고를 당하면 50포인트가 감점됩니다.\n\n누룽지에서 대장금⭐⭐⭐까지 가는 여정은 팔로워 수가 아닌 검증된 포스팅 횟수로 티어가 상승합니다. 100,000 포인트는 10,000개의 검증된 피드를 의미하는데, 하루 1개씩 올린다면 약 27년이 걸립니다. 전 세계에서 100-200명만 도달하는 전설의 티어입니다. 높은 티어일수록 영향력 범위가 5km에서 무제한으로 확대됩니다.\n\n노력하면 누구나 영향력 있는 미식가가 될 수 있습니다. 팔로워 수를 사거나, 바이럴 마케팅을 할 필요가 없습니다. 진짜 음식을 먹고, 진짜 리뷰를 쓰면 됩니다.\n\n## 왜 처음부터 글로벌인가?\n\nfallingo는 위치 기반 서비스입니다. 그리고 피드는 실제로 음식을 먹을 때만 생성됩니다. GPS 검증으로 50m 이내에 있어야 하고, Vision API로 음식을 감지하며, 영수증 OCR로 검증합니다. 이런 물리적 제약 때문에 한 지역에서는 콘텐츠 생산이 제한적입니다.\n\n로컬만으로는 부족합니다. 서울에 100명이 있다면 하루 3-5개 피드가 생성됩니다. 사람들은 하루 1-2끼 외식을 하고, 매번 포스팅하는 사람은 극소수이기 때문에 콘텐츠가 쌓이는 속도가 너무 느립니다.\n\n글로벌로 가면 해결됩니다. 서울 100명, 도쿄 100명, 뉴욕 100명이 각각 하루 3-5개씩 피드를 올리면 전체로는 충분한 콘텐츠가 됩니다. 14개 언어 지원으로 언어 장벽을 제거하고, 여행을 가면 다른 나라 맛집도 바로 확인할 수 있습니다.\n\n**9개 지역 네트워크 구조:**\n1. 🇰🇷 Korea (개별 국가)\n2. 🇯🇵 Japan & Southeast Asia (일본, 베트남, 태국, 필리핀, 인도네시아, 말레이시아, 싱가포르)\n3. 🇨🇳 China & Taiwan (중국, 대만, 홍콩, 마카오)\n4. 🇮🇳 India & South Asia (인도, 파키스탄, 방글라데시, 스리랑카)\n5. 🇺🇸 USA & Canada (미국, 캐나다)\n6. 🇬🇧 Europe (영국, 프랑스, 독일, 이탈리아, 스페인 등)\n7. 🇦🇺 Oceania (호주, 뉴질랜드)\n8. 🇧🇷 Latin America (브라질, 멕시코, 아르헨티나 등)\n9. 🌍 Africa & Middle East (남아공, UAE, 사우디 등)\n\n**14개 언어 지원:**\n- 한국어, 영어, 일본어, 중국어(간체/번체)\n- 베트남어, 태국어, 인도네시아어, 말레이어\n- 힌디어, 스페인어, 프랑스어, 독일어, 아랍어\n\n**그래서 처음부터:**\n- Google Translate API 14개 언어 자동 번역\n- Google Cloud 글로벌 인프라\n- 다국어 지원 UI/UX\n- 지역별 음식 문화 데이터셋\n\n위치 기반이지만, **글로벌 스케일로만 성공할 수 있는 서비스다.**\n\n## 나의 꿈은 구글이니까\n\n구글에 들어갈 순 없지만, 구글의 기술로 내 앱을 만들 수 있다.\n\n**100% Google Cloud Platform:**\n- Cloud Run (FastAPI 백엔드)\n- Cloud SQL (PostgreSQL + PostGIS)\n- Cloud Memorystore (Redis)\n- Vision API (음식 감지)\n- Gemini AI (리뷰 생성)\n- Document AI (영수증 OCR)\n- Translate API (14개 언어)\n- Maps Platform (지도)\n- Firebase (인증)\n\n모든 것이 구글 기술이다.\n\n백엔드도 모르고, Flutter도 처음이고, GCP도 처음이었다.\n\n하지만 **AI와 함께라면 된다고 믿었다.**\n\n그리고 실제로 그렇게 됐다.\n\n---\n\n## 맛에 빠져들어, 함께 떠나는 여정\n\n**Falling in, Go together.**\n\nfallingo는 단순히 맛집을 찾는 앱이 아니다.\n\n**진짜 음식 경험을 공유하는 플랫폼이다:**\n\n| 기존 앱 | fallingo |\n|---------|----------|\n| 점포 중심 | 메뉴 중심 |\n| 누구나 작성 | 실제 방문자만 |\n| 팔로워 수 = 영향력 | 노력 = 영향력 |\n| 허위 정보 | 3중 검증 |\n| 로컬 한정 | 글로벌 9개 지역 |\n| 번역 없음 | 14개 언어 자동 번역 |\n\n**세 가지 사용자 가치:**\n\n1. **일반 사용자**: 3단계 검증으로 믿을 수 있는 맛집 정보\n2. **미식가**: 누룽지에서 대장금⭐⭐⭐까지 성장하는 RPG 같은 경험\n3. **소상공인**: 비싼 광고비 없이도 공정하게 노출되는 기회\n\n**나의 꿈은 구글이니까.**\n\n구글에 들어갈 순 없지만, 구글의 기술로 내 꿈을 만들 수 있다.\n\nfallingo는 그렇게 시작됐다.",
      "description": "위치 기반 검증으로 진짜 음식 경험만 공유되는 플랫폼. 그리고 처음부터 글로벌을 목표로 한 이유",
      "tags": [
        "fallingo",
        "vision",
        "startup",
        "food-tech"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-03-why-fallingo.md"
    },
    {
      "slug": "fallingo-devlog-0001",
      "title": "fallingo 개발일지 - 2025-05-28 ~ 2025-05-29 (20개 커밋)",
      "date": "2025-05-29T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-05-28 ~ 2025-05-29 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 프로젝트 초기 설정 (2개 커밋)\n- Initial commit: 프로젝트 저장소 생성\n- README.md 작성\n\n### 기획 문서 작성 (18개 커밋)\n- **proposal.md**: 프로젝트 제안서 작성 및 7회 수정\n- **서비스 철학 및 개요**: fallingo 철학, 서비스 개요 문서화\n- **비전/미션 정의**: 서비스 비전 및 미션 명확화\n- **기능 명세**: 주요 기능 3개 문서, 소셜 네트워크 기능 문서\n- **차별화 전략**: 차별화 포인트 문서화\n- **기술 스택**: 사용할 기술 스택 정리\n- **개발 계획**: 개발 진행 상황 및 향후 로드맵 문서\n- **법률 문서**: 개인정보 및 위치정보 처리 방침\n- **커뮤니케이션**: 문의 및 제안 채널 정리\n\n총 10개의 기획 문서를 체계적으로 작성했습니다.\n\n## 💡 작업 하이라이트\n\n**체계적인 기획 문서화**\n\nfallingo 프로젝트를 시작하면서 코드를 작성하기 전에 **기획 단계를 철저히 문서화**했습니다. proposal.md를 7번 수정하면서 프로젝트 방향성을 명확히 했고, 이를 바탕으로 00번부터 10번까지 번호를 매긴 체계적인 문서 구조를 만들었습니다.\n\n특히 서비스 철학, 비전/미션, 차별화 포인트를 명확히 정의한 것이 인상적입니다. 개발 전 기획 단계에 시간을 투자하는 것이 프로젝트의 방향성을 잡는 데 중요하다는 것을 보여줍니다.\n\n## 📊 개발 현황\n\n- **기획 단계**: 100% 완료\n- **문서화**: 10개 핵심 문서 작성 완료\n- **개발 단계**: 아직 시작 전",
      "description": "fallingo 프로젝트 초기 설정 및 기획 문서 작성",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0001.md"
    },
    {
      "slug": "fallingo-devlog-0002",
      "title": "fallingo 개발일지 - 2025-05-29 ~ 2025-05-31 (20개 커밋)",
      "date": "2025-05-31T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-05-29 ~ 2025-05-31 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 기획 문서 전면 개선 (19개 커밋)\n- **00_fallingo_철학.md ~ 10_문의_및_제안.md**: 기존 10개 문서 전면 수정\n- **proposal.md**: 제안서 추가 개선\n- **03_주요기능.md**: 2회 추가 수정으로 주요 기능 명세 정교화\n- **04_소셜_네트워크_기능.md**: 소셜 기능 상세 명세 보완\n- **09_개인정보_및_위치정보.md**: 법률 문서 보완\n- **README.md**: 3회 업데이트로 프로젝트 소개 개선\n\n### 신규 문서 작성 (1개 커밋)\n- **00_서비스_소개.md**: 서비스 소개 문서 신규 작성\n\n## 💡 작업 하이라이트\n\n**기획 문서 품질 개선**\n\n초기 작성한 10개 기획 문서를 전면적으로 검토하고 개선했습니다. 특히 주요 기능 명세(03_주요기능.md)는 3회에 걸쳐 수정하며 기능 설명을 정교화했고, 소셜 네트워크 기능(04_소셜_네트워크_기능.md)도 추가 보완했습니다.\n\nREADME.md를 3회 업데이트하며 프로젝트의 첫인상을 개선하는 데 집중했으며, 마지막으로 00_서비스_소개.md를 신규 작성하여 서비스 전체를 조망할 수 있는 문서를 추가했습니다.\n\n## 📊 개발 현황\n\n- **기획 단계**: 100% 완료 (품질 개선 완료)\n- **문서화**: 11개 핵심 문서 (10개 기획 + 1개 서비스 소개)\n- **개발 단계**: 아직 시작 전",
      "description": "기획 문서 개선 및 서비스 소개 문서 작성",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0002.md"
    },
    {
      "slug": "fallingo-devlog-0003",
      "title": "fallingo 개발일지 - 2025-05-31 (20개 커밋)",
      "date": "2025-05-31T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-05-31 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 문서 구조 정리 (6개 삭제)\n- **docs/ 폴더 정리**: 중복 및 불필요 문서 6개 삭제\n  - 00_fallingo_철학.md\n  - 01_서비스_개요.md\n  - 02_서비스_비전_미션.md\n  - 06_기술_스택.md\n  - 07_개발_진행_상황.md\n  - 08_향후_로드맵.md\n\n### 파일명 개선 (5개 리네임)\n- **번호 제거**: 문서명에서 숫자 prefix 제거하여 가독성 향상\n  - 00_서비스_소개.md → 서비스_소개.md\n  - 03_주요기능.md → 주요기능.md\n  - 04_소셜_네트워크_기능.md → 소셜_네트워크_기능.md\n  - 05_차별화_포인트.md → 차별화_포인트.md\n  - 09_개인정보_및_위치정보.md → 개인정보_및_위치정보.md\n\n### 문서 내용 보완 (8개 수정 + 1개 신규)\n- **주요기능.md**: 4회 연속 수정으로 기능 명세 정교화\n- **소셜_네트워크_기능.md**: 소셜 기능 개선\n- **차별화_포인트.md**: 차별화 전략 보완\n- **08_향후_로드맵.md**: 로드맵 업데이트\n- **개인정보_및_위치정보.md**: 법률 문서 보완\n- **기술_및_개발_로드맵.md**: 신규 작성 (기술 스택 + 로드맵 통합)\n\n## 💡 작업 하이라이트\n\n**문서 구조 대대적 개편**\n\n프로젝트 문서가 체계화되면서 중복되거나 불필요한 문서들이 발견되었습니다. 이번 작업에서는 6개의 중복 문서를 삭제하고, 남은 핵심 문서들의 파일명에서 숫자 prefix를 제거하여 더 직관적인 구조로 개편했습니다.\n\n특히 기술_스택, 개발_진행_상황, 향후_로드맵을 통합하여 **기술_및_개발_로드맵.md** 하나로 정리한 것이 핵심입니다. 주요기능.md는 하루에 4회나 수정하며 기능 명세를 완성도 높게 다듬었습니다.\n\n## 📊 개발 현황\n\n- **기획 단계**: 100% 완료 (문서 구조 최적화 완료)\n- **문서화**: 핵심 문서로 압축 정리 완료\n- **개발 단계**: 아직 시작 전",
      "description": "문서 구조 개편 및 파일명 정리",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0003.md"
    },
    {
      "slug": "fallingo-devlog-0004",
      "title": "fallingo 개발일지 - 2025-05-31 ~ 2025-06-02 (20개 커밋)",
      "date": "2025-06-02T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-05-31 ~ 2025-06-02 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### README 집중 개선 (7개 커밋)\n- **README.md**: 6회 연속 업데이트로 프로젝트 소개 완성도 향상\n- **5/31 ~ 6/2**: 3일간 지속적인 README 개선 작업\n\n### 프로젝트 규칙 및 정리 (3개 커밋)\n- **[ADD] rules**: 프로젝트 규칙 문서 추가\n- **Merge**: 원격 저장소 동기화\n- **[DEL]**: 불필요한 파일 삭제\n\n### 기획 문서 최종 다듬기 (6개 커밋)\n- **proposal.md**: 2회 수정으로 제안서 최종 완성\n- **주요기능.md**: 2회 수정\n- **소셜_네트워크_기능.md**: 업데이트\n- **차별화_포인트.md**: 업데이트\n- **기술_및_개발_로드맵.md**: 업데이트\n- **개인정보_및_위치정보.md**: 최종 보완\n\n### 개발 시작 (2개 커밋)\n- **Start**: 개발 시작 커밋\n- **[ADD] planning**: 개발 계획 문서 추가\n\n## 💡 작업 하이라이트\n\n**기획에서 개발로 전환**\n\nREADME.md를 6회나 수정하며 프로젝트의 첫인상을 완벽하게 다듬었습니다. 또한 프로젝트 규칙(rules) 문서를 추가하여 개발 가이드라인을 명확히 했습니다.\n\n5월 31일부터 6월 1일까지 모든 기획 문서(proposal, 주요기능, 소셜 네트워크, 차별화, 기술 로드맵, 개인정보)를 최종 점검하고 보완했습니다.\n\n6월 2일, 드디어 **\"Start\"** 커밋과 함께 개발 단계로 진입했으며, planning 문서를 추가하여 본격적인 개발을 준비했습니다.\n\n## 📊 개발 현황\n\n- **기획 단계**: 100% 완료\n- **문서화**: 최종 완성\n- **개발 단계**: 시작 (planning 단계)",
      "description": "README 대폭 개선 및 개발 시작 준비",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0004.md"
    },
    {
      "slug": "fallingo-devlog-0005",
      "title": "fallingo 개발일지 - 2025-06-05 (2개 커밋)",
      "date": "2025-06-05T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-06-05 (2개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### README 최종 업데이트 (2개 커밋)\n- **README.md**: 2회 연속 업데이트로 프로젝트 소개 최종 마무리\n\n## 💡 작업 하이라이트\n\n**프로젝트 문서 최종 완성**\n\n개발 시작(Start) 이후 3일 만에 README.md를 다시 2회 수정하며 프로젝트 소개를 최종 완성했습니다. 이는 개발 초기 단계에서 프로젝트 방향성을 다시 한번 점검하고 명확히 하는 과정으로 보입니다.\n\n## 📊 개발 현황\n\n- **기획 단계**: 100% 완료\n- **문서화**: 최종 완성\n- **개발 단계**: 진행 중 (초기 단계)",
      "description": "README 최종 업데이트",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0005.md"
    },
    {
      "slug": "fallingo-devlog-0006",
      "title": "fallingo 개발일지 - 2025-06-04 ~ 2025-06-15 (20개 커밋)",
      "date": "2025-06-15T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-06-04 ~ 2025-06-15 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 프로젝트 시작 및 재시작 (5개 커밋)\n- **README.md**: 관련 문서에 직접 링크 추가\n- **[ADD] start**: 프로젝트 시작\n- **[MOD] refactor**: 초기 리팩토링\n- **[MOD] restart**: 프로젝트 재시작\n- **[MOD] 문서 업데이트**: 개발 가이드 정리\n\n### Part 0 개발 (4개 커밋)\n- **개발 가이드 문서 업데이트 - Part 0**: 초기 설계 문서화\n- **Part 0 개발 완료**: 기본 설정 완료\n- **Complete Part 0 development**: Part 0 최종 완료\n- **Part 0 검토 및 업데이트**: 코드 리뷰 및 개선\n\n### Part 1 시스템 설계 (6개 커밋)\n- **Part 1 - 시스템 설계 완료**: 2회 커밋으로 시스템 아키텍처 구축\n- **Part 1 종료 - 문서 업데이트**: Part 1 완료 문서화\n- **이슈수정**: 발견된 문제 해결\n- **문서 / 소스코드 검토 및 업데이트**: 전체 검토\n- **4.3 인증 UI 흐름**: 인증 시스템 UI 설계\n\n### Part 5 개발 및 인프라 변경 (5개 커밋)\n- **[MOD] update**: 일반 업데이트\n- **5.1 완료**: Part 5.1 기능 완료\n- **Complete Stage 5 development**: Part 5 전체 완료\n- **supabase 변경**: Supabase 인프라로 전환\n- **[DEL] Reset**: 리셋 작업\n\n## 💡 작업 하이라이트\n\n**빠른 개발 속도와 체계적 접근**\n\nfallingo 프로젝트가 6월 4일 시작하여 11일 만에 Part 0, Part 1, Part 5까지 완료했습니다. 특히 프로젝트를 한 번 **재시작(restart)**하는 과정을 거쳤으며, 이후 더 체계적인 파트 단위 개발 방식으로 전환했습니다.\n\nPart 0에서 기본 설정을 완료한 후, Part 1에서 시스템 설계와 인증 UI 흐름을 구축했습니다. 중간에 Part 5로 건너뛴 것은 핵심 기능 우선 개발 전략으로 보이며, 마지막에 **Supabase로 인프라를 변경**하는 중요한 아키텍처 결정을 내렸습니다.\n\n## 📊 개발 현황\n\n- **Part 0**: 완료 (기본 설정)\n- **Part 1**: 완료 (시스템 설계 + 인증 UI)\n- **Part 5**: 완료\n- **인프라**: Supabase 전환",
      "description": "fallingo 프로젝트 초기 개발 및 Part 0~1 완료",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0006.md"
    },
    {
      "slug": "fallingo-devlog-0007",
      "title": "fallingo 개발일지 - 2025-06-15 ~ 2025-06-16 (20개 커밋)",
      "date": "2025-06-16T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-06-15 ~ 2025-06-16 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 문서 및 프롬프트 정리 (10개 커밋)\n- **문서 업데이트**: 4회 반복 업데이트\n- **프롬프트 업데이트**: 4회 연속 프롬프트 개선\n- **프로젝트 지식 업데이트**: 프로젝트 컨텍스트 정리\n- **개발_진행_로드맵.md**: 로드맵 문서 업데이트\n\n### Phase 0~4 개발 완료 (7개 커밋)\n- **Complete Phase 0 development**: Phase 0 완료\n- **Merge**: 원격 저장소 동기화\n- **Complete Phase 1 development**: Phase 1 완료\n- **Complete Phase 2 development**: Phase 2 완료\n- **Complete Phase 3 development**: Phase 3 완료\n- **Complete Phase 4 development**: 3회 연속 커밋으로 Phase 4 완료\n\n### 프로젝트 전면 재시작 (2개 커밋)\n- **RESET!!**: 프로젝트 전면 리셋\n- **Phase 0**: 새로운 Phase 0 시작\n\n## 💡 작업 하이라이트\n\n**빠른 진행과 과감한 리셋**\n\n6월 15일 하루 동안 문서와 프롬프트를 10회나 업데이트하며 개발 방향성을 정립했습니다. 이후 Phase 0부터 Phase 4까지 빠르게 완료했으나, 6월 16일 **\"RESET!!\"** 커밋과 함께 프로젝트를 전면 리셋하는 과감한 결정을 내렸습니다.\n\nPhase 4를 3회나 커밋하며 완성했음에도 불구하고 리셋을 결정한 것은, 프로젝트 초기 단계에서 더 나은 아키텍처나 접근 방식을 발견했기 때문으로 보입니다. 리셋 후 즉시 새로운 Phase 0를 시작하며 더 견고한 기반을 다지는 모습입니다.\n\n## 📊 개발 현황\n\n- **첫 번째 시도**: Phase 0~4 완료 → 리셋\n- **두 번째 시도**: Phase 0 시작\n- **의사결정**: 초기 단계에서 과감한 리셋 결정",
      "description": "Phase 0~4 완료 및 프로젝트 리셋",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0007.md"
    },
    {
      "slug": "fallingo-devlog-0008",
      "title": "fallingo 개발일지 - 2025-06-18 ~ 2025-07-14 (20개 커밋)",
      "date": "2025-07-14T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-06-18 ~ 2025-07-14 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### Phase 기반 개발 (6개 커밋)\n- **Phase 0**: 기본 설정 완료\n- **Phase 1, 2**: 통합 개발\n- **Complete Phase 3 development**: Phase 3 완료\n- **문서 업데이트**: 개발 문서 정리\n- **Complete Phase 4 development**: Phase 4 완료\n- **개발 문서 업데이트**: Phase 4 완료 문서화\n\n### 연속된 리셋 (4개 커밋)\n- **[RESET]** (6/20): 첫 번째 리셋\n- **Complete Phase 1 development**: Phase 1 재개발\n- **[RESET]** (6/20): 두 번째 리셋\n- **[RESET]** (6/21): 세 번째 리셋\n\n### Step 기반 재구축 (9개 커밋)\n- **개발 문서 업로드**: 2회 연속 문서 정리\n- **Complete Step 2~4 development**: Step 2, 3, 4 완료\n- **project_id = \"fallingo\"**: 프로젝트 ID 설정\n- **legal**: 법률 문서 작성\n- **docs update**: 문서 업데이트\n- **first setup**: 첫 번째 셋업 완료\n\n### 최종 리셋 (1개 커밋)\n- **[RESET]** (7/14): 마지막 리셋\n\n## 💡 작업 하이라이트\n\n**완벽을 위한 반복적 리셋**\n\n6월 18일부터 7월 14일까지 약 한 달간 **총 4번의 리셋**을 단행했습니다. Phase 0~4를 완료한 후 6월 20일 연속으로 2번 리셋했고, 6월 21일 다시 한번 리셋했습니다.\n\n리셋 후 **\"Phase\"에서 \"Step\"으로 명명 방식을 변경**하며 개발 방법론을 개선했습니다. Step 2~4를 완료하고 프로젝트 ID를 \"fallingo\"로 명확히 설정했으며, 법률 문서까지 작성하며 체계를 갖췄습니다.\n\n그러나 7월 14일, 약 3주 만에 다시 **최종 리셋**을 결정했습니다. 이는 프로젝트 초기 단계에서 최적의 아키텍처를 찾기 위한 반복적 시도로, 빠른 실패와 학습을 통해 더 나은 기반을 구축하려는 전략으로 보입니다.\n\n## 📊 개발 현황\n\n- **두 번째 시도**: Phase 0~4 완료 → 리셋\n- **세 번째 시도**: Phase 1 완료 → 리셋\n- **네 번째 시도**: Step 2~4 완료, 법률 문서 작성 → 리셋\n- **다섯 번째 시도**: 7/14 새로운 시작 예정",
      "description": "반복된 리셋과 Step 기반 개발 완료",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0008.md"
    },
    {
      "slug": "fallingo-devlog-0009",
      "title": "fallingo 개발일지 - 2025-07-14 ~ 2025-08-09 (20개 커밋)",
      "date": "2025-08-09T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-07-14 ~ 2025-08-09 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 리셋 후 재시작 (3개 커밋)\n- **reset - docs**: 문서 리셋\n- **reset - del**: 파일 삭제\n- **docs**: 문서 재작성\n\n### 프로젝트 초기 설정 (5개 커밋)\n- **프로젝트 초기 설정 완료** (8/5): 본격적인 개발 시작\n- **lint error**: 린트 에러 수정\n- **DELETE**: 3회 연속 불필요한 파일 삭제\n\n### 배포 및 인프라 구축 (2개 커밋)\n- **배포 test**: 배포 테스트\n- **workflow**: GitHub Actions 워크플로우 설정\n\n### 프론트엔드 개발 (9개 커밋)\n- **프로덕션 API URL 설정**: API 엔드포인트 구성\n- **프론트엔드 환경변수 관리 개선**: 환경별 설정 분리\n- **프론트엔드 주요 기능 구현 및 린트 에러 해결**: 핵심 기능 구현\n- **GitHub Actions 테스트 워크플로우 수정**: CI/CD 개선\n- **DELETE**: 불필요한 파일 삭제\n- **테스트 환경에서 GCP 서비스 초기화 문제 해결**: GCP 통합\n- **Flutter 웹 빌드 시 API URL 환경변수 적용 안되는 문제 수정**: 빌드 이슈 해결\n- **경로 기반 라우팅 설정 완료**: 라우팅 시스템 구축\n- **프론트엔드 코드 정리**: 코드 리팩토링\n\n### 버전 관리 (1개 커밋)\n- **claude git**: Git 설정\n\n## 💡 작업 하이라이트\n\n**리셋 후 본격 개발 시작**\n\n7월 14일 리셋 후 약 3주간의 준비 기간을 거쳐, 8월 5일 **\"프로젝트 초기 설정 완료\"** 커밋과 함께 본격적인 개발에 돌입했습니다.\n\nFlutter 웹 기반 프론트엔드 개발에 집중하며, 환경변수 관리, API URL 설정, GCP 서비스 통합, 경로 기반 라우팅 등 **프로덕션 레벨의 인프라를 구축**했습니다. GitHub Actions를 통한 CI/CD 파이프라인도 설정하여 자동화 배포 체계를 갖췄습니다.\n\n특히 Flutter 웹 빌드 시 환경변수 적용 문제, GCP 서비스 초기화 문제 등 실무적인 이슈들을 하나씩 해결하며 안정적인 개발 환경을 구축했습니다.\n\n## 📊 개발 현황\n\n- **인프라**: GCP 연동, GitHub Actions CI/CD 구축\n- **프론트엔드**: Flutter 웹, 환경변수 관리, 라우팅 시스템 완료\n- **배포**: 자동화 배포 파이프라인 구축",
      "description": "프로젝트 초기 설정 및 프론트엔드 개발 시작",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0009.md"
    },
    {
      "slug": "fallingo-devlog-0010",
      "title": "fallingo 개발일지 - 2025-08-09 (20개 커밋)",
      "date": "2025-08-09T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-08-09 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 백엔드 환경 설정 (5개 커밋)\n- **BASE_URL 환경변수 변경**: 하드코딩 제거\n- **import 문 정리**: 린트 에러 수정\n- **lint**: 코드 스타일 정리\n- **테스트 conftest.py import 에러 수정**: 테스트 환경 안정화\n- **GCP 라이브러리 import 문제 해결**: 테스트 환경 GCP 통합\n\n### 배포 및 인프라 (5개 커밋)\n- **Cloud Run 호스트 헤더 검증 문제 해결**: Cloud Run 배포 이슈\n- **프론트엔드 배포 버킷 fallingo.app으로 변경**: 도메인 설정\n- **백엔드 CORS 및 API 경로 문제 해결**: CORS 정책 수정\n- **Load Balancer 경로 기반 라우팅 설정**: 로드 밸런서 구성\n- **Cloud Run 배포 오류 수정**: 배포 안정화\n\n### API 개선 (7개 커밋)\n- **OpenWeatherMap을 Open-Meteo로 변경**: 날씨 API 교체\n- **API 엔드포인트 404 오류 해결**: 라우팅 문제 해결\n- **피드 목록 조회 API 인증 제거**: 퍼블릭 API로 변경\n- **FastAPI 인증 의존성 오류 수정**: 인증 시스템 안정화\n- **API 파라미터 정합성 수정**: 파라미터 검증 개선\n- **피드 목록 API 500 오류 수정**: 서버 에러 해결\n\n### 프론트엔드 개선 (3개 커밋)\n- **main.dart 파일 정리 및 코드 분리**: 코드 구조 개선\n- **Weather 모델 타입 캐스팅 오류 수정**: 타입 안정성 향상\n- **test_root_redirect 테스트 수정**: 테스트 안정화\n- **파비콘 추가 및 웹 메타데이터 개선**: UX 개선\n\n## 💡 작업 하이라이트\n\n**집중 디버깅 데이**\n\n8월 9일 하루 동안 **20개의 버그 픽스 커밋**을 작성하며 배포 안정화 작업을 진행했습니다. Cloud Run 배포, CORS 정책, API 인증, 환경변수 관리 등 프로덕션 배포 시 발생하는 다양한 이슈들을 체계적으로 해결했습니다.\n\n특히 **OpenWeatherMap → Open-Meteo** API 교체, **Load Balancer 경로 기반 라우팅**, **fallingo.app 도메인** 설정 등 인프라 레벨의 중요한 변경 사항들을 포함하고 있습니다.\n\n피드 목록 API의 인증 제거, 500 에러 수정 등을 통해 API 안정성을 확보했으며, 파비콘과 메타데이터 추가로 웹 앱의 완성도를 높였습니다.\n\n## 📊 개발 현황\n\n- **배포**: Cloud Run + Load Balancer 안정화\n- **도메인**: fallingo.app 설정 완료\n- **API**: 날씨 API 교체, 인증 시스템 안정화\n- **테스트**: 테스트 환경 안정화",
      "description": "하루 동안 20개 버그 픽스 및 배포 안정화",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0010.md"
    },
    {
      "slug": "fallingo-devlog-0011",
      "title": "fallingo 개발일지 - 2025-08-09 ~ 2025-08-12 (20개 커밋)",
      "date": "2025-08-12T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-08-09 ~ 2025-08-12 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 샘플 데이터 및 Mock API (5개 커밋)\n- **샘플 데이터를 일반 장소로 수정**: 테스트 데이터 개선\n- **실제적인 샘플 데이터 추가**: 현실적인 테스트 데이터\n- **AI 추천 Mock API 추가**: AI 기능 목업 구현\n- **테스트 계정 정보 추가**: 문서화\n- **종합 테스트 가이드 및 문서 개선**: 테스트 가이드 작성\n- **AI 추천 기능에 갈비탕(Tier 3) 등급 제한 추가**: 등급 시스템 구현\n\n### Phase 1 백엔드 완료 (6개 커밋)\n- **Phase 1 백엔드 구현 완료 및 배포 준비**: Phase 1 완료\n- **GitHub Actions 워크플로우 수정**: CI/CD 개선\n- **API URL 설정 수정 및 Load Balancer 설정 추가**: 인프라 구성\n- **프로젝트 문서화 및 레거시 파일 정리**: 문서 정리\n- **health endpoint routing to Load Balancer**: 헬스체크 추가\n- **AI health endpoint 수정 및 백엔드 README 추가**: 문서화\n\n### 리셋 및 재구축 (1개 커밋)\n- **reset**: 프로젝트 리셋\n\n### 백엔드 완전 구현 (5개 커밋)\n- **백엔드 완전 구현 및 데이터베이스 설정 완료**: 백엔드 재구축\n- **Remove problematic packages from requirements.txt**: 패키지 정리\n- **Add test files to fix GitHub Actions test failure**: 테스트 수정\n- **Trigger deployment after adding secrets to Secret Manager**: 시크릿 관리\n- **Disable frontend tests temporarily**: 임시 테스트 비활성화\n\n### Identity Platform 인증 (2개 커밋)\n- **Identity Platform 인증 시스템 구현 및 백엔드 아키텍처 개선**: 인증 시스템 구축\n- **Remove non-existent google-cloud-identity-platform package**: 패키지 정리\n\n## 💡 작업 하이라이트\n\n**Phase 1 완료와 인증 시스템 구축**\n\n8월 9일~10일 동안 AI 추천 Mock API와 갈비탕(Tier 3) 등급 제한을 포함한 샘플 데이터를 구축하며 **Phase 1 백엔드 구현을 완료**했습니다. 종합 테스트 가이드와 테스트 계정 정보를 문서화하여 QA 체계를 갖췄습니다.\n\n그러나 8월 10일 다시 **reset**을 결정했고, 8월 11일 **\"백엔드 완전 구현 및 데이터베이스 설정 완료\"** 커밋으로 더 견고한 백엔드를 재구축했습니다. GitHub Actions 테스트 실패 문제를 해결하고, Secret Manager를 통한 보안 설정을 강화했습니다.\n\n8월 12일에는 **Identity Platform 인증 시스템**을 구현하며 백엔드 아키텍처를 대폭 개선했습니다. 이는 프로덕션 레벨의 사용자 인증 체계를 갖추는 중요한 마일스톤입니다.\n\n## 📊 개발 현황\n\n- **Phase 1**: 완료 (리셋 후 재구축)\n- **백엔드**: 완전 구현 (데이터베이스, 인증 시스템)\n- **인증**: Identity Platform 구현\n- **테스트**: 종합 테스트 가이드 작성",
      "description": "Phase 1 백엔드 완료 및 Identity Platform 인증 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0011.md"
    },
    {
      "slug": "fallingo-devlog-0012",
      "title": "fallingo 개발일지 - 2025-08-12 (20개 커밋)",
      "date": "2025-08-12T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-08-12 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 문서 및 설정 정리 (6개 커밋)\n- **기술 스택 문서 업데이트 - Identity Platform 통합 완료**: 문서화\n- **Remove duplicate python field and google-cloud-identity-platform**: pyproject.toml 정리\n- **update --**: 일반 업데이트\n- **Correct PytestDeprecationWarning path**: pytest 설정 수정\n- **Add required environment variables for test configuration**: 테스트 환경 개선\n- **Correct database session import name**: import 수정\n\n### 버그 수정 (3개 커밋)\n- **Correct exception class names in auth.py**: 인증 예외 처리 수정\n- **Resolve import errors and test failures**: import 에러 해결\n- **Add aiosqlite to dependencies for test environment**: 테스트 DB 의존성 추가\n\n### 프로젝트 구조 개선 (5개 커밋)\n- **Consolidate .gitignore files into root**: .gitignore 통합\n- **Add Cloud SQL Proxy setup guide**: Cloud SQL 가이드 추가\n- **Organize Cloud SQL Proxy setup in backend directory**: 디렉토리 정리\n- **Organize scripts folder**: 스크립트 정리\n- **Fix docs/README.md with actual existing files only**: 문서 수정\n\n### 레거시 코드 정리 (6개 커밋)\n- **Remove unused migrations folder**: 사용하지 않는 마이그레이션 삭제\n- **Remove archived legacy scripts**: 아카이브 스크립트 삭제\n- **Remove unnecessary database initialization scripts**: 불필요한 DB 스크립트 삭제\n- **Remove unused GCP infrastructure folders**: 사용하지 않는 GCP 폴더 삭제\n- **Remove temporary test files and credentials**: 임시 파일 정리\n\n### Python 버전 업그레이드 (1개 커밋)\n- **Update to Python 3.13 and latest versions (2025)**: Python 3.13 업그레이드\n\n## 💡 작업 하이라이트\n\n**대규모 코드베이스 정리**\n\n8월 12일 하루 동안 **20개의 리팩토링 커밋**으로 프로젝트를 전면 정리했습니다. Identity Platform 통합 완료 후, 누적된 레거시 코드와 사용하지 않는 인프라 코드를 체계적으로 제거했습니다.\n\n특히 migrations, archived scripts, DB initialization scripts, GCP infrastructure folders, temporary test files 등 **6개의 레거시 코드 삭제 커밋**을 통해 코드베이스를 깔끔하게 정리했습니다.\n\n.gitignore 통합, Cloud SQL Proxy 가이드 추가, scripts 폴더 정리 등으로 프로젝트 구조를 개선했으며, 마지막으로 **Python 3.13**으로 업그레이드하여 최신 버전 생태계로 전환했습니다.\n\n## 📊 개발 현황\n\n- **코드 정리**: 레거시 코드 6개 카테고리 삭제\n- **Python**: 3.13 업그레이드\n- **문서**: Cloud SQL Proxy 가이드, Identity Platform 통합 문서\n- **테스트**: aiosqlite 추가, pytest 설정 개선",
      "description": "대규모 리팩토링 및 프로젝트 정리",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0012.md"
    },
    {
      "slug": "fallingo-devlog-0013",
      "title": "fallingo 개발일지 - 2025-08-12 (20개 커밋)",
      "date": "2025-08-12T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-08-12 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### Python 버전 시행착오 (7개 커밋)\n- **Update to Python 3.13.6 (latest stable)**: 3.13.6 업그레이드\n- **Regenerate requirements.txt for Python 3.13 compatibility**: 의존성 재생성\n- **Update GitHub Actions to properly install dependencies for Python 3.13.6**: CI/CD 수정\n- **Downgrade to Python 3.12 for better compatibility**: 3.12로 다운그레이드\n- **Use requirements.txt directly in Dockerfile instead of Poetry**: Poetry → requirements.txt\n- **Add email-validator dependency for Pydantic email validation**: 의존성 추가\n- **Update to Python 3.13.6 with Poetry support**: 다시 3.13.6 + Poetry\n- **Remove --with dev flag from Poetry install**: Poetry 설정 수정\n\n### Cloud Run 배포 개선 (9개 커밋)\n- **Update Dockerfile to use PORT environment variable for Cloud Run**: PORT 환경변수 추가\n- **Update Dockerfile to properly handle PORT environment variable**: PORT 처리 개선\n- **Simplify Dockerfile and add dedicated startup script for Cloud Run**: 시작 스크립트 추가\n- **Use PORT environment variable for Cloud Run deployment**: PORT 사용\n- **Simplify backend for Cloud Run deployment**: 백엔드 단순화\n- **Update logging to use simplified config**: 로깅 설정 단순화\n- **모든 모듈을 config_simple 사용하도록 변경**: 전체 모듈 config 변경\n- **Cloud Run URL을 TrustedHostMiddleware에 추가**: 신뢰 호스트 추가\n- **원래 config.py 사용하도록 복구 및 환경 변수 수정**: config 복구\n\n### 보안 및 설정 개선 (4개 커밋)\n- **SECRET_KEY를 JWT_SECRET_KEY로 수정**: 환경변수명 명확화\n- **secret_key를 jwt_secret_key로 명확하게 변경**: 코드 명확화\n- **psycopg2-binary 패키지 추가**: PostgreSQL 드라이버 추가\n\n## 💡 작업 하이라이트\n\n**Python 버전 선택과 Cloud Run 최적화**\n\nPython 3.13.6으로 업그레이드했다가 호환성 문제로 **Python 3.12로 다운그레이드**, 그러다 다시 **Python 3.13.6**으로 돌아오는 과정을 거쳤습니다. Poetry와 requirements.txt 사이에서도 고민하며 최적의 의존성 관리 방식을 찾았습니다.\n\nCloud Run 배포를 위해 **PORT 환경변수** 처리를 개선하고, Dockerfile을 단순화했으며, **TrustedHostMiddleware**에 Cloud Run URL을 추가하여 보안을 강화했습니다. config.py를 config_simple로 변경했다가 다시 원래대로 복구하는 과정에서 최적의 설정을 찾았습니다.\n\n**SECRET_KEY → JWT_SECRET_KEY** 리네이밍으로 환경변수의 용도를 명확히 했으며, psycopg2-binary를 추가하여 PostgreSQL 연결을 안정화했습니다.\n\n## 📊 개발 현황\n\n- **Python**: 3.13.6 (최종 선택)\n- **배포**: Cloud Run PORT 환경변수 처리 완료\n- **보안**: JWT_SECRET_KEY 명확화, TrustedHost 설정\n- **DB**: psycopg2-binary 추가",
      "description": "Python 버전 시행착오 및 Cloud Run 배포 안정화",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0013.md"
    },
    {
      "slug": "fallingo-devlog-0014",
      "title": "fallingo 개발일지 - 2025-08-12 (20개 커밋)",
      "date": "2025-08-12T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-08-12 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 의존성 정리 (3개 커밋)\n- **pyproject.toml에도 psycopg2-binary 추가**: 의존성 동기화\n- **Poetry lock 파일 업데이트 및 requirements.txt 재생성**: 의존성 재생성\n- **Redis 비활성화 및 비용 최적화**: Redis 비활성화\n- **Cloud Run 배포 오류 해결**: 배포 수정\n- **Redis 완전 제거**: Redis 완전 삭제\n\n### Cloud Run 최적화 (6개 커밋)\n- **콘피그 hide**: 설정 숨김\n- **config_simple.py로 전환하여 배포 문제 해결**: 설정 단순화\n- **Cloud Run 배포 시작 시간 최적화 - uvicorn workers 설정 조정**: 성능 최적화\n- **otel_service_name 속성 추가로 테스트 오류 해결**: OpenTelemetry 설정\n- **Cloud Run 시작 문제 해결**: lifespan 에러 처리 추가\n- **claude**: 일반 업데이트\n- **config_simple.py에서 config.py로 복원**: 설정 복원\n\n### API 경로 개선 (3개 커밋)\n- **/api prefix 추가로 fallingo.app/api/docs 접근 가능하도록 수정**: API prefix 추가\n- **/health 엔드포인트 제거, /api/health만 유지**: 경로 통일\n- **hide open**: 설정 숨김\n- **health check 테스트 경로를 /api/health로 수정**: 테스트 수정\n\n### 보안 강화 (1개 커밋)\n- **보안 강화 구현**:\n  - JWT 시크릿 키 환경변수 사용\n  - Rate Limiting 미들웨어 추가 (60req/min)\n  - CORS 프로덕션 도메인만 허용\n  - 토큰 블랙리스트 구현 (로그아웃 시 무효화)\n\n### 대규모 리팩토링 (3개 커밋)\n- **백엔드 코드 품질 개선 및 레거시 제거**: 전체 코드 정리\n- **main.py 대규모 리팩토링 및 코드 구조 개선**: 메인 파일 리팩토링\n- **인증 서비스 대규모 리팩토링 및 분리**: 인증 로직 분리\n\n## 💡 작업 하이라이트\n\n**비용 최적화와 프로덕션 준비**\n\n**Redis를 완전 제거**하여 인프라 비용을 최적화했습니다. 초기에는 캐싱 레이어로 Redis를 고려했으나, 현재 단계에서는 불필요하다고 판단하여 과감히 제거했습니다.\n\nCloud Run 배포를 위해 lifespan에서 **외부 연결 실패 시에도 앱이 시작**되도록 에러 처리를 추가했고, uvicorn workers 설정을 조정하여 **시작 시간을 최적화**했습니다.\n\n**보안 강화**가 이번 작업의 핵심입니다:\n- **Rate Limiting**: 60req/min으로 DDoS 방어\n- **CORS**: 프로덕션 환경에서 실제 도메인만 허용\n- **토큰 블랙리스트**: 로그아웃 시 JWT 무효화\n\n마지막으로 **main.py와 인증 서비스를 대규모 리팩토링**하며 코드 품질을 대폭 향상시켰습니다. **/api prefix** 추가로 API 경로를 표준화했습니다.\n\n## 📊 개발 현황\n\n- **인프라**: Redis 제거, 비용 최적화\n- **보안**: Rate Limiting, CORS, JWT 블랙리스트 구현\n- **API**: /api prefix 표준화\n- **코드**: main.py, 인증 서비스 리팩토링 완료",
      "description": "Redis 제거, 보안 강화 및 대규모 리팩토링",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0014.md"
    },
    {
      "slug": "fallingo-devlog-0015",
      "title": "fallingo 개발일지 - 2025-08-12 ~ 2025-08-13 (20개 커밋)",
      "date": "2025-08-13T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-08-12 ~ 2025-08-13 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 버그 수정 (6개 커밋)\n- **dependencies.py 정리 및 import 오류 수정**: 의존성 정리\n- **IndentationError in auth.py line 50**: 들여쓰기 에러 수정\n- **Cloud Run 배포 오류 수정**: 3회 배포 이슈 해결\n- **불필요한 데일리 로그인 포인트 상수 제거**: 코드 정리\n\n### API 구현 (5개 커밋)\n- **User API 구현**: 사용자 API 완성\n- **API URL 수정 및 User API 문서 업데이트**: 문서화\n- **Feed, Restaurant API 구현 및 모든 주요 API 완성**: 핵심 API 완성\n- **기획서 기반 포인트 시스템 정확히 반영**: 포인트 시스템 구현\n- **개발 체크리스트 및 API 상태 업데이트**: 진행 상황 문서화\n- **api 체크리스트**: 체크리스트 정리\n\n### FastAPI 파라미터 수정 (4개 커밋)\n- **FastAPI Depends 사용 오류 수정**: Depends 수정\n- **FastAPI 파라미터 순서 오류 수정**: 파라미터 순서 수정\n- **Python 파라미터 순서 규칙 준수**: 순서 규칙 적용\n- **users.py 모든 파라미터 순서 오류 수정**: users.py 수정\n- **Cloud Run 배포 리전 통일 및 시작 최적화**: 배포 최적화\n\n### 백엔드 전면 재작성 (4개 커밋)\n- **백엔드 전체 삭제 - 처음부터 다시 시작**: 전체 리셋\n- **FastAPI 백엔드 구현 및 데이터베이스 스키마 완성**: 백엔드 재구축\n- **Swagger UI 경로 수정 (/api/docs)**: API 문서 경로 수정\n- **GitHub Actions 워크플로우 수정 (Poetry → pip)**: 빌드 도구 변경\n\n## 💡 작업 하이라이트\n\n**주요 API 완성 후 전면 재작성**\n\n8월 12일, **User API, Feed API, Restaurant API**를 모두 구현하며 \"모든 주요 API 완성\"을 선언했습니다. 기획서 기반 포인트 시스템을 정확히 반영하고, API 체크리스트로 진행 상황을 문서화했습니다.\n\n그러나 FastAPI 파라미터 순서 오류가 여러 파일에서 발견되며 4개의 수정 커밋이 연속으로 발생했습니다. Cloud Run 배포 오류도 3회 발생했습니다.\n\n결국 8월 12일 저녁, **\"백엔드 전체 삭제 - 처음부터 다시 시작\"** 결정을 내렸습니다. 이는 누적된 기술 부채와 구조적 문제를 해결하기 위한 과감한 선택이었습니다.\n\n8월 13일, **FastAPI 백엔드 구현 및 데이터베이스 스키마를 완성**하며 더 견고한 백엔드를 재구축했습니다. **Poetry에서 pip**으로 빌드 도구를 변경하여 배포를 단순화했습니다.\n\n## 📊 개발 현황\n\n- **API**: User, Feed, Restaurant API 완성 → 리셋\n- **백엔드**: 전체 재작성 (FastAPI + DB 스키마)\n- **빌드**: Poetry → pip 전환\n- **배포**: GitHub Actions 워크플로우 재구성",
      "description": "주요 API 완성 및 백엔드 전면 재작성",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0015.md"
    },
    {
      "slug": "fallingo-devlog-0016",
      "title": "fallingo 개발일지 - 2025-08-13 ~ 2025-08-25 (20개 커밋)",
      "date": "2025-08-25T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-08-13 ~ 2025-08-25 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 배포 및 호환성 수정 (6개 커밋)\n- **GitHub Actions Poetry → pip 변경**: 빌드 도구 전환\n- **Python 3.13 → 3.12 다운그레이드 (asyncpg 호환성)**: Python 버전 조정\n- **Cloud Run 배포 오류 수정**: 배포 이슈 해결\n- **Cloud Run 배포를 위한 단순화**: 배포 프로세스 단순화\n- **GCP 패키지 다시 활성화**: GCP 라이브러리 복원\n- **/api prefix routing for Load Balancer compatibility**: 라우팅 설정\n\n### API 구조 구현 (1개 커밋)\n- **Implement basic API endpoints structure**: 기본 API 구조 구축\n\n### 개발 중단 (3개 커밋)\n- **백엔드 개발중**: 2회 개발 진행\n- **dev stop**: 개발 중단\n\n### 리셋 및 문서화 전환 (10개 커밋)\n- **reset -- backend** (8/15): 백엔드 리셋\n- **데이터베이스 문서 완전 재작성 및 정리** (8/16): DB 문서화 시작\n- **데이터베이스 문서 개선 및 정리** (8/20): DB 문서 개선\n- **DELETE**: 파일 삭제\n- **CLAUDE.md 개선 및 한글화**: AI 가이드 문서 개선\n- **데이터베이스 문서 체계 완성** (8/21): DB 문서 완성\n- **RESET** (8/25): 전체 리셋\n- **fallingo 데이터베이스 설계 및 백엔드 문서 100% 완성**: 완전한 문서화\n- **문서 작성일 2025-08-25로 수정**: 날짜 수정\n- **Cloud SQL 데이터베이스 구축 및 REST API 작성 가이드 추가**: 가이드 추가\n\n## 💡 작업 하이라이트\n\n**개발에서 문서화로 전략 전환**\n\n8월 13일~14일, Python 3.12로 다운그레이드하고 기본 API 구조를 구축하며 백엔드 개발을 진행했으나, **\"dev stop\"** 커밋으로 개발을 중단했습니다.\n\n8월 15일 **백엔드 리셋** 후, 전략을 완전히 전환했습니다. 코드를 작성하는 대신 **데이터베이스 설계 문서화에 집중**하기 시작했습니다.\n\n8월 16일부터 21일까지 데이터베이스 문서를 3회 업데이트하며 체계를 완성했고, **CLAUDE.md 개선 및 한글화**로 AI 협업 가이드도 작성했습니다.\n\n8월 25일, 다시 한번 **RESET** 후 **\"fallingo 데이터베이스 설계 및 백엔드 문서 100% 완성\"**을 선언했습니다. Cloud SQL 구축 가이드와 REST API 작성 가이드를 추가하여 완전한 개발 문서를 완성했습니다.\n\n이는 반복된 리셋과 실패를 경험한 후, **완벽한 설계 문서를 먼저 작성하고 개발하자**는 전략적 결정으로 보입니다.\n\n## 📊 개발 현황\n\n- **코드 개발**: 중단 (dev stop)\n- **문서화**: 100% 완성 (DB 설계, 백엔드, Cloud SQL, REST API 가이드)\n- **전략**: 문서 우선 → 개발 (Document-First Development)",
      "description": "개발 중단 및 데이터베이스 문서화 집중",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0016.md"
    },
    {
      "slug": "fallingo-devlog-0017",
      "title": "fallingo 개발일지 - 2025-08-26 ~ 2025-09-04 (20개 커밋)",
      "date": "2025-09-04T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-08-26 ~ 2025-09-04 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### API 문서화 및 DB 통일 (6개 커밋)\n- **완전한 REST API 문서화 완료 (11개 문서, 85+ 엔드포인트)**: 전체 API 문서화\n- **PostgreSQL 17 + Cloud SQL 호환성 개선**: DB 호환성\n- **스크립트 파일들을 docs/database/scripts로 이동**: 파일 정리\n- **티어 시스템을 데이터베이스 기준으로 통일**: 티어 통일\n- **price_range 타입을 데이터베이스 기준으로 통일**: 타입 통일\n- **API 스키마를 데이터베이스와 100% 일치하도록 완전 수정**: 완전 동기화\n\n### 백엔드 인프라 구축 (3개 커밋)\n- **백엔드 아키텍처 기반 구축 및 문서 업데이트** (9/2): 아키텍처 구축\n- **법적 문서 시스템 및 배포 인프라 완성** (9/3): 법적 시스템 구축\n- **백엔드 개발 완성 문서화** (9/3): 백엔드 완성\n\n### 광고 시스템 구현 (2개 커밋)\n- **AdMob/AdSense 광고 시스템 누락 사항 문서화**: 광고 문서화\n- **AdMob/AdSense 광고 시스템 구현**: 광고 시스템 구현\n\n### 보안 및 티어 시스템 (6개 커밋)\n- **종합 보안 시스템 구현**: 보안 시스템 구축\n- **SNS 상호작용 최적화 - 티어별 좋아요 반경 시스템**: 반경 제한 시스템\n- **포인트 정책 수정 - 받는 행위에는 포인트 보상 유지**: 포인트 정책 개선\n- **중복 포인트 지급 방지 시스템 구현**: 중복 방지\n- **티어별 상호작용 시스템 문서 완전 업데이트**: 문서 업데이트\n- **완성된 티어별 상호작용 반경 제한 시스템 구현**: 시스템 완성\n\n### 코드베이스 정리 (3개 커밋)\n- **불필요한 파일들 정리 및 코드베이스 최적화**: 파일 정리\n- **법적 문서 임시 파일들 대규모 정리**: 임시 파일 삭제\n- **추가 불필요 파일 정리**: 추가 정리\n\n## 💡 작업 하이라이트\n\n**문서화 완성 후 본격 개발**\n\n8월 26일, **11개 문서에 85개 이상의 엔드포인트를 포함한 완전한 REST API 문서화**를 완료했습니다. 이후 티어 시스템, price_range 타입 등 **API 스키마를 데이터베이스와 100% 일치**시키는 작업을 진행했습니다.\n\n9월 2일부터 본격적인 개발에 돌입했습니다. **백엔드 아키텍처를 구축**하고, 9월 3일에는 **법적 문서 시스템 및 배포 인프라를 완성**하며 \"백엔드 개발 완성\"을 문서화했습니다.\n\n9월 4일, 핵심 기능들을 집중적으로 구현했습니다:\n- **AdMob/AdSense 광고 시스템**: 수익화 모델 구현\n- **종합 보안 시스템**: 프로덕션 보안 강화\n- **티어별 상호작용 반경 제한**: 게이미피케이션 핵심 메커니즘\n- **중복 포인트 지급 방지**: 정책 남용 방지\n\n마지막으로 법적 문서 임시 파일 등 불필요한 파일들을 대규모로 정리하며 코드베이스를 최적화했습니다.\n\n## 📊 개발 현황\n\n- **문서**: 11개 API 문서, 85+ 엔드포인트\n- **백엔드**: 아키텍처 + 법적 시스템 + 배포 인프라 완성\n- **핵심 기능**: 광고, 보안, 티어별 반경 제한, 포인트 중복 방지\n- **코드 정리**: 임시 파일 대규모 정리 완료",
      "description": "완전한 API 문서화 및 백엔드 핵심 기능 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0017.md"
    },
    {
      "slug": "fallingo-devlog-0018",
      "title": "fallingo 개발일지 - 2025-09-04 ~ 2025-09-09 (20개 커밋)",
      "date": "2025-09-09T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-09-04 ~ 2025-09-09 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 백엔드 완성 및 프로덕션 준비 (4개 커밋)\n- **SQLAlchemy 관계 설정 오류 완전 수정 및 회원가입 API 추가**: DB 관계 수정\n- **Cloud Run 배포를 위한 포트 설정 수정**: 배포 설정\n- **백엔드 완성도 최적화 및 프로덕션 준비 완료**: 프로덕션 준비\n- **commit used backend changes; remove test files and pytest cache**: 테스트 파일 정리\n- **prompt**: 일반 업데이트\n\n### Cloud Run 배포 문제 해결 (5개 커밋)\n- **Cloud Run 배포 실패 문제 완전 해결**: 배포 수정\n- **Cloud Run PORT 환경변수 충돌 문제 해결**: PORT 충돌 해결\n- **Cloud Run 컨테이너 시작 최적화 및 배포 안정성 개선**: 시작 최적화\n- **간단한 FastAPI 앱으로 Cloud Run 배포 테스트**: 최소 앱 테스트\n\n### 단계별 배포 테스트 (11개 커밋)\n- **step1: 기본 FastAPI 구조 복원 테스트**: 1단계 테스트\n- **step2: 데이터베이스 연결 추가 테스트**: 2단계 테스트\n- **step3: 미들웨어 단계별 추가 테스트**: 3단계 테스트\n- **단계별 배포 테스트**: 일반 테스트\n- **TrustedHost 미들웨어에 Cloud Run 도메인 패턴 추가**: TrustedHost 수정\n- **TrustedHost 미들웨어 '*' 호스트 패턴 제거**: 패턴 제거\n- **claude**: 일반 업데이트\n- **step4: Secret Manager 통합 테스트**: 4단계 테스트\n- **Claude 설정 파일 동기화**: 설정 동기화\n- **5단계 Startup Application 통합 완료**: 5단계 완료\n- **6단계 기본 API 라우터 통합 완료**: 6단계 완료\n\n## 💡 작업 하이라이트\n\n**단계별 통합 테스트로 배포 안정화**\n\n9월 4일, SQLAlchemy 관계 설정을 완전히 수정하고 회원가입 API를 추가하며 **\"백엔드 완성도 최적화 및 프로덕션 준비 완료\"**를 선언했습니다.\n\n그러나 9월 8일~9일, Cloud Run 배포에서 **PORT 환경변수 충돌, 컨테이너 시작 실패** 등 다양한 문제가 발생했습니다. 문제를 근본적으로 해결하기 위해 **단계별 통합 테스트** 전략을 채택했습니다:\n\n**Step 1**: 기본 FastAPI 구조 복원 ✅\n**Step 2**: 데이터베이스 연결 추가 ✅\n**Step 3**: 미들웨어 단계별 추가 ✅\n**Step 4**: Secret Manager 통합 ✅\n**Step 5**: Startup Application 통합 ✅\n**Step 6**: 기본 API 라우터 통합 ✅\n\n각 단계마다 배포 테스트를 진행하며 문제가 발생한 지점을 정확히 파악했습니다. 특히 **TrustedHost 미들웨어**의 Cloud Run 도메인 패턴 문제를 발견하고 해결했습니다.\n\n## 📊 개발 현황\n\n- **배포**: Cloud Run 단계별 통합 테스트 6단계 완료\n- **인프라**: PORT 충돌, TrustedHost, Secret Manager 이슈 해결\n- **API**: 회원가입 API 추가\n- **전략**: 단계별 통합 테스트 방법론 확립",
      "description": "Cloud Run 배포 문제 해결 및 단계별 통합 테스트",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0018.md"
    },
    {
      "slug": "fallingo-devlog-0019",
      "title": "fallingo 개발일지 - 2025-09-09 ~ 2025-09-10 (20개 커밋)",
      "date": "2025-09-10T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-09-09 ~ 2025-09-10 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 전체 API 통합 완료 (5개 커밋)\n- **🎉 FINAL: 7단계 전체 API 라우터 통합 완료 - 복원 성공!**: 전체 통합\n- **🏆 FINAL REPLACEMENT: 원본 main.py 완전 교체 완료!**: main.py 교체\n- **불필요한 백업 파일들 정리**: 백업 파일 삭제\n- **백엔드 폴더의 불필요한 테스트 및 스크립트 파일 정리**: 테스트 파일 정리\n- **클로드 설정**: Claude 설정\n\n### 프로덕션 배포 수정 (4개 커밋)\n- **Add setup_security_middleware function to resolve 403 errors**: 보안 미들웨어 수정\n- **🚨 HOTFIX: Add missing secrets.py module to restore all APIs**: secrets.py 추가\n- **백엔드 의존성 설치 및 170개 API 엔드포인트 로드 문제 해결**: 의존성 해결\n- **.env 파일들을 gitignore에 추가하고 예제 템플릿 생성**: 환경변수 보안\n\n### API 안정화 (11개 커밋)\n- **feeds API 인증 문제 해결 - 로그인 없이도 접근 가능하도록 수정**: 인증 제거\n- **feeds API 500 오류 해결 및 불필요한 필드 제거**: 500 에러 수정\n- **production deployment critical issues**: 프로덕션 이슈 해결\n- **resolve NoneType + int error in feed stats**: NoneType 에러 수정\n- **완전히 share_count 제거 및 피드 이미지 필드 안정성 개선**: share_count 삭제\n- **FeedImage 모델 import 충돌 해결 및 None 값 안전 처리**: import 충돌 해결\n- **NoneType + int 오류 해결 - 포인트 연산 안전성 개선**: 포인트 연산 수정\n- **모든 NoneType += 에러 수정**: += 에러 전체 수정\n- **NoneType 나눗셈 에러 수정 (CTR 계산)**: CTR 계산 수정\n- **gamification_service의 NoneType 나눗셈 에러 수정**: gamification 수정\n- **레스토랑 API NoneType 에러 수정 (5개 수정사항)**: 레스토랑 API 수정\n\n## 💡 작업 하이라이트\n\n**전체 API 통합 성공 후 NoneType 에러와의 전쟁**\n\n9월 9일, **\"🎉 FINAL: 7단계 전체 API 라우터 통합 완료 - 복원 성공!\"** 커밋으로 단계별 통합 테스트를 성공적으로 마무리했습니다. 원본 main.py를 완전히 교체하고 백업 파일들을 정리하며 깔끔한 코드베이스를 구축했습니다.\n\n9월 10일, 프로덕션 배포 후 **170개 API 엔드포인트 로드 문제**를 해결하고, 403 에러 수정, secrets.py 모듈 추가 등 핫픽스를 진행했습니다.\n\n그러나 feeds API에서 **500 에러가 발생**하며 본격적인 디버깅이 시작되었습니다. 문제의 핵심은 **NoneType 에러**였습니다:\n- NoneType + int (feed stats, 포인트 연산)\n- NoneType += (여러 곳에서 발생)\n- NoneType 나눗셈 (CTR 계산, gamification_service)\n\n**11개의 연속 수정 커밋**으로 feeds API, gamification_service, 레스토랑 API의 NoneType 에러를 체계적으로 해결했습니다. share_count 필드를 완전히 제거하고, None 값에 대한 안전 처리를 추가했습니다.\n\n## 📊 개발 현황\n\n- **API**: 170개 엔드포인트 통합 완료\n- **배포**: 프로덕션 배포 성공\n- **버그 수정**: NoneType 에러 11개 수정 커밋\n- **안정성**: feeds, gamification, restaurant API 안정화",
      "description": "전체 API 통합 완료 및 NoneType 에러 집중 수정",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0019.md"
    },
    {
      "slug": "fallingo-devlog-0020",
      "title": "fallingo 개발일지 - 2025-09-10 ~ 2025-10-01 (20개 커밋)",
      "date": "2025-10-01T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-09-10 ~ 2025-10-01 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 리셋 및 문서 동기화 (6개 커밋)\n- **레스토랑 API NULL 정렬 에러 수정**: NULL 에러 수정\n- **RESET** (9/10): 전체 리셋\n- **API-기획서-데이터베이스 문서 일치성 완료** (9/12): 문서 동기화\n- **GCP 기반 FastAPI 백엔드 스케폴딩 구현** (9/15): 스케폴딩 구축\n- **실제 DB 스키마에 맞춰 전체 문서 동기화** (9/15): DB 동기화\n- **SQL 스키마 통합 및 중복 파일 정리** (9/16): 스키마 통합\n\n### 문서 및 시스템 정리 (2개 커밋)\n- **권역 시스템 통합 및 문서 정정 완료** (9/17): 권역 시스템 정리\n- **문서 준비** (9/17): 문서 정리\n\n### 핵심 기능 구현 (8개 커밋)\n- **FastAPI 백엔드 인증 및 CSRF 보안 시스템 구현** (9/17): 보안 시스템\n- **팔로우 시스템 완전 구현 (QR 기반 + 일반 팔로우)** (9/19): 팔로우 시스템\n- **메ㅑ** (9/19): 일반 업데이트\n- **Feed API 완성 및 통합 테스트 구현** (9/22): Feed API 완성\n- **근거리 탐지 팔로우 시스템 완전 구현** (9/23): 근거리 팔로우\n- **AI integration APIs 및 Restaurant API 완전 구현** (9/26): AI + Restaurant API\n- **핵심 백엔드 기능 완성 및 테스트 구현** (10/1): 백엔드 완성\n- **전체 API 모듈 및 문서 완성** (10/1): API 모듈 완성\n\n### 코드 품질 개선 (4개 커밋)\n- **Feed Service GPS 인증 변수 정의 오류 수정**: 버그 수정\n- **코드 품질 개선 1단계**: 1단계 리팩토링\n- **코드 품질 개선 2단계 - Type Hinting 추가**: Type Hinting\n- **코드 품질 개선 3단계 - Docstring 추가**: Docstring\n\n## 💡 작업 하이라이트\n\n**완벽한 재구축과 체계적 개발**\n\n9월 10일 NULL 정렬 에러 수정 후 다시 **RESET**을 결정했습니다. 이번에는 다릅니다. 9월 12일 **API-기획서-데이터베이스 문서 일치성을 완료**하며 완벽한 문서화부터 시작했습니다.\n\n9월 15일~16일, GCP 기반 FastAPI 백엔드 스케폴딩을 구현하고, 실제 DB 스키마와 문서를 완전히 동기화했습니다. SQL 스키마를 통합하고 중복 파일을 정리하며 깔끔한 기반을 마련했습니다.\n\n9월 17일부터 본격적인 기능 구현에 돌입했습니다:\n- **9/17**: 인증 + CSRF 보안 시스템\n- **9/19**: QR 기반 + 일반 팔로우 시스템\n- **9/22**: Feed API 완성 + 통합 테스트\n- **9/23**: 근거리 탐지 팔로우 시스템\n- **9/26**: AI integration + Restaurant API\n- **10/1**: 핵심 백엔드 기능 완성, 전체 API 모듈 완성\n\n마지막으로 10월 1일, **3단계 코드 품질 개선**을 진행했습니다:\n1. 일반 리팩토링\n2. Type Hinting 추가\n3. Docstring 추가\n\n## 📊 개발 현황\n\n- **문서**: API-기획서-DB 완전 동기화\n- **백엔드**: 인증, CSRF, 팔로우, Feed, AI, Restaurant API 완성\n- **테스트**: 통합 테스트 구현\n- **코드 품질**: Type Hinting + Docstring 완료",
      "description": "리셋 후 백엔드 완전 재구축 및 코드 품질 개선",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0020.md"
    },
    {
      "slug": "fallingo-devlog-0021",
      "title": "fallingo 개발일지 - 2025-10-01 ~ 2025-10-17 (20개 커밋)",
      "date": "2025-10-17T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-01 ~ 2025-10-17 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 백엔드 완성 (3개 커밋)\n- **코드 품질 개선 진행 상황 리포트 추가**: 리포트 문서화\n- **prompt**: 일반 업데이트\n- **백엔드 145 엔드포인트 완전 구현 및 문서 업데이트** (10/12): 백엔드 완성\n\n### Flutter 프론트엔드 구조 (7개 커밋)\n- **Flutter 단일 코드베이스로 프론트엔드 문서 재구성**: 문서 재구성\n- **frontend 폴더를 프로젝트 root로 구조 변경**: 폴더 구조 변경\n- **문서 날짜 수정 (2025-10-12)**: 날짜 수정\n- **Flutter 패키지 최신 버전으로 업데이트 (2025-10)**: 패키지 업데이트\n- **조직 식별자를 app.fallingo로 수정 (도메인: fallingo.app)**: 조직 ID 수정\n- **Flutter 앱 내부 텍스트 다국어 처리 구성 추가**: i18n 구성\n- **Flutter i18n 설정 완료**: i18n 완료\n\n### Flutter UI 구현 (7개 커밋)\n- **Flutter UI 시스템 구현 완료**: UI 시스템 구축\n- **l10n import 경로 수정 및 테스트 업데이트**: import 수정\n- **날씨 기반 동적 스플래시 화면 구현**: 스플래시 화면\n- **인증 시스템 및 날씨 기반 스플래시 화면 구현** (10/15): 인증 시스템\n- **피드/프로필/검색 화면 완전 구현 + 백엔드 닉네임/프로필 개선** (10/17): 핵심 화면 구현\n- **프론트엔드 구현 상태 및 개발 가이드 문서 업데이트** (10/17): 문서 업데이트\n\n### 백엔드 고도화 (3개 커밋)\n- **백엔드 서비스 레이어 함수형 프로그래밍 패턴 적용** (10/13): FP 패턴 적용\n- **백엔드 API 테스트 완료 및 서비스 레이어 리팩토링** (10/15): 테스트 완료\n- **스마트 피드 큐레이션 및 무한 스크롤 구현** (10/15): 피드 큐레이션\n- **스마트 피드 큐레이션 및 티어별 반경 문서 업데이트** (10/15): 문서 업데이트\n\n## 💡 작업 하이라이트\n\n**백엔드 완성 후 프론트엔드 본격 개발**\n\n10월 12일, **백엔드 145 엔드포인트 완전 구현**을 선언하며 백엔드 개발을 마무리했습니다. 이후 Flutter 프론트엔드 개발에 본격적으로 돌입했습니다.\n\n**Flutter 프로젝트 구조 확립** (10/12):\n- 단일 코드베이스로 문서 재구성\n- frontend 폴더를 프로젝트 root로 이동\n- 조직 식별자: app.fallingo (도메인: fallingo.app)\n- Flutter 패키지 최신 버전 (2025-10)\n- i18n 다국어 처리 완료\n\n**백엔드 고도화** (10/13~10/15):\n- 서비스 레이어에 **함수형 프로그래밍 패턴** 적용\n- API 테스트 완료 및 서비스 레이어 리팩토링\n- **스마트 피드 큐레이션 + 무한 스크롤** 구현\n- 티어별 반경 시스템 문서화\n\n**Flutter 핵심 기능 구현** (10/15~10/17):\n- UI 시스템 구축\n- **날씨 기반 동적 스플래시 화면**\n- 인증 시스템 구현\n- **피드/프로필/검색 화면 완전 구현**\n- 백엔드 닉네임/프로필 개선\n\n## 📊 개발 현황\n\n- **백엔드**: 145 엔드포인트 완성, FP 패턴, 스마트 큐레이션\n- **프론트엔드**: Flutter UI 시스템, 인증, 피드/프로필/검색 화면\n- **인프라**: i18n, 날씨 기반 스플래시, 무한 스크롤",
      "description": "백엔드 145 엔드포인트 완성 및 Flutter 프론트엔드 본격 개발",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0021.md"
    },
    {
      "slug": "fallingo-devlog-0022",
      "title": "fallingo 개발일지 - 2025-10-17 ~ 2025-10-22 (20개 커밋)",
      "date": "2025-10-22T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-17 ~ 2025-10-22 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 인프라 및 문서 정리 (2개 커밋)\n- **logo** (10/20): 로고 추가\n- **docs 폴더 구조 정리 및 통합** (10/17): 문서 정리\n\n### 인증 시스템 개선 (6개 커밋)\n- **GCP Identity Platform 마이그레이션 및 프론트엔드 API 통합** (10/20): Identity Platform 전환\n- **API 경로에서 /v1 제거** (10/20): API 경로 단순화\n- **회원가입 시 국가 국기를 기본 프로필 이미지로 설정** (10/21): 프로필 기본 이미지\n- **소셜 로그인 패키지 추가 및 린트 에러 수정** (10/21): 소셜 로그인 준비\n- **소셜 로그인 완전 구현 (Google, Apple, Facebook, Twitter)** (10/21): 4개 소셜 로그인\n- **법률 문서 다국어 API 및 Android 인증 설정 완료** (10/21): 법률 API\n\n### AI 및 댓글 기능 (5개 커밋)\n- **댓글 좋아요 기능 추가 + 불필요한 화면 삭제** (10/20): 댓글 좋아요 백엔드\n- **댓글 좋아요 UI 구현 완료** (10/20): 댓글 좋아요 프론트\n- **Gemini API 기반 AI 콘텐츠 검수 구현** (10/21): AI 검수 시스템\n- **AI 검수 비용 절감 시스템 구현 (85-90% 절감)** (10/21): 비용 최적화\n- **실시간 카메라 오버레이에 최근 등록 시간 추가** (10/21): 카메라 UI 개선\n\n### 프론트엔드 API 연동 (3개 커밋)\n- **피드 화면 실제 API 연동 구현** (10/21): 피드 API 연동\n- **FeedCard 파라미터 린트 에러 수정** (10/21): 린트 수정\n- **다국어 파일 에러 수정** (10/21): i18n 수정\n\n### GCP 프로젝트 변경 (4개 커밋)\n- **로고 이미지 확장자 변경 (jpg → png)** (10/21): 로고 수정\n- **GCP 프로젝트 ID 업데이트 (fallingo-449913 → fallingo-473300)** (10/21): 프로젝트 ID 변경\n- **GCP 프로젝트 정보 업데이트 및 데이터베이스 마이그레이션 설정** (10/22): DB 마이그레이션\n- **GitHub Actions에서 Poetry 사용하도록 수정** (10/22): Poetry 전환\n\n## 💡 작업 하이라이트\n\n**소셜 로그인 완전 구현**\n\n10월 20일, **GCP Identity Platform**으로 마이그레이션하며 인증 시스템을 대폭 개선했습니다. API 경로에서 /v1을 제거하여 단순화했고, 회원가입 시 **국가 국기를 기본 프로필 이미지**로 설정하는 세련된 UX를 구현했습니다.\n\n10월 21일, **Google, Apple, Facebook, Twitter 4개 소셜 로그인**을 완전히 구현했습니다. 법률 문서 다국어 API와 Android 인증 설정까지 완료하며 프로덕션 준비를 마쳤습니다.\n\n**AI 콘텐츠 검수 비용 85-90% 절감**\n\n**Gemini API 기반 AI 콘텐츠 검수 시스템**을 구축했습니다. 핵심은 **비용 절감 시스템**으로, AI 검수 비용을 **85-90% 절감**했습니다. 이는 스타트업에게 매우 중요한 성과입니다.\n\n**GCP 프로젝트 마이그레이션**\n\n10월 21일~22일, GCP 프로젝트를 **fallingo-449913 → fallingo-473300**으로 변경했습니다. 데이터베이스 마이그레이션 설정을 완료하고, GitHub Actions를 Poetry로 전환했습니다.\n\n## 📊 개발 현황\n\n- **인증**: Identity Platform, 4개 소셜 로그인 완성\n- **AI**: Gemini 검수 시스템, 85-90% 비용 절감\n- **프론트엔드**: 피드 API 연동, 댓글 좋아요 UI\n- **인프라**: GCP 프로젝트 마이그레이션, Poetry 전환",
      "description": "소셜 로그인, AI 콘텐츠 검수, GCP 프로젝트 마이그레이션",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0022.md"
    },
    {
      "slug": "fallingo-devlog-0023",
      "title": "fallingo 개발일지 - 2025-10-22 (20개 커밋)",
      "date": "2025-10-22T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-22 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### Dockerfile 및 Poetry 설정 (4개 커밋)\n- **FastAPI 백엔드용 프로덕션 Dockerfile 추가**: 프로덕션 Dockerfile 작성\n- **poetry.lock을 Git 추적에 추가**: lock 파일 추가\n- **Dockerfile에서 poetry.lock 자동 생성하도록 수정**: 자동 생성\n- **Poetry 명령어 업데이트 (--no-dev → --only main)**: 최신 명령어\n\n### Cloud Build 배포 시도 (4개 커밋)\n- **Trigger deployment**: 배포 트리거\n- **Cloud Build를 사용하도록 배포 워크플로우 개선**: Cloud Build 전환\n- **Retry deployment with Cloud Build permissions**: 권한 재시도\n- **dev check**: 개발 체크\n\n### Docker 직접 빌드 전환 (5개 커밋)\n- **Cloud Build 대신 Docker 직접 빌드로 변경**: Docker 직접 빌드\n- **Retry deployment with iam.serviceAccountUser permission**: IAM 권한 추가\n- **Remove --service-account option to use default Compute Engine SA**: 기본 SA 사용\n- **Add DATABASE_URL and DATABASE_PASSWORD for Cloud SQL connection**: DB 환경변수\n- **Cloud Run 배포 문제 해결**: 배포 문제 해결\n\n### 의존성 및 버그 수정 (7개 커밋)\n- **Update poetry.lock for google-generativeai**: poetry.lock 업데이트\n- **Fix function parameter order in feed_curation_service**: 파라미터 순서 수정\n- **Add missing aiohttp dependency**: aiohttp 추가\n- **Add missing google-cloud-documentai dependency**: documentai 추가\n- **Disable Redis cache manager (not currently used)**: Redis 비활성화\n- **Re-enable in-memory cache manager (not Redis)**: 인메모리 캐시 활성화\n- **Skip init_db() during startup for faster cold start**: DB 초기화 스킵\n\n## 💡 작업 하이라이트\n\n**Cloud Run 배포 최적화**\n\n프로덕션 배포를 위한 Dockerfile을 작성하며 시작했습니다. Poetry 설정을 최신화하고 (--no-dev → --only main), poetry.lock을 Git에 추가했습니다.\n\n**Cloud Build vs Docker 직접 빌드**\n\n처음에는 **Cloud Build**를 사용하려 했으나, 권한 문제가 발생했습니다. Retry를 2회 시도했으나 결국 **Docker 직접 빌드**로 전환했습니다. IAM 권한을 추가하고, 기본 Compute Engine Service Account를 사용하도록 변경했습니다.\n\n**의존성 및 성능 최적화**\n\n배포 중 누락된 의존성을 발견했습니다:\n- **google-generativeai**: poetry.lock 업데이트\n- **aiohttp**: 누락 의존성 추가\n- **google-cloud-documentai**: 누락 의존성 추가\n\n**Redis 제거 및 Cold Start 최적화**\n\n현재 사용하지 않는 **Redis cache manager를 비활성화**하고, 대신 **in-memory cache manager**를 활성화했습니다. 또한 **init_db() 스킵**으로 **Cold Start 시간을 단축**했습니다.\n\nfeed_curation_service의 함수 파라미터 순서 오류도 수정했습니다.\n\n## 📊 개발 현황\n\n- **배포**: Docker 직접 빌드, Cloud SQL 연결\n- **의존성**: aiohttp, documentai 추가\n- **성능**: Redis → 인메모리 캐시, init_db 스킵\n- **Poetry**: 최신 명령어, lock 파일 관리",
      "description": "프로덕션 Dockerfile 및 Cloud Run 배포 최적화",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0023.md"
    },
    {
      "slug": "fallingo-devlog-0024",
      "title": "fallingo 개발일지 - 2025-10-22 ~ 2025-10-24 (20개 커밋)",
      "date": "2025-10-24T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-22 ~ 2025-10-24 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### Cloud Run 배포 안정화 (6개 커밋)\n- **Use DATABASE_URL from Secret Manager with password**: DB URL 시크릿 사용\n- **Add PORT environment variable to Dockerfile**: PORT 환경변수 추가\n- **claude dev**: 개발 업데이트\n- **Improve health check endpoint with real status checks**: 헬스체크 개선\n- **Allow all hosts for Cloud Run deployment**: 모든 호스트 허용\n- **API prefix를 /api/v1에서 /api로 변경**: API prefix 단순화\n- **API_V1_PREFIX를 API_PREFIX로 변수명 변경**: 변수명 수정\n\n### 테스트 파일 정리 (6개 커밋)\n- **테스트 파일 및 문서 제거**: 테스트 파일 삭제\n- **Revert \"chore: 테스트 파일 및 문서 제거\"**: Revert 1\n- **테스트 파일만 제거**: 다시 삭제\n- **API 테스트 스크립트 제거**: API 스크립트 삭제\n- **추가 테스트 스크립트 제거**: 추가 스크립트 삭제\n- **Revert \"chore: 테스트 파일만 제거\"**: Revert 2\n- **개발/테스트 스크립트 제거**: 최종 삭제\n\n### Spec-kit 도입 및 리팩토링 (7개 커밋)\n- **Add spec-kit for code quality management**: Spec-kit 도입\n- **Convert follow_service to Facade pattern (999 → 208 lines)**: 대규모 리팩토링\n- **Generate all 17 domain specifications**: 17개 도메인 스펙 생성\n- **Fill domain specs with detailed information**: 스펙 상세 작성\n- **Add complete spec generator for restaurants domain (NO TODOs)**: restaurants 스펙 완성\n\n### 프론트엔드 개발 (1개 커밋)\n- **Stage 2 완료 - 피드 생성 기능 (카메라 + 작성 화면)** (10/24): 피드 생성 구현\n\n## 💡 작업 하이라이트\n\n**API prefix 단순화 및 배포 안정화**\n\n10월 22일, Cloud Run 배포를 안정화하기 위한 작업을 진행했습니다. **DATABASE_URL을 Secret Manager**에서 읽도록 개선하고, PORT 환경변수를 Dockerfile에 추가했습니다. 헬스체크 엔드포인트에 **실제 상태 확인 로직**을 추가했습니다.\n\n**API prefix를 /api/v1에서 /api로 단순화**하여 API 경로를 깔끔하게 정리했습니다.\n\n**Spec-kit 도입: 코드 품질 관리 시스템**\n\n**Spec-kit**을 도입하여 코드 품질 관리를 체계화했습니다. 가장 인상적인 성과는 **follow_service를 Facade 패턴으로 리팩토링하여 999줄 → 208줄로 79% 축소**한 것입니다.\n\n**17개 도메인 스펙**을 생성하고 상세 정보를 작성했습니다. restaurants 도메인에 대해서는 **TODO 없는 완전한 스펙**을 작성했습니다.\n\n**프론트엔드 Stage 2 완료**\n\n10월 24일, **피드 생성 기능 (카메라 + 작성 화면)**을 구현하며 프론트엔드 Stage 2를 완료했습니다.\n\n## 📊 개발 현황\n\n- **배포**: Secret Manager, PORT, 헬스체크, API prefix 단순화\n- **코드 품질**: Spec-kit 도입, Facade 패턴 (999 → 208줄)\n- **스펙**: 17개 도메인 스펙 생성, restaurants 완성\n- **프론트엔드**: Stage 2 완료 (피드 생성)",
      "description": "배포 안정화 및 Spec-kit 코드 품질 관리 도입",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0024.md"
    },
    {
      "slug": "fallingo-devlog-0025",
      "title": "fallingo 개발일지 - 2025-10-25 (20개 커밋)",
      "date": "2025-10-25T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-25 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### Cloud Run 최적화 (8개 커밋)\n- **Optimize startup for Cloud Run deployment**: 시작 최적화\n- **Change default PORT to 8080 for Cloud Run compatibility**: PORT 8080\n- **Optimize Cloud Run startup and configuration**: 설정 최적화\n- **Remove PORT from env vars (Cloud Run reserved variable)**: PORT 제거\n- **Disable background tasks and add no-cpu-throttling for faster startup**: 백그라운드 태스크 비활성화\n- **Add database engine error handling with SQLite fallback**: SQLite fallback\n- **Add print statements to track startup process**: 디버깅 로그 추가\n\n### 환경변수 및 시크릿 관리 (6개 커밋)\n- **Standardize DATABASE_URL environment variable**: DATABASE_URL 표준화\n- **Use GitHub Secret for JWT_SECRET_KEY instead of GCP Secret Manager**: GitHub Secret 사용\n- **Restore jwt-secret-key from GCP Secret Manager**: GCP Secret 복원\n- **Change GCP secret name from DATABASE_URL_PROD to DATABASE_URL**: 시크릿명 변경\n- **Complete DATABASE_URL_PROD to DATABASE_URL migration**: 마이그레이션 완료\n- **Use hardcoded SECRET_KEY env var instead of GCP secret**: 하드코드 env\n- **Use GCP Secret Manager for JWT_SECRET_KEY**: GCP Secret 사용\n\n### API 구조 개선 (6개 커밋)\n- **Correct user router import path**: import 경로 수정\n- **Fix incorrect API path comments**: 주석 수정\n- **Remove v1 directory structure from API**: v1 디렉토리 제거\n- **Add service __init__.py exports and fix imports**: __init__.py 수정\n- **Add prefix to all sub-routers to prevent empty path errors**: prefix 추가\n- **로컬 테스트 통과 - 169개 API 엔드포인트 정상 로드**: 169개 엔드포인트 성공\n\n## 💡 작업 하이라이트\n\n**Cloud Run 배포 최적화의 긴 여정**\n\n10월 25일 하루 동안 **20개의 커밋**으로 Cloud Run 배포를 최적화했습니다. 핵심은 **시작 시간 단축**과 **환경변수 관리**였습니다.\n\n**PORT 설정**을 8080으로 변경하고, Cloud Run에서 예약된 변수이므로 env vars에서 제거했습니다. **백그라운드 태스크를 비활성화**하고 **no-cpu-throttling**을 추가하여 시작 시간을 단축했습니다.\n\n**환경변수 혼란 해결**\n\n**DATABASE_URL** 관리가 가장 복잡했습니다:\n- DATABASE_URL_PROD → DATABASE_URL로 표준화\n- GCP Secret Manager 사용 결정\n\n**JWT_SECRET_KEY**도 시행착오를 겪었습니다:\n- GitHub Secret 사용 시도\n- GCP Secret Manager 복원\n- 하드코드 env 시도\n- 최종적으로 GCP Secret Manager 사용\n\n**API 구조 개선**\n\n**v1 디렉토리 구조를 완전히 제거**하며 API 경로를 단순화했습니다. service __init__.py exports를 추가하고, 모든 sub-router에 prefix를 추가하여 **169개 API 엔드포인트를 정상적으로 로드**했습니다.\n\n## 📊 개발 현황\n\n- **Cloud Run**: 시작 최적화, SQLite fallback\n- **환경변수**: DATABASE_URL, JWT_SECRET_KEY GCP Secret Manager 통합\n- **API**: v1 구조 제거, 169개 엔드포인트 정상 로드\n- **성능**: 백그라운드 태스크 비활성화, no-cpu-throttling",
      "description": "Cloud Run 배포 최적화 및 169개 API 엔드포인트 정상화",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0025.md"
    },
    {
      "slug": "fallingo-devlog-0026",
      "title": "fallingo 개발일지 - 2025-10-25 ~ 2025-10-27 (20개 커밋)",
      "date": "2025-10-27T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-25 ~ 2025-10-27 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 배포 및 경로 수정 (3개 커밋)\n- **GitHub Actions 테스트 워크플로우를 Poetry로 변경**: Poetry 전환\n- **Load Balancer와 경로 충돌 해결 - /api prefix 제거**: 경로 충돌 해결\n- **API 문서 경로를 /api prefix 안으로 이동**: 문서 경로 수정\n\n### 테스트 데이터 시딩 (4개 커밋)\n- **테스트 데이터 시딩 스크립트 추가**: 시딩 스크립트 작성\n- **Add Cloud Shell one-click seeding guide**: Cloud Shell 가이드\n- **Update seed_test_data.py to match production DB schema**: DB 스키마 매칭\n- **Add Windows env vars and fix like_count field name**: Windows 지원\n\n### API 게스트 접근 및 버그 수정 (7개 커밋)\n- **Allow guest access to feed list/detail APIs**: 게스트 접근 허용\n- **Add missing VisionService and DocumentAIService dependencies**: 의존성 추가\n- **Add VisionService and DocumentAIService to FeedService facade**: Facade 수정\n- **Map AI_SERVICES_API_KEY to GOOGLE_GEMINI_API_KEY**: API 키 매핑\n- **Replace GOOGLE_GEMINI_API_KEY with AI_SERVICES_API_KEY**: API 키 교체\n- **Add detailed error messages to feed API for troubleshooting**: 에러 메시지 추가\n- **Add 'pending' to verification_status enum**: enum 수정\n\n### Flutter 프론트엔드 배포 (6개 커밋)\n- **Deploy real Flutter UI to Cloud Run** (10/27): Flutter UI 배포\n- **Add README** (10/27): README 추가\n- **Use GitHub Actions Docker build instead of Cloud Build**: Docker 빌드 전환\n- **Remove Docker Buildx and simplify GCR auth**: GCR 인증 단순화\n- **Use Artifact Registry instead of GCR**: Artifact Registry 전환\n- **Update API URL to production domain (fallingo.app/api)**: 프로덕션 URL 설정\n\n## 💡 작업 하이라이트\n\n**테스트 데이터 시딩 시스템**\n\n프로덕션 DB에 테스트 데이터를 투입하기 위한 **시딩 스크립트**를 작성했습니다. **Cloud Shell one-click seeding 가이드**를 추가하여 간편하게 테스트 데이터를 생성할 수 있도록 했습니다. Windows 환경변수 지원과 like_count 필드명 수정 등 세부 사항을 개선했습니다.\n\n**API 게스트 접근 개선**\n\n**피드 목록/상세 API를 게스트 접근 허용**으로 변경하여 로그인 없이도 피드를 볼 수 있게 했습니다. 이는 사용자 유입에 중요한 기능입니다.\n\nFeedService Facade에 **VisionService와 DocumentAIService 의존성**을 추가하여 AI 기능을 통합했습니다. API 키 관리도 **GOOGLE_GEMINI_API_KEY → AI_SERVICES_API_KEY**로 표준화했습니다.\n\n**Flutter 프론트엔드 프로덕션 배포**\n\n10월 27일, **실제 Flutter UI를 Cloud Run에 배포**했습니다. GitHub Actions를 통한 Docker 빌드로 전환하고, **GCR에서 Artifact Registry**로 이동했습니다.\n\n**API URL을 프로덕션 도메인(fallingo.app/api)**으로 설정하여 백엔드와 프론트엔드를 완전히 연동했습니다.\n\n## 📊 개발 현황\n\n- **테스트**: 시딩 스크립트, Cloud Shell 가이드\n- **API**: 게스트 접근, AI 서비스 통합, API 키 표준화\n- **프론트엔드**: Flutter UI Cloud Run 배포, Artifact Registry\n- **인프라**: fallingo.app/api 프로덕션 URL",
      "description": "테스트 데이터 시딩 및 Flutter 프론트엔드 배포",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0026.md"
    },
    {
      "slug": "fallingo-devlog-0027",
      "title": "fallingo 개발일지 - 2025-10-27 ~ 2025-10-28 (20개 커밋)",
      "date": "2025-10-28T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-27 ~ 2025-10-28 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 프론트엔드 UI 개선 (4개 커밋)\n- **Add assets/images/ to pubspec.yaml**: 이미지 에셋 추가\n- **Always use production API URL and UI improvements**: 프로덕션 URL 고정\n- **Update favicon and branding to fallingo logo**: fallingo 로고 적용\n- **Remove CORS-blocked pravatar.cc avatar images**: CORS 차단 이미지 제거\n\n### API 경로 수정 (8개 커밋)\n- **Remove duplicate /api in API URLs**: 중복 /api 제거\n- **Use correct API paths without /v1 prefix**: /v1 제거\n- **Remove all /api/ prefixes from service endpoints**: /api prefix 전체 제거\n- **Update frontend deployment to use API_BASE_URL env var**: 환경변수 사용\n- **Add /api to API_BASE_URL in deployment**: /api 추가\n- **Make API_BASE_URL environment variable required**: 필수 환경변수 설정\n- **Support both /feeds and /feeds/ routes**: 양쪽 경로 지원\n- **Remove empty path route and redirect_slashes=False**: 빈 경로 제거\n\n### CORS 및 리다이렉트 문제 (8개 커밋)\n- **Add production domains to CORS origins**: CORS 도메인 추가\n- **Disable redirect_slashes to prevent CORS preflight errors**: redirect_slashes 비활성화\n- **Redeploy frontend with fixed API_BASE_URL**: 프론트엔드 재배포\n- **Add trailing slash automatically in Dio interceptor**: Dio 인터셉터 추가\n- **Set redirect_slashes=False to prevent HTTP redirect**: redirect 방지\n- **Use redirect_slashes=True with trailing slash auto-append**: redirect 활성화\n- **Update Feed.fromJson() to match backend nested schema structure**: Feed 파싱 수정\n- **Fix Feed parsing to match actual API response structure**: API 응답 구조 매칭\n\n## 💡 작업 하이라이트\n\n**API 경로 혼란 해결**\n\n프론트엔드-백엔드 통합 과정에서 **API 경로 문제**가 복잡하게 얽혔습니다:\n- /api 중복 제거\n- /v1 prefix 제거\n- /api prefix를 환경변수로 관리\n- 양쪽 모두 제거 → 다시 /api 추가\n- API_BASE_URL을 필수 환경변수로 설정\n\n**8개의 연속 커밋**으로 API 경로를 안정화했습니다.\n\n**CORS 및 trailing slash 문제**\n\n**CORS preflight 에러**가 발생하며 여러 해결책을 시도했습니다:\n1. 프로덕션 도메인을 CORS origins에 추가\n2. redirect_slashes=False로 HTTP redirect 방지\n3. Dio 인터셉터로 trailing slash 자동 추가\n4. redirect_slashes=False 유지\n5. redirect_slashes=True로 다시 전환\n\n**/feeds와 /feeds/ 양쪽 경로를 지원**하도록 설정했습니다.\n\n**Feed 파싱 수정**\n\n백엔드 API 응답 구조가 **nested schema**인 것을 발견하고, **Feed.fromJson()을 수정**하여 실제 API 응답 구조와 매칭했습니다.\n\n## 📊 개발 현황\n\n- **API 경로**: API_BASE_URL 환경변수 관리, /v1 제거\n- **CORS**: 프로덕션 도메인 추가, redirect_slashes 설정\n- **파싱**: Feed 모델을 백엔드 응답 구조와 매칭\n- **UI**: fallingo 로고, CORS 차단 이미지 제거",
      "description": "CORS 및 API 경로 문제 집중 해결",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0027.md"
    },
    {
      "slug": "fallingo-devlog-0028",
      "title": "fallingo 개발일지 - 2025-10-28 ~ 2025-10-29 (20개 커밋)",
      "date": "2025-10-29T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-28 ~ 2025-10-29 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### Trailing slash 문제 (8개 커밋)\n- **Add null-safe parsing for createdAt field**: null-safe 파싱\n- **Add trailing slash to feeds API endpoint**: trailing slash 추가\n- **Remove trailing slash from all 1depth API endpoints**: 전체 제거\n- **Remove automatic trailing slash appending in Dio interceptor**: Dio 제거\n- **Remove trailing slash from feeds API endpoint**: feeds 제거\n- **Revert empty string routes to slash routes**: slash 복원\n- **Remove trailing slashes from all 1-depth API endpoints**: 1-depth 제거\n\n### 관리자 및 데이터 모델 수정 (6개 커밋)\n- **Add admin API endpoint for test data seeding**: 관리자 API\n- **Exclude admin seed endpoint from CSRF protection**: CSRF 제외\n- **Make restaurant address optional and fix verification score field**: 필드 수정\n- **Simplify Advertisement model to match API response**: Advertisement 단순화\n- **Remove Advertisement.content references from feed_screen**: content 제거\n- **Add missing fields to feed API response (user_interactions, location, profile_image_url)**: 필드 추가\n\n### 신규 기능 구현 (6개 커밋)\n- **dev**: 일반 개발\n- **Add realistic seed data script with Google Places API**: Google Places 시딩\n- **Add SEO optimization (robots.txt, sitemap.xml, meta tags)**: SEO 최적화\n- **Add ad system for feed (web + mobile ready)**: 광고 시스템\n- **피드 이미지 1:1 크롭 및 테스트 데이터 개선**: 이미지 크롭\n- **Update Flutter dependencies**: Flutter 업데이트\n- **피드 이미지 1:1 크롭 강화 및 스플래시 피드 프리로드**: 크롭 강화\n\n## 💡 작업 하이라이트\n\n**Trailing slash 지옥 탈출**\n\n10월 28일, **trailing slash 문제**로 8개의 커밋을 작성했습니다:\n1. feeds API에 trailing slash 추가\n2. 모든 1-depth 엔드포인트에서 제거\n3. Dio 인터셉터의 자동 추가 제거\n4. feeds에서 다시 제거\n5. empty string routes를 slash routes로 복원\n6. 다시 모든 1-depth에서 제거\n\n결론: **trailing slash를 완전히 제거**하고 표준화했습니다.\n\n**광고 시스템 구현**\n\n10월 29일, **피드 광고 시스템**을 구현했습니다. 웹과 모바일 모두 지원하는 광고 시스템으로, Advertisement 모델을 API 응답 구조에 맞게 단순화했습니다.\n\n**SEO 최적화**\n\n**robots.txt, sitemap.xml, meta tags**를 추가하여 SEO를 최적화했습니다. 검색 엔진 최적화는 서비스 성장에 중요한 요소입니다.\n\n**Google Places API 시딩**\n\n**Google Places API를 활용한 현실적인 시드 데이터 스크립트**를 작성했습니다. 관리자 API 엔드포인트를 추가하고 CSRF 보호에서 제외하여 편리하게 테스트 데이터를 생성할 수 있게 했습니다.\n\n**피드 이미지 1:1 크롭**\n\n피드 이미지를 1:1 비율로 크롭하여 일관된 UI를 제공하도록 개선했습니다. 스플래시 화면에서 **피드 프리로드**를 추가하여 UX를 향상시켰습니다.\n\n## 📊 개발 현황\n\n- **API**: trailing slash 표준화, 관리자 엔드포인트\n- **광고**: 웹+모바일 광고 시스템 구현\n- **SEO**: robots.txt, sitemap.xml, meta tags\n- **데이터**: Google Places API 시딩\n- **UI**: 1:1 이미지 크롭, 피드 프리로드",
      "description": "Trailing slash 문제 해결 및 광고 시스템 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0028.md"
    },
    {
      "slug": "fallingo-devlog-0029",
      "title": "fallingo 개발일지 - 2025-10-29 ~ 2025-11-06 (20개 커밋)",
      "date": "2025-11-06T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-10-29 ~ 2025-11-06 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 버그 수정 및 정리 (4개 커밋)\n- **seed_realistic_data 버그 수정 (미사용 파일, 보관용)**: 시딩 수정\n- **Remove unnecessary ad files**: 광고 파일 제거\n- **Update feed card badge layout**: 배지 레이아웃 수정\n- **DEL** (10/31): 파일 삭제\n\n### 성능 최적화 (3개 커밋)\n- **Add API performance optimization (DB indexes + in-memory caching)** (10/30): 성능 최적화\n- **Add guide for applying performance indexes to GCP Cloud SQL**: Cloud SQL 인덱스 가이드\n- **Update performance index migration parent and add apply script**: 마이그레이션 스크립트\n\n### 인증 및 상태 관리 (2개 커밋)\n- **Add email whitelist for authentication** (11/1): 이메일 화이트리스트\n- **Implement global FeedProvider for state management** (11/4): 전역 상태 관리\n\n### Google for Startups (4개 커밋)\n- **Add HTML landing page for Google for Startups review** (11/4): 랜딩 페이지\n- **Clean up unused imports and add CORS localhost regex**: CORS 개선\n- **Update Claude Code settings and simplify web index.html**: 웹 페이지 단순화\n- **내용 수정** (11/5): 내용 수정\n- **구글 시너지 섹션** (11/5): 시너지 섹션 추가\n\n### 핵심 기능 구현 (7개 커밋)\n- **Implement point multiplier-based Daejanggeum selection scoring system** (11/5): 대장금 선정 시스템\n- **Enable Google Maps API integration for feed card map view** (11/6): Google Maps 통합\n- **Merge pull request #1**: PR 병합\n- **Remove gallery option and connect camera/OCR screens to feed creation** (11/6): 카메라/OCR 연결\n- **Connect camera/feed creation flow and OCR verification** (11/6): OCR 검증 연결\n- **Add My Foodmap screen (Tier 6+ premium feature)** (11/6): 프리미엄 푸드맵\n\n## 💡 작업 하이라이트\n\n**성능 최적화**\n\n10월 30일, **DB 인덱스와 인메모리 캐싱**을 추가하여 API 성능을 최적화했습니다. GCP Cloud SQL에 성능 인덱스를 적용하는 가이드와 마이그레이션 스크립트를 작성했습니다.\n\n**Google for Startups 랜딩 페이지**\n\n11월 4일~5일, **Google for Startups 심사를 위한 HTML 랜딩 페이지**를 제작했습니다. 구글 시너지 섹션을 추가하고 내용을 수정하며 완성도를 높였습니다. 이는 이전에 작성한 Google for Startups 승인 스토리의 후속 작업입니다.\n\n**대장금 선정 시스템**\n\n11월 5일, **포인트 배수 기반 대장금 선정 점수 시스템**을 구현했습니다. 이는 fallingo의 게이미피케이션 핵심 메커니즘입니다.\n\n**카메라/OCR 연결 및 프리미엄 기능**\n\n11월 6일, 핵심 기능들을 집중적으로 구현했습니다:\n- **Google Maps API 통합**: 피드 카드 지도 뷰\n- **갤러리 옵션 제거**: 카메라/OCR 화면만 사용\n- **카메라/피드 생성 플로우 연결**: OCR 검증 통합\n- **My Foodmap 화면**: **Tier 6+ 프리미엄 기능**\n\n## 📊 개발 현황\n\n- **성능**: DB 인덱스 + 인메모리 캐싱\n- **인증**: 이메일 화이트리스트, 전역 FeedProvider\n- **Google**: Startups 랜딩 페이지, Maps API 통합\n- **게이미피케이션**: 대장금 선정 시스템\n- **프리미엄**: Tier 6+ My Foodmap 화면",
      "description": "성능 최적화, Google for Startups 랜딩 페이지, 프리미엄 기능 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0029.md"
    },
    {
      "slug": "fallingo-devlog-0030",
      "title": "fallingo 개발일지 - 2025-11-06 ~ 2025-11-07 (20개 커밋)",
      "date": "2025-11-07T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-11-06 ~ 2025-11-07 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 화면 API 연동 (5개 커밋)\n- **Enable Google Maps API integration for feed card map view** (11/6): Maps 통합\n- **Integrate SearchScreen with real API (remove mock data)** (11/6): 검색 화면\n- **Implement CommentScreen with full functionality** (11/6): 댓글 화면\n- **Integrate ProfileScreen with real API** (11/6): 프로필 화면\n- **Integrate AIRecommendScreen with real API** (11/6): AI 추천 화면\n\n### FCM 푸시 알림 (6개 커밋)\n- **Add Document AI OCR integration for receipt scanning** (11/7): OCR 통합\n- **Add pre-commit hooks for code quality** (11/7): pre-commit 훅\n- **Add FCM push notification service** (11/7): FCM 서비스\n- **Add VAPID_PUBLIC_KEY environment variable for FCM web** (11/7): VAPID 키\n- **Firebase FCM 연동 완료** (11/7): FCM 완료\n- **Merge branch 'feature/fcm-integration'** (11/7): FCM 병합\n\n### PR 및 코드 품질 (9개 커밋)\n- **Add comprehensive PR description for frontend development** (11/7): PR 문서화\n- **Merge pull request #2**: PR 병합\n- **mail** (11/7): 메일 업데이트\n- **dev config** (11/7): 개발 설정\n- **린트 에러 수정 (39개 → 0개)** (11/7): 린트 수정\n- **privacy_policy_widget_example.dart → .dart.example** (11/7): 파일명 수정\n- **EOF 개행 추가** (11/7): EOF 개행\n- **코드 품질 개선 (Unused 정리)** (11/7): Unused 정리\n- **Deprecated API 업데이트 (5개)** (11/7): Deprecated 수정\n\n## 💡 작업 하이라이트\n\n**전체 화면 API 연동 완료**\n\n11월 6일, 모든 Mock 데이터를 제거하고 **실제 API와 연동**했습니다:\n- **SearchScreen**: 실시간 검색 API\n- **CommentScreen**: 댓글 CRUD 전체 기능\n- **ProfileScreen**: 사용자 프로필 API\n- **AIRecommendScreen**: AI 추천 API\n\n이제 fallingo 프론트엔드는 **100% 실제 데이터**로 작동합니다.\n\n**FCM 푸시 알림 시스템**\n\n11월 7일, **Firebase Cloud Messaging (FCM) 푸시 알림**을 구현했습니다:\n- FCM 서비스 추가\n- VAPID_PUBLIC_KEY 환경변수 (웹 지원)\n- feature/fcm-integration 브랜치에서 작업 후 병합\n\n**Document AI OCR** 영수증 스캔 통합도 완료하여 멀티모달 검증 시스템을 구축했습니다.\n\n**코드 품질 대폭 개선**\n\n11월 7일, **5개의 리팩토링 커밋**으로 코드 품질을 개선했습니다:\n1. **린트 에러 39개 → 0개**: 완전 해결\n2. privacy_policy_widget 파일명 수정\n3. EOF 개행 추가\n4. Unused 코드 정리\n5. **Deprecated API 5개 업데이트**\n\n**pre-commit hooks**를 추가하여 앞으로 코드 품질이 자동으로 관리됩니다.\n\n## 📊 개발 현황\n\n- **화면**: Search, Comment, Profile, AI Recommend 100% API 연동\n- **푸시 알림**: FCM 완전 구현 (모바일 + 웹)\n- **OCR**: Document AI 영수증 스캔\n- **코드 품질**: 린트 0개, Deprecated 0개, pre-commit 훅\n- **PR**: #2 병합 완료",
      "description": "전체 화면 API 연동 및 FCM 푸시 알림 구현",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0030.md"
    },
    {
      "slug": "fallingo-devlog-0031",
      "title": "fallingo 개발일지 - 2025-11-07 ~ 2025-11-09 (20개 커밋)",
      "date": "2025-11-09T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-11-07 ~ 2025-11-09 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### UI 및 광고 (3개 커밋)\n- **라우팅 설정 및 About 화면 추가** (11/7): About 화면\n- **AdMob 설정 및 UI 텍스트 개선** (11/8): AdMob 설정\n- **의존성 버전 업데이트 (pubspec.lock)** (11/8): 의존성 업데이트\n\n### Redis 캐싱 시스템 (5개 커밋)\n- **GCP Memorystore Redis 캐싱 시스템 구축** (11/8): Redis 구축\n- **CLAUDE.md 업데이트 - PostgreSQL 17 및 Redis 활성화** (11/8): 문서 업데이트\n- **주요 서비스에 Redis 캐싱 적용** (11/8): 캐싱 적용\n- **Redis 캐싱 시스템 적용 문서화** (11/9): 문서화\n- **Redis 캐싱 시스템 로컬 환경 테스트 완료** (11/9): 테스트 완료\n\n### BackgroundTasks 성능 개선 (2개 커밋)\n- **BackgroundTasks 도입으로 API 응답 속도 76% 개선** (11/9): 76% 개선\n- **BackgroundTasks를 팔로우 및 피드 생성 API에도 확대 적용** (11/9): 확대 적용\n\n### 배포 및 버그 수정 (7개 커밋)\n- **Redis 패키지 의존성 추가로 배포 실패 수정** (11/8): 배포 수정\n- **Merge pull request #3**: PR 병합\n- **Cloud Run startup timeout 해결 (캐시 연결 타임아웃 추가)** (11/9): 타임아웃 수정\n- **pre-commit hook deprecated stage 수정 및 about.html API 문서 비활성화** (11/9): 설정 수정\n- **BackgroundTasks Depends() 제거 (FastAPI 자동 주입)** (11/9): Depends 제거\n- **BackgroundTasks 파라미터 순서 수정 (SyntaxError 해결)** (11/9): 파라미터 수정\n\n### 보안 강화 (3개 커밋)\n- **Remove exposed GoogleService-Info.plist** (11/9): API 키 제거\n- **Add Firebase config files to .gitignore** (11/9): gitignore 추가\n- **Firebase API 키 보안 강화** (11/9): 보안 강화\n- **Merge branch 'security/remove-api-keys'** (11/9): 보안 브랜치 병합\n\n## 💡 작업 하이라이트\n\n**Redis 캐싱 시스템 구축**\n\n11월 8일, **GCP Memorystore Redis 캐싱 시스템**을 구축했습니다. 이전에 제거했던 Redis를 다시 도입한 것은 프로덕션 환경에서 성능이 필요하다고 판단했기 때문입니다.\n\n주요 서비스에 캐싱을 적용하고, 로컬 환경 테스트를 완료했습니다. PostgreSQL 17과 Redis를 활성화하며 인프라를 강화했습니다.\n\n**BackgroundTasks로 76% 성능 개선**\n\n11월 9일, **FastAPI BackgroundTasks**를 도입하여 **API 응답 속도를 76% 개선**했습니다. 이는 매우 인상적인 성과입니다.\n\n초기에는 특정 API에만 적용했으나, 효과가 검증되어 **팔로우 및 피드 생성 API**로 확대 적용했습니다.\n\n구현 과정에서 Depends() 제거, 파라미터 순서 수정 등 FastAPI 특성을 이해하며 안정화했습니다.\n\n**보안 강화: Firebase API 키**\n\n11월 9일, **노출된 GoogleService-Info.plist를 제거**하고, Firebase 설정 파일을 .gitignore에 추가하며 **API 키 보안을 강화**했습니다. security/remove-api-keys 브랜치에서 작업 후 병합했습니다.\n\n## 📊 개발 현황\n\n- **캐싱**: GCP Memorystore Redis 구축 및 적용\n- **성능**: BackgroundTasks로 76% 개선\n- **보안**: Firebase API 키 제거, gitignore 추가\n- **배포**: Cloud Run 타임아웃 해결\n- **광고**: AdMob 설정 완료",
      "description": "Redis 캐싱 및 BackgroundTasks로 76% 성능 개선",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0031.md"
    },
    {
      "slug": "fallingo-devlog-0032",
      "title": "fallingo 개발일지 - 2025-11-09 (20개 커밋)",
      "date": "2025-11-09T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-11-09 (20개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### 낙관적 업데이트 (3개 커밋)\n- **낙관적 업데이트 피드 등록 시스템 구현**: 낙관적 업데이트 구현\n- **낙관적 업데이트 문서 포맷팅 개선**: 문서 개선\n- **Merge pull request #4**: PR 병합\n\n### 백엔드 코드 품질 개선 (9개 커밋)\n- **백엔드 코드 품질 개선 - 심각한 에러 4개 수정**: 에러 수정\n- **Merge branch 'fix/code-quality-improvements'**: 품질 개선 병합\n- **follow_action_service.py를 follow_service.py로 이름 변경**: 파일명 변경\n- **Merge branch 'refactor/follow-service-rename'**: 리네임 병합\n- **소스코드 품질 분석 리포트 추가**: 분석 리포트\n- **Phase 1 코드 품질 개선 - 높은 우선순위 이슈 해결**: Phase 1\n- **Merge branch 'refactor/code-quality-phase1'**: Phase 1 병합\n- **Phase 2 코드 품질 개선 - Black 포맷팅 + 인코딩 수정**: Phase 2\n- **Merge branch 'refactor/code-quality-phase2'**: Phase 2 병합\n\n### 프론트엔드 코드 품질 (5개 커밋)\n- **Frontend 코드 품질 개선 - Warning 해결**: Warning 수정\n- **Merge branch 'refactor/frontend-code-quality'**: 프론트 품질 병합\n- **search_screen.dart 빌드 에러 수정**: 빌드 에러\n- **Merge branch 'fix/search-screen-build-error'**: 빌드 수정 병합\n\n### 문서 및 자동화 (3개 커밋)\n- **no-commit-to-branch 훅 제거**: 훅 제거\n- **Frontend 남은 작업 명세서 작성**: 작업 명세\n- **레스토랑 상세 페이지 제거 및 Markdownlint 오류 수정 완료**: Markdown 수정\n- **주간 블로그 자동 생성 시스템 추가**: 블로그 자동화\n\n## 💡 작업 하이라이트\n\n**낙관적 업데이트 시스템**\n\n**낙관적 업데이트 피드 등록 시스템**을 구현했습니다. 사용자가 피드를 등록하면 즉시 UI에 반영되고, 백그라운드에서 실제 API 요청을 처리합니다. 이는 UX를 크게 향상시키는 중요한 기능입니다.\n\n**대규모 코드 품질 개선**\n\n11월 9일 하루 동안 **체계적인 코드 품질 개선**을 진행했습니다:\n\n**백엔드 Phase 1~2**:\n- 심각한 에러 4개 수정\n- follow_action_service.py → follow_service.py 리네임\n- 소스코드 품질 분석 리포트 추가\n- Phase 1: 높은 우선순위 이슈 해결\n- Phase 2: **Black 포맷팅 + 인코딩 수정**\n\n**프론트엔드**:\n- Warning 전체 해결\n- search_screen.dart 빌드 에러 수정\n\n모든 작업이 **별도 브랜치에서 진행 후 병합**되어 안정적인 개발 프로세스를 보여줍니다.\n\n**주간 블로그 자동 생성 시스템**\n\n**주간 블로그 자동 생성 시스템**을 추가했습니다. 이는 현재 작업 중인 시스템(20개 커밋마다 개발일지 작성)과 관련이 있어 보입니다.\n\n## 📊 개발 현황\n\n- **UX**: 낙관적 업데이트 시스템 구현\n- **백엔드 품질**: 에러 4개 수정, Phase 1~2 완료\n- **프론트엔드 품질**: Warning 0개, 빌드 에러 수정\n- **자동화**: 주간 블로그 자동 생성\n- **문서**: 품질 분석 리포트, 작업 명세서",
      "description": "낙관적 업데이트 구현 및 대규모 코드 품질 개선",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0032.md"
    },
    {
      "slug": "fallingo-devlog-0033",
      "title": "fallingo 개발일지 - 2025-11-10 (9개 커밋)",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "dev-log",
      "content": "# fallingo 개발일지 - 2025-11-10 (9개 커밋)\n\n## 📝 이번 기간 작업 내용\n\n### GitHub Actions 수정 (3개 커밋)\n- **GitHub Actions에 태그 push 권한 추가**: 태그 권한 추가\n- **GitHub API 업로드 에러 처리 개선**: 에러 처리 개선\n- **마지막 블로그 이후 커밋만 수집하도록 수정**: 중복 방지\n\n### 블로그 시스템 재구성 (6개 커밋)\n- **블로그 제목 및 파일명을 커밋 기반으로 변경**: 커밋 기반 전환\n- **블로그 자동화 시스템을 커밋 기반으로 완전 전환**: 완전 전환\n- **블로그 제목에 커밋 범위(해시) 추가**: 해시 추가\n- **블로그 작성 스타일에 존댓말 사용 명시**: 존댓말 명시\n- **블로그 프롬프트를 현실적으로 개선**: 프롬프트 개선\n- **블로그를 개발 일지(Dev Log) 형식으로 변경**: Dev Log 형식\n\n## 💡 작업 하이라이트\n\n**블로그 자동화 시스템 완전 재구성**\n\n11월 10일, **블로그 자동화 시스템을 주간 기반에서 커밋 기반으로 완전히 전환**했습니다. 이는 우리가 지금 사용하고 있는 시스템입니다.\n\n**핵심 변경 사항**:\n1. **커밋 기반 수집**: 마지막 블로그 이후 커밋만 수집 (중복 방지)\n2. **제목 및 파일명**: 커밋 기반으로 변경\n3. **커밋 해시 범위**: 블로그 제목에 추가\n4. **존댓말 사용**: 블로그 작성 스타일 명시\n5. **프롬프트 개선**: 더 현실적인 내용 생성\n6. **Dev Log 형식**: 개발 일지 형식으로 표준화\n\n**GitHub Actions 권한 및 에러 처리**\n\n태그 push 권한을 추가하고, GitHub API 업로드 에러 처리를 개선했습니다. 이는 자동화 시스템의 안정성을 높입니다.\n\n**현재 작업 중인 시스템의 기반**\n\n이 9개의 커밋이 바로 **지금 우리가 사용하는 블로그 자동 생성 시스템의 기반**입니다. 20개 커밋마다 개발일지를 작성하고, 존댓말을 사용하며, 커밋 해시를 포함하는 시스템이 여기서 완성되었습니다.\n\n## 📊 개발 현황\n\n- **블로그 자동화**: 주간 기반 → 커밋 기반 완전 전환\n- **스타일**: 존댓말 사용, Dev Log 형식\n- **안정성**: GitHub Actions 권한, 에러 처리 개선\n- **중복 방지**: 마지막 블로그 이후 커밋만 수집",
      "description": "블로그 자동화 시스템 완전 재구성",
      "tags": [
        "fallingo",
        "개발일지"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0033.md"
    },
    {
      "slug": "fallingo-devlog-0034",
      "title": "fallingo 개발일지 - eca8e83..f985f12 (35개 커밋)",
      "date": "2025-11-16T00:00:00.000Z",
      "category": "dev-log",
      "content": "안녕하세요! Fallingo 개발자 Su입니다. 🍂 어느덧 2025년 11월 중순이네요. 2025년 12월 베타 런칭 목표를 향해 정말 눈코 뜰 새 없이 달리고 있습니다. 이번 개발일지는 지난 며칠간 `eca8e83`부터 `f985f12`까지, 총 35개의 커밋에 대한 내용을 담고 있어요. 정말 많은 작업을 했죠? 🤔 저도 커밋 로그를 정리하면서 '와, 이거 다 했단 말이야?' 싶을 정도로 스스로 놀랐습니다.\n\n**작업 기간**: 2025-11-15 ~ 2025-11-16\n\n## 📝 이번 기간 작업 내용\n\n이번 기간에는 Fallingo의 핵심 기능인 '피드 등록' 프로세스를 대대적으로 재정의하고, AI 기반 콘텐츠 생성 및 외부 API 연동을 고도화하는 데 집중했습니다. 또한, 서비스 안정성과 확장성을 위해 백엔드와 프론트엔드 코드 품질 개선 작업도 빼놓지 않았죠.\n\n### 🚀 핵심 기능 재정의 및 개선: 피드 등록 & OCR 인증\n\nFallingo의 꽃은 역시 '음식 피드' 아니겠어요? 이번에 피드 등록 플로우를 완전히 갈아엎었습니다. 특히, AI 기반 OCR 인증 방식에 큰 변화를 줬어요.\n\n*   **피드 등록 프로세스 재정의 (Phase 2 완료)**: 프론트엔드와 백엔드 모두에서 피드 등록 로직을 완전히 새로 짰습니다. 사용자 경험을 최적화하고, 데이터 일관성을 높이는 데 주력했어요. DB 마이그레이션까지 완료해서 이제 새로운 피드 등록 방식이 안정적으로 동작합니다!\n*   **OCR 인증 UX 플로우 개선**: 기존에는 피드 상세 화면을 거쳐 OCR 인증을 하는 방식이었는데, 사용자 편의성을 위해 '피드 상세 거치지 않고 직접 카메라 열기' 방식으로 변경했습니다. 갤러리 접근은 막고, 바로 카메라로 영수증을 찍어서 인증하는 거죠. 👍 더 빠르고 직관적인 경험을 제공할 수 있게 되었어요.\n    *   `feat: 프론트엔드 피드 등록 프로세스 재정의 - Phase 2 완료`\n    *   `feat: 피드 등록 DB 마이그레이션 완료 - Phase 1`\n    *   `docs: OCR 인증 UX 플로우 수정 - 피드 상세 거치지 않고 직접 카메라 열기`\n\n> **작업량**: 2개의 핵심 프로세스 재정의 및 DB 마이그레이션 완료, 3개의 UX 플로우 개선 (완성도: 90%)\n\n### 🤖 AI 및 외부 API 연동: 월드 이벤트 자동화\n\n최근 FastAPI와 Flutter, PostgreSQL을 학습하며 AI 기반 개발 방식에 푹 빠져있다고 말씀드렸죠? 이번에 그 결과물이 나왔습니다! Fallingo가 단순한 맛집 앱을 넘어, 사용자에게 더 풍부한 경험을 제공할 수 있도록 월드 이벤트 콘텐츠를 AI로 자동 생성하는 시스템을 구축했어요.\n\n*   **월드 이벤트 API 연동**: FIFA와 Olympic.org API를 연동해서 월드컵, 올림픽 일정을 자동으로 가져오도록 만들었습니다. 🌍 전 세계의 중요한 음식 축제나 스포츠 이벤트가 있을 때 Fallingo에서 관련 정보를 바로바로 볼 수 있게 되는 거죠.\n*   **Gemini API 기반 AI 콘텐츠 생성**: 연동된 일정 데이터를 바탕으로 Gemini API를 활용해 월드 이벤트 피드 콘텐츠를 AI가 자동으로 생성하도록 구현했습니다. 이 부분이 정말 흥미로웠어요. 비전공자 출신인 제가 이렇게 AI를 활용해서 실제 서비스를 만든다는 게 감회가 새롭습니다. 물론 시행착오도 많았지만, 결국 해냈습니다! 🥳\n*   **Cloud Scheduler 보안 강화**: 이 과정에서 Cloud Scheduler로 주기적인 작업을 돌려야 했는데, 보안을 위해 OIDC 토큰 검증까지 구현해서 외부 접근을 철저히 막았습니다.\n\n> **작업량**: 2개의 외부 API 연동, 1개의 AI 콘텐츠 생성 시스템 구축, 1개의 보안 시스템 적용 (완성도: 85%)\n\n### ⚙️ 백엔드 API 및 시스템 고도화\n\nFallingo의 뼈대가 되는 백엔드 시스템도 가만두지 않았습니다. 안정성과 성능 향상을 위한 리팩토링과 새로운 기능 추가가 많았어요.\n\n*   **API 엔드포인트 코드 품질 개선**: Auth (인증) 및 Follow (팔로우) 관련 API 엔드포인트의 코드 품질을 대폭 개선했습니다. 아무래도 서비스의 핵심 기능이다 보니 더욱 견고하게 만들어야 했죠.\n*   **서비스 모듈 분할 (Facade 패턴 적용)**: `gamification_service.py`와 `feed_curation_service.py`처럼 기능이 커진 모듈들을 각각 4개, 3개의 서브 모듈로 분할하고 Facade 패턴을 적용했습니다. 덕분에 코드 가독성이 좋아지고 유지보수가 훨씬 쉬워졌어요. 나중에 다른 개발자들이 합류하더라도 이해하기 쉬울 거예요. 🙇‍♂️\n*   **스마트 위치 알림 기능 추가**: 사용자 주변의 맛집이나 이벤트를 효율적으로 알려줄 수 있도록 Geofencing 기반의 스마트 위치 알림 기능을 추가했습니다. 배터리 효율까지 고려해서 설계하느라 머리가 좀 아팠지만, 사용자 경험 향상을 위해 꼭 필요한 기능이라고 생각해요.\n*   **에러 핸들러 적용**: `notification_endpoints.py`를 시작으로 여러 API 엔드포인트에 에러 핸들러 데코레이터를 적용해서, 예상치 못한 오류 발생 시에도 사용자에게 친절한 메시지를 전달하고 백엔드 로그를 더욱 체계적으로 관리할 수 있게 했습니다.\n\n> **작업량**: 5개의 핵심 백엔드 서비스 모듈 분할 및 개선, 1개의 신규 기능 (Geofencing) 추가, 10개 이상의 API 엔드포인트 코드 품질 개선 및 에러 핸들러 적용 (완성도: 80%)\n\n### 📱 프론트엔드 (Flutter) UI/UX 및 상태 관리 개선\n\nFlutter 기반의 프론트엔드도 대대적인 리팩토링이 진행되었습니다. 특히 상태 관리와 UI 코드 품질에 신경을 많이 썼어요.\n\n*   **설정 화면 리팩토링**: `settings_screen.dart` 파일을 '2025 Best Practices'에 맞춰 전면 리팩토링했습니다. 불필요한 위젯 중첩을 줄이고, 반응형 UI를 더욱 견고하게 만들었어요.\n*   **상태 관리 리팩토링 (ProfileProvider 패턴 적용)**: 프로필 관련 상태 관리를 `ProfileProvider` 패턴으로 통일하여 더욱 예측 가능하고 관리하기 쉽게 만들었습니다. React나 Vue.js를 오랫동안 다루면서 쌓인 경험이 Flutter 상태 관리에도 빛을 발하는 것 같습니다. ✨\n*   **iOS 개발 환경 정리**: iOS Xcode 자동 생성 파일들을 `.gitignore`에 추가하고, 불필요한 파일들을 Git 추적에서 제거하는 작업을 했습니다. `fix: iOS Xcode 파일 .gitignore 패턴 수정` 같은 커밋이 반복된 건, 처음에는 놓쳤던 Xcode 관련 파일들이 계속 나타나서 완벽하게 정리하느라 여러 번 손이 갔기 때문입니다. 😅\n\n> **작업량**: 1개의 핵심 UI 화면 리팩토링, 1개의 상태 관리 패턴 적용, 3개의 iOS 개발 환경 관련 정리 (완성도: 70%)\n\n### 📚 문서화 및 코드 품질 관리\n\n개발 속도가 빨라질수록 문서화와 코드 품질 관리는 더욱 중요해집니다. 이번 기간에도 꾸준히 진행했어요.\n\n*   **성능 최적화 현황 업데이트**: 25개의 데이터베이스 인덱스를 적용하고, 그에 따른 성능 분석 리포트를 업데이트했습니다.\n*   **코드 품질 가이드 및 리포트**: 'Priority 5 Code Cleanup 가이드'와 '코드 품질 분석 및 리팩토링 가이드' 문서를 작성하고, `CODE_QUALITY_REPORT.md`를 업데이트하며 진행 상황을 공유했습니다.\n*   **법률 문서 시스템 확장**: 서비스가 점점 고도화되면서 필요한 약관들이 늘어나고 있어요. 6개의 추가 약관 및 모델 개선을 통해 법률 문서 시스템을 확장했습니다.\n\n> **작업량**: 3개의 현황 리포트 및 가이드 문서 작성, 25개 인덱스 적용 현황 문서화, 6개 법률 문서 추가 (완성도: 95%)\n\n### 🛠️ 버그 수정 및 개발 환경 설정\n\n*   **프로덕션 배포 차단 이슈 해결**: 가장 시급했던 '프로덕션 배포 차단 이슈'와 몇 가지 보안 취약점을 수정했습니다. 정말 가슴을 쓸어내렸죠. 🤯\n*   **Python 환경 설정**: `pyenv`를 이용해 Python 3.11.9 환경을 설정했습니다.\n*   **모델 import 및 Poetry 경로 수정**: 여러 모델의 `__init__.py` export 오류를 수정하고, GitHub Actions에서 `Poetry` 명령어 경로가 제대로 잡히지 않는 문제를 해결했습니다.\n\n> **작업량**: 5개의 Critical 버그 및 환경 설정 이슈 해결 (완성도: 100%)\n\n## 💡 작업 하이라이트\n\n이번 기간의 가장 큰 하이라이트는 두 가지를 꼽을 수 있을 것 같습니다.\n\n1.  **피드 등록 프로세스 전면 재정의 및 OCR 인증 고도화**: Fallingo의 핵심인 피드 등록 경험을 사용자 중심으로 대폭 개선한 것이 가장 큰 성과라고 생각합니다. 특히 OCR 인증 플로우를 단순화하여 실제 사용자들이 더 쉽고 빠르게 영수증 인증을 할 수 있도록 만든 점이 매우 만족스러워요.\n    ![피드 등록 프로세스 개요](https://www.plantuml.com/plantuml/svg/TO_2j2m034Ft_932f_95S4P4T5U8j42_s2V2m20L8O9A1C5W2gM0xI9X2W_d5B7T2i8Y2M_0gS5N5i-oA7K8x1kM1sA7i7N3H0e7u-8W3t0S2Q9m9n0Q0a7O0k7Q3h3A0W_f5K4J0_1vF0i0_i4V2F0g8E2F_E0wQ2m2U6c_A0f-v0w6k2_G7E0D2_S9V4V6Z6j_S5y2q1r2y_V9j9J8c4A9I0r_P4D2n0x4K2P3Z7G2F1n7n4x7S8I0J2M7N5P9Z5N3F0W3V5L8j_F7i5P0y2y4B7L1A6g3O5f2T0f0P5Y4u5e0I3Q1c1H5B3C7M2f0B0P0T1x3E5U9F4D3C9G2N4Y1E1q2v0x5M4F2I3P4L1J4P1F4Z1O4Z2K7G4J4E4W1i4p5D1r4L1D5n1w0b0c6H6Q3C3w4z2n3A5b1I6x5H0r1I0o0t1y6n1e6z7m3e0R7M2r2z2G2n4C0s0e0d4H2E7B3W4s4N5Y4k7R3Q2c2j5T0W2y2S0u3A3w3B2x4S0m4g4l2Q6c_f6G3d4Y1z6w2k4V0n3H1o0b7j2e1S6U4B7J6m2d7g1M6l5b1P4z3O4R5i8_W6X5H4N7v5R6j3z5F8l4R6P3e5M4P4U5G4U0c8R4L0Q6K8F4W5N4J6D5O4H0S6X6n4W4g0A5O6f5e3Z5G4i0c2W3F5G3O6E6M4b6U2Z4h4B3M0B1I7C3C5V4G1o5c7B2n3e0Y7w3c5j1E4G3o0k7G7C3N6w4y0f5i2B5U7T5O7v5D2g0s5M2R2l4E1I2t5E5N2l2k1U4z1n4m4u5d1n3u3c1R5e0u1U6o3i4D4s5m0k4w1x2i5o0M4L0O5u5t1O5t6u3d3f1N3y0m1s0k1y3C1P1n3C4v0u1k5I7i3N1e0J6L0V1U4v1v3y1e6m5G1x0z2D2L1F2D6t1j4n5k2i6E3S3G4M3m4r0H1r5j2F1l3s5e3T3W4n4U4R4J2I4D0u1o4w5s2g3o3S3N6l5Q6i2Q3f1T0T2j6o3W0o7z0X1Q0W6n2B5G4G4U4K4Y6s5I4l2P3c2f0T2k4n3i1e6z0H0R1Y3d4i1A5E7G4g6X6I4x4i1m1j4i0V1B6D2P7U5O5D6W4m6t3V7G2O2F7A5S2l2Q5m3V7g0A5Q6J6D2k1r5D7Q5A6f0D0E2n5L5B4D6I1L7K7B5r2x6r0M2o7O4m6r5H5V6E5C4k7R6R4m0z4I1i3C6O6m5U5L4Q6n4I0g7M5L4W7O5t6T4v1k0p6P6S2u7E6L4V6B6v0E0W5T4w0B0A3J5c4x6v5L0X4C6Q4S6Q4U7D6R6M6D5S7M5V4T6Q4P6B6L0b6Q5v0O7m5A6R5Q4X6S6H6b2D2G6P3z5S2o6w4p3G6Q4o7J6C0S6x4x3W0v6m4C6l6C3D2v7e7P3H2K4o6C6J6H6H5B6P0t6x6K5w4w0e6w6c4l4C7B5D6J0v0w6y4m6g7P5D6L5F4M7I4J4w4B5U5r0h6x0s6H5L5g7k6l0e0X4w0V4g7O5Y4e7L4G5e2j7M0e6k0p6C6f6B6x6x0X6x4z5s6C6z6j7L0e6r4w4K6C6P5m6D5e5L6F7R3o0e4D4B0m4R0v0o6e3g0e6m4Q4r7E2O6L6U6D5D2R7E6N5C7k4j4G4z6G2p4l6A7H2Y6g5W4W2n5E2J6P3g4J3N5E6N3C4P4Q6z3R6Q4X4e4Z4x4D7H4K7I3Y6Y7z6K6K3J6D2k2k7f4t4f4G3g4k4x4k7E3f5j3J2t4Q6X5P7N7x0o5S4r4Q5G0p5M5r4r2f0D4S3i1k1D5t0U2p0K3x6Y4w0n6T3X3i1Y0Q5B7N4C4S2t3D5A5U3Y3B0F5W2o4s5f2C6K4k0H4P3V4P1O2i0Q3G2S6L1H4L0F1G3Q0n5X4Y1x3M6w0L3k1L6F2n3M7m3X4X0Y4V5O3k3i0r3G7K2N5Z3k2l5n1e0k2t2F0X2G1J2k5z0z0T0o6H5L4Y6N4r5t7g5X7z7B0S5s5L5N5W0G6U5Q6L3K6S5D5o5X0E2K5X5R0w6x0R6r6F4t6r6J5o0p6g6x4R7m7g0x5g5J7C7C5Y2o2m0H6z0r4E4g6W7i6f5r4l6f6i5j6g5w5W4p4x0Y4g6e6J5M5Y5Q5H4H6R5B5f5Y6k4J6c6K6B5G6j6C6A6V6Z4N7t4O4M4g7O5Q6K5A4M3K6E3Z5W5k6V4h3D4Y6e6g7o6e7g6D4g5e4Z6i5s6x6r4G4Q7i6C7J6L6M5m6G5w6l6g5F6o6x6x6y4K6G6O6Y4O7x6X6Q7Q7Y7B5T5E5K7B6W6f6R6j5J6X6R4f4h6R4Y5B6M5O7L6J7H6K4G7i5D6S4W5G7E6T4D7I6I6D6Y6L5G6T6V5T5T4L6M4K7L5U5U6U4N5M5W5W6b5H5r4f7H7J5J6K6L7L6Q6H7K6g6I6G6J7K6O6K5H6B5H6X6H5J6O6I6I6G7Y6O6N7F7K6K6L6M6Q6G7K6G6N6Q6O6L6D7H6H6G7G6J7L6G7E6G7L6R5L5H6D5G6J7L6N7M6Q7T6J7G6M7L7L6N7M6P6K7T6K7G6M7L7Q6L7K6P7H7L7L7K6K7M6M7P6Q7K7L7K7O6Q7L6M7M7G6K7L7N7M6M7L7K6O6P7Q6L7K6K7L6M6Q7T6G7L7P7K6P7M6N7G6K7L7K7M7M6P7M7L7L7P7K7O6Q7M7M6N7L7K7L7K7K7L7K6N7Q6K7T7K7K7M6M7P7M7L7L7L7M6N7M7K7L7K7O6Q7L7M6N7L7K7M7M7M7M7L7L7K7K7K7L7L7K7M7M7L7K7M7M7L7L7M7M7M7K7M7L7L7L7K7L7M7K7L7K7K7L7L7M7K7M7L7L7K7L7K7L7K7L7K7L7M7K7L7K7L7L7K7L7M7K7L7K7L7M7M7L7M7M7K7L7K7K7M7K7L7L7K7M7L7K7L7K7K7L7K7L7K7L7K7L7K7L7K7K7L7K7L7M7K7L7L7K7M7K7L7K7L7K7M7L7M7M7K7L7K7M7L7K7M7M7K7L7K7L7K7K7M7K7L7K7L7M7K7L7K7L7M7M7L7M7M7L7K7M7L7M7M7M7M7M7K7L7K7L7K7M7K7L7M7M7M7L7K7L7K7M7L7M7L7K7M7K7L7L7M7L7M7M7M7K7L7K7M7K7L7M7K7L7K7L7M7K7L7M7K7L7K7L7L7K7L7M7M7L7M7K7L7L7K7L7M7L7M7L7K7L7L7K7L7M7L7M7L7K7L7L7K7L7M7L7M7L7K7L7K7L7M7K7L7K7L7M7L7K7L7M7L7K7L7M7M7L7L7K7L7M7L7M7M7L7K7L7L7K7L7M7L7M7K7L7K7M7L7K7L7M7L7K7M7M7L7K7L7K7L7K7L7M7K7M7L7K7L7K7M7K7M7K7L7K7L7K7M7K7L7K7M7L7K7M7K7M7L7K7M7K7L7K7M7K7L7K7L7M7K7L7K7L7M7K7M7K7M7L7K7L7K7M7K7L7K7M7L7K7L7M7K7L7K7L7M7L7M7K7M7L7K7L7K7L7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7K7M7L7K7L7M7M7L7M7K7L7K7L7M7M7M7K7L7K7L7M7K7M7K7M7L7K7L7M7M7L7M7K7L7K7L7K7L7M7K7L7K7M7M7L7K7L7M7L7K7M7L7K7M7L7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7K7M7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7M7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7L7M7L7K7M7K7L7K7M7K7L7K7L7M7K7L7M7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7L7K7L7M7L7K7M7L7K7L7K7L7M7K7L7K7M7L7K7L7M7K7L7K7L7M7L7K7M7L7K7L7K7L7M7K7L7K7L7M7L7K7M7L7K7L7K7L7M7K7L7M7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7L7M7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7L7M7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7M7L7M7K7L7K7L7M7K7M7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7L7M7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K7L7K7M7K",
      "description": "피드 등록 프로세스 재정의, AI/API 연동 및 백엔드/프론트엔드 코드 품질 개선 작업 진행",
      "tags": [
        "fallingo",
        "개발일지",
        "피드",
        "OCR",
        "AI",
        "FastAPI",
        "Flutter",
        "리팩토링"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/fallingo-devlog-0034.md"
    },
    {
      "slug": "tech-auto-devlog",
      "title": "GitHub Actions + Gemini API로 커밋 20개마다 개발 일지 자동 생성하기",
      "date": "2025-11-11T00:00:00.000Z",
      "category": "tech",
      "content": "# GitHub Actions + Gemini API로 커밋 20개마다 개발 일지 자동 생성하기\n\n## 문제: 개발 일지를 꾸준히 쓰기 어렵다\n\n개발자라면 누구나 이런 고민이 있습니다. \"프로젝트를 진행하면서 개발 일지를 작성하고 싶지만, 매번 실행에 옮기기 어렵다\" 그리고 \"커밋은 매일 하는데 문서화는 못하고 있다\"는 고민 말입니다.\n\n저도 fallingo를 개발하면서 같은 문제를 겪었습니다. 매주 개발 일지를 작성하려고 했지만, 막상 앉아서 쓰려니 \"뭐 했더라?\" 하면서 커밋 히스토리를 다시 읽어야 했습니다.\n\n## 해결책: 커밋 20개마다 자동으로 개발 일지 생성\n\n자동으로 되면 좋겠다는 생각을 했고 시도해봤습니다:\n\n1. **프로젝트 저장소**에서 마지막 개발 일지 태그 이후 **커밋이 20개 쌓이면** 자동 트리거\n2. **Gemini API**(Google의 무료 AI)로 커밋 히스토리 분석 및 **마크다운 개발 일지 자동 생성**\n3. 생성된 개발 일지를 **개발 일지 저장소**로 **자동 푸시**\n4. 개발 일지 저장소의 **GitHub Actions가 자동으로 재배포**\n\n**핵심 포인트:**\n\n- **Git 태그로 상태 관리**: 마지막 개발 일지 시점을 `log-YYYYMMDD-HHMMSS` 태그로 기록\n- **자동 커밋 카운팅**: 태그 이후 20개 커밋이 쌓였는지 자동 체크\n- **순차 번호 부여**: GitHub API로 기존 개발 일지 개수 확인하여 `fallingo-devlog-0001.md` 형식으로 자동 번호 부여\n\n**결과:** 개발에만 집중하면, 커밋 20개마다 개발 일지가 자동으로 작성되고 배포됩니다.\n\n## 시스템 아키텍처\n\n```mermaid\nsequenceDiagram\n    participant Dev as 개발자\n    participant Project as 프로젝트 저장소<br/>(fallingo)\n    participant Actions as GitHub Actions\n    participant Gemini as Gemini API\n    participant DevLog as 개발 일지 저장소<br/>(stories)\n    participant Pages as GitHub Pages\n\n    Dev->>Project: git push (커밋 누적)\n\n    Note over Project,Actions: 커밋 20개 체크\n\n    Actions->>Project: 마지막 log-* 태그 확인\n    Project-->>Actions: log-20251101-153020\n\n    Actions->>Project: git log log-20251101-153020..HEAD --count\n    Project-->>Actions: 커밋 20개 이상 확인\n\n    Note over Actions: ✅ 20개 이상 → 개발 일지 생성\n\n    Actions->>Project: git log 수집 (커밋 메시지, 날짜, 작성자)\n    Project-->>Actions: 20개 커밋 히스토리\n\n    Actions->>Gemini: 커밋 히스토리 + 프롬프트 전송\n    Gemini-->>Actions: 마크다운 개발 일지 생성\n\n    Actions->>DevLog: GitHub API로 마크다운 푸시<br/>(fallingo-devlog-0034.md)\n    DevLog-->>Actions: 업로드 성공\n\n    Actions->>Project: git tag log-20251111-042530 생성\n    Actions->>Project: git push origin log-20251111-042530\n\n    Note over DevLog,Pages: 자동 빌드 & 배포\n\n    DevLog->>DevLog: GitHub Actions 트리거\n    DevLog->>DevLog: posts-index.json 생성\n    DevLog->>DevLog: React 앱 빌드 (Vite)\n    DevLog->>Pages: GitHub Pages 배포\n\n    Pages-->>Dev: 개발 일지 자동 배포 완료\n```\n\n## 핵심 구성 요소\n\n### 1. GitHub Actions Workflow (프로젝트 저장소)\n\n```yaml\n# .github/workflows/auto-dev-log.yml\nname: Auto Dev Log Post\n\non:\n  push:\n    branches:\n      - main\n  workflow_dispatch: # 수동 실행도 가능\n\njobs:\n  generate-log:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write  # 태그 push 권한\n\n    steps:\n      - name: Checkout 프로젝트 저장소\n        uses: actions/checkout@v4\n        with:\n          repository: <프로젝트-계정>/<프로젝트-저장소>\n          fetch-depth: 0 # 전체 커밋 히스토리 가져오기\n\n      - name: 마지막 개발 일지 이후 커밋 개수 체크\n        id: check\n        run: |\n          # 마지막 개발 일지 태그 찾기 (log-* 패턴)\n          LAST_LOG_TAG=$(git tag -l \"log-*\" | sort -V | tail -1)\n\n          if [ -z \"$LAST_LOG_TAG\" ]; then\n            # 태그가 없으면 전체 커밋 개수\n            COMMIT_COUNT=$(git rev-list --count HEAD)\n          else\n            # 마지막 개발 일지 이후 커밋 개수\n            COMMIT_COUNT=$(git rev-list --count ${LAST_LOG_TAG}..HEAD)\n          fi\n\n          echo \"커밋 개수: $COMMIT_COUNT\"\n          echo \"count=$COMMIT_COUNT\" >> $GITHUB_OUTPUT\n\n          # 20개 이상이면 개발 일지 생성\n          if [ $COMMIT_COUNT -ge 20 ]; then\n            echo \"✅ 20개 이상 커밋 누적 → 개발 일지 생성\"\n            echo \"should_run=true\" >> $GITHUB_OUTPUT\n          else\n            echo \"⏳ 커밋 $COMMIT_COUNT개 누적 중 (20개 필요)\"\n            echo \"should_run=false\" >> $GITHUB_OUTPUT\n          fi\n\n      - name: Node.js 설정\n        if: steps.check.outputs.should_run == 'true'\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n      - name: 의존성 설치\n        if: steps.check.outputs.should_run == 'true'\n        run: |\n          cd dev-log\n          npm install\n\n      - name: 개발 일지 생성\n        if: steps.check.outputs.should_run == 'true'\n        env:\n          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}\n          DEV_LOG_TOKEN: ${{ secrets.DEV_LOG_TOKEN }}\n          DEV_LOG_REPO: <계정>/<개발일지-저장소>\n        run: |\n          cd dev-log\n          node generate-log.js\n\n      - name: 개발 일지 태그 생성\n        if: steps.check.outputs.should_run == 'true'\n        run: |\n          TAG_NAME=\"log-$(date +%Y%m%d-%H%M%S)\"\n          git config user.name \"github-actions[bot]\"\n          git config user.email \"github-actions[bot]@users.noreply.github.com\"\n          git tag \"$TAG_NAME\"\n          git push origin \"$TAG_NAME\"\n          echo \"✅ 태그 생성: $TAG_NAME\"\n```\n\n**핵심 로직:**\n\n1. **태그 기반 커밋 카운팅**: `git tag -l \"log-*\"`로 마지막 개발 일지 태그 찾기\n2. **Git Range 계산**: `${LAST_LOG_TAG}..HEAD`로 새 커밋만 카운팅\n3. **조건부 실행**: 20개 이상일 때만 `should_run=true`\n4. **태그 자동 생성**: 개발 일지 생성 후 `log-YYYYMMDD-HHMMSS` 태그 푸시\n\n### 2. 개발 일지 생성 스크립트\n\n아래 코드는 제가 실제로 사용하는 것을 예시로 작성한 것입니다.\n\n```javascript\n// dev-log/generate-log.js\nimport { GoogleGenerativeAI } from '@google/generative-ai';\nimport { execSync } from 'child_process';\nimport fetch from 'node-fetch';\n\n// 환경 변수\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY;\nconst DEV_LOG_TOKEN = process.env.DEV_LOG_TOKEN;\nconst DEV_LOG_REPO = process.env.DEV_LOG_REPO; // \"계정/저장소\" 형식\n\n// Gemini AI 초기화 (gemini-2.5-flash, 일일 1,000만 토큰 무료)\nconst genAI = new GoogleGenerativeAI(GEMINI_API_KEY);\nconst model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });\n\n// 1️⃣ 마지막 개발 일지 이후 커밋 히스토리 가져오기\nfunction getCommitsSinceLastLog() {\n  let gitRange = 'HEAD';\n  try {\n    const lastLogTag = execSync(\n      `git tag -l \"log-*\" | sort -V | tail -1`,\n      { encoding: 'utf-8' }\n    ).trim();\n\n    if (lastLogTag) {\n      gitRange = `${lastLogTag}..HEAD`;\n      console.log(`📌 마지막 개발 일지 태그: ${lastLogTag}`);\n    } else {\n      console.log(`📌 첫 개발 일지 생성`);\n    }\n  } catch (e) {\n    console.log(`📌 태그 없음, 전체 커밋 사용`);\n  }\n\n  const commits = execSync(\n    `git log ${gitRange} --pretty=format:\"%H|%an|%ad|%s\" --date=short`,\n    { encoding: 'utf-8' }\n  );\n\n  if (!commits.trim()) {\n    return [];\n  }\n\n  return commits.trim().split('\\n').map(line => {\n    const [hash, author, date, message] = line.split('|');\n    return { hash, author, date, message };\n  });\n}\n\n// 2️⃣ Gemini로 개발 일지 생성\nasync function generateLogPost(commits) {\n  const commitSummary = commits.map(c =>\n    `- ${c.date}: ${c.message}`\n  ).join('\\n');\n\n  // 커밋 범위 정보\n  const startCommit = commits[commits.length - 1].hash.substring(0, 7);\n  const endCommit = commits[0].hash.substring(0, 7);\n  const commitRange = `${startCommit}..${endCommit}`;\n\n  // 날짜 범위\n  const startDate = commits[commits.length - 1].date;\n  const endDate = commits[0].date;\n  const dateRange = startDate === endDate ? startDate : `${startDate} ~ ${endDate}`;\n\n  const prompt = `\n당신은 프로젝트 개발 일지를 작성하는 AI입니다.\n\n# 개발자 소개\n- {개발자 정보를 여기에 작성}\n\n# 작성 스타일\n- 존댓말 사용 (예: \"했습니다\", \"배웠습니다\", \"시도했습니다\")\n- 친근하고 솔직한 어투\n- 기술적 도전과 해결 과정 중심\n- 실패와 배움도 공유\n- 개발자 커뮤니티에 도움이 되는 내용\n\n# 최근 커밋 내역 (${commitRange}, ${commits.length}개)\n${commitSummary}\n\n# 요청사항\n위 ${commits.length}개의 커밋 내역 (${commitRange})을 바탕으로 **개발 일지(Dev Log)**를 작성해주세요.\n이것은 기술 튜토리얼이 아니라 \"이번 기간 동안 무엇을 했는지\" 기록하는 일지입니다.\n\n**반드시 아래 Frontmatter 형식으로 시작해야 합니다:**\n\n---\ntitle: \"fallingo 개발일지 - ${commitRange} (${commits.length}개 커밋)\"\ndate: \"${endDate}\"\ncategory: \"dev-log\"\ndescription: \"작업 내용을 한 줄로 요약 (20-40자)\"\ntags: [\"fallingo\", \"개발일지\"]\nauthor: \"Su\"\nlang: \"ko\"\n---\n\n# fallingo 개발일지 - ${commitRange} (${commits.length}개 커밋)\n\n**작업 기간**: ${dateRange}\n\n## 📝 이번 기간 작업 내용\n- 커밋들을 **기능/영역별로 그룹화**하여 목록 형식으로 정리\n  * 예: \"백엔드 API 개선\", \"프론트엔드 UI 작업\", \"인프라 설정\", \"문서화\" 등\n- 각 그룹별로 주요 커밋 2-3개씩 간단히 설명\n- 작업량과 완성도를 숫자로 표현 (예: \"10개 API 엔드포인트 구현\", \"5개 버그 수정\")\n\n## 💡 작업 하이라이트\n- 이번 기간의 가장 의미 있는 작업 1-2가지\n- 반복된 fix/refactor가 있다면 그 이유 간단히 추측\n\n## 📊 개발 현황\n- 전체 프로젝트에서 현재 단계 위치 (예: \"백엔드 90% 완료, 프론트엔드 80% 진행 중\")\n\n길이: 1,500-2,500자 (간결하게)\n\n**작성 가이드**:\n- 반드시 Frontmatter(---로 감싼 YAML)로 시작\n- description은 커밋 내용을 요약한 한 줄 (20-40자)\n- 커밋 메시지 그대로 나열하지 말고, 의미 있게 그룹화\n- 과도한 해석이나 추측 지양, 팩트 기반으로 작성\n- 개발 일지답게 담백하고 정보 전달에 집중\n- **다이어그램, 표(Table), 코드 블록 등 마크다운 기능을 자유롭게 사용 가능**\n\n개발 일지만 출력하고, 다른 설명은 붙이지 마세요.\n`;\n\n  // 재시도 로직 (Quota 초과 대응)\n  let retries = 3;\n  let delay = 30000; // 30초\n\n  for (let i = 0; i < retries; i++) {\n    try {\n      const result = await model.generateContent(prompt);\n      const response = await result.response;\n      return response.text();\n    } catch (error) {\n      if (error.status === 429) {\n        console.log(`⏳ Quota 초과. ${delay / 1000}초 후 재시도 (${i + 1}/${retries})...`);\n        if (i < retries - 1) {\n          await new Promise(resolve => setTimeout(resolve, delay));\n          delay *= 2; // 지수 백오프\n        } else {\n          throw new Error('Gemini API quota 초과. 나중에 다시 시도해주세요.');\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n\n// 3️⃣ 개발 일지 저장소에 업로드\nasync function uploadToGitHub(content, commitCount, commitRange) {\n  // 기존 개발 일지 개수 확인하여 순차 번호 생성\n  let logNumber = 1;\n  try {\n    const response = await fetch(\n      `https://api.github.com/repos/${DEV_LOG_REPO}/contents/posts`,\n      {\n        headers: {\n          'Authorization': `token ${DEV_LOG_TOKEN}`,\n        },\n      }\n    );\n    if (response.ok) {\n      const files = await response.json();\n      // fallingo-devlog-NNNN.md 패턴 찾기\n      const devlogFiles = files.filter(f =>\n        f.name.match(/^fallingo-devlog-\\d{4}\\.md$/)\n      );\n      if (devlogFiles.length > 0) {\n        // 가장 큰 번호 찾기\n        const numbers = devlogFiles.map(f =>\n          parseInt(f.name.match(/\\d{4}/)[0])\n        );\n        logNumber = Math.max(...numbers) + 1;\n      }\n    }\n  } catch (e) {\n    console.log(`📝 첫 개발 일지 생성 (번호: ${String(logNumber).padStart(4, '0')})`);\n  }\n\n  const fileName = `fallingo-devlog-${String(logNumber).padStart(4, '0')}.md`;\n  const filePath = `posts/${fileName}`;\n  console.log(`📝 파일명: ${fileName}`);\n\n  // 기존 파일 확인 (중복 방지)\n  let sha = null;\n  try {\n    const checkResponse = await fetch(\n      `https://api.github.com/repos/${DEV_LOG_REPO}/contents/${filePath}`,\n      {\n        headers: {\n          'Authorization': `token ${DEV_LOG_TOKEN}`,\n        },\n      }\n    );\n    if (checkResponse.ok) {\n      const data = await checkResponse.json();\n      sha = data.sha;\n      console.log(`📝 기존 파일 발견, 업데이트 모드`);\n    }\n  } catch (e) {\n    console.log('📝 새 파일 생성 모드');\n  }\n\n  const body = {\n    message: `Add fallingo dev log: ${commitRange} (${commitCount} commits)`,\n    content: Buffer.from(content).toString('base64'),\n  };\n\n  if (sha) {\n    body.sha = sha; // 업데이트 시 필수\n  }\n\n  const response = await fetch(\n    `https://api.github.com/repos/${DEV_LOG_REPO}/contents/${filePath}`,\n    {\n      method: 'PUT',\n      headers: {\n        'Authorization': `token ${DEV_LOG_TOKEN}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body),\n    }\n  );\n\n  if (!response.ok) {\n    const errorData = await response.json();\n    throw new Error(`GitHub API error: ${JSON.stringify(errorData)}`);\n  }\n\n  return response.json();\n}\n\n// 메인 실행\nasync function main() {\n  try {\n    console.log('🔍 마지막 개발 일지 이후 커밋 수집 중...');\n    const commits = getCommitsSinceLastLog();\n\n    if (commits.length === 0) {\n      console.log('⚠️  새로운 커밋이 없습니다.');\n      return;\n    }\n\n    console.log(`✅ ${commits.length}개 커밋 발견`);\n\n    console.log('✍️  Gemini로 개발 일지 생성 중...');\n    const logPost = await generateLogPost(commits);\n\n    const startCommit = commits[commits.length - 1].hash.substring(0, 7);\n    const endCommit = commits[0].hash.substring(0, 7);\n    const commitRange = `${startCommit}..${endCommit}`;\n\n    console.log('📤 GitHub에 업로드 중...');\n    const result = await uploadToGitHub(logPost, commits.length, commitRange);\n\n    console.log('🎉 개발 일지 발행 완료!');\n    console.log(`📝 ${result.content.html_url}`);\n  } catch (error) {\n    console.error('❌ 오류 발생:', error);\n    process.exit(1);\n  }\n}\n\nmain();\n```\n\n**핵심 로직:**\n\n1. **Git 태그 기반 커밋 수집**: `log-*` 패턴 태그로 마지막 시점 파악\n2. **Gemini API 호출**: 커밋 히스토리 + 상세 프롬프트 전송\n3. **GitHub API 파일 업로드**: Base64 인코딩 후 PUT 요청\n4. **순차 번호 자동 부여**: 기존 파일 스캔하여 `fallingo-devlog-0001.md` 형식\n\n## 설정 방법\n\n### 1️⃣ Gemini API 키 발급\n\n1. **Google AI Studio 접속**: https://aistudio.google.com/\n2. **Get API Key** → **Create API Key** 클릭\n3. API 키 복사 (`xxxx...`)\n\n**무료 티어 제한:**\n\n- 일일 1,500 요청\n- 분당 15 요청\n- 월 100만 토큰\n\n### 2️⃣ GitHub Personal Access Token 발급\n\n개발 일지 저장소에 푸시하려면 토큰이 필요합니다.\n\n1. **GitHub** → **Settings** → **Developer settings** → **Personal access tokens** → **Tokens (classic)**\n2. **Generate new token (classic)**\n3. **Scopes 선택**:\n   - ✅ `repo` (전체 선택)\n   - ✅ `workflow`\n4. 토큰 복사 (`xxxx...`)\n\n### 3️⃣ GitHub Secrets 등록\n\n**프로젝트 저장소** → **Settings** → **Secrets and variables** → **Actions**\n\n```\nName: GEMINI_API_KEY\nSecret: xxxx...\n\nName: DEV_LOG_TOKEN\nSecret: xxxx...\n```\n\n### 4️⃣ package.json 설정\n\n```json\n{\n  \"name\": \"fallingo-dev-log\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@google/generative-ai\": \"^0.21.0\",\n    \"node-fetch\": \"^3.3.2\"\n  }\n}\n```\n\n### 5️⃣ 디렉토리 구조\n\n```\n프로젝트-저장소/\n├── .github/\n│   └── workflows/\n│       └── auto-dev-log.yml\n├── dev-log/\n│   ├── package.json\n│   └── generate-log.js\n└── (나머지 프로젝트 파일)\n```\n\n### 6️⃣ GitHub Pages 설정\n\n개발 일지 저장소에서 GitHub Pages를 활성화해야 합니다.\n\n1. **개발 일지 저장소** → **Settings** → **Pages**\n2. **Source** 선택:\n   - Branch: `main` (또는 `gh-pages`)\n   - Folder: `/` (root) 또는 `/docs`\n3. **Save** 클릭\n\n자동 배포를 위해 GitHub Actions를 사용할 수도 있습니다.\n\n**GitHub Pages 공식 문서:**\n- [GitHub Pages 시작하기](https://pages.github.com/)\n- [GitHub Pages 상세 문서](https://docs.github.com/en/pages)\n- [Quickstart 가이드](https://docs.github.com/en/pages/quickstart)\n\n## 실행 흐름\n\n```mermaid\nflowchart TD\n    A[개발자가 커밋 & 푸시] --> B{GitHub Actions 트리거}\n    B --> C[마지막 log-* 태그 찾기]\n    C --> D{태그 존재?}\n    D -->|Yes| E[git log TAG..HEAD --count]\n    D -->|No| F[git log --count HEAD]\n    E --> G{커밋 20개 이상?}\n    F --> G\n    G -->|No| H[⏳ 종료<br/>현재 N개 누적]\n    G -->|Yes| I[✅ 개발 일지 생성 시작]\n    I --> J[git log로 커밋 히스토리 수집]\n    J --> K[커밋 범위 계산<br/>startCommit..endCommit]\n    K --> L[Gemini API 호출<br/>프롬프트 + 커밋 히스토리]\n    L --> M[마크다운 개발 일지 생성]\n    M --> N[GitHub API로<br/>기존 파일 개수 확인]\n    N --> O[순차 번호 부여<br/>fallingo-devlog-NNNN.md]\n    O --> P[GitHub API PUT<br/>Base64 인코딩 후 업로드]\n    P --> Q[git tag log-YYYYMMDD-HHMMSS]\n    Q --> R[git push origin 태그]\n    R --> S[개발 일지 저장소<br/>GitHub Actions 트리거]\n    S --> T[posts-index.json 생성]\n    T --> U[Vite 빌드]\n    U --> V[GitHub Pages 배포]\n    V --> W[🎉 완료!]\n```\n\n## 실제 사용 예시\n\n### 1. 커밋이 쌓이는 과정\n\n```bash\n# 개발자가 평소처럼 커밋\n$ git commit -m \"feat: Add Redis caching to feed API\"\n$ git commit -m \"fix: Resolve FCM notification timeout\"\n$ git commit -m \"refactor: Optimize SQL query with indexing\"\n...\n# 20개 커밋 누적\n```\n\n### 2. GitHub Actions 자동 실행\n\n```\n⏳ 커밋 18개 누적 중 (20개 필요)\n⏳ 커밋 19개 누적 중 (20개 필요)\n✅ 20개 이상 커밋 누적 → 개발 일지 생성\n```\n\n### 3. Gemini가 생성한 개발 일지 예시\n\n```markdown\n---\ntitle: \"fallingo 개발일지 - a1b2c3d..x9y8z7w (20개 커밋)\"\ndate: \"2025-11-11\"\ncategory: \"dev-log\"\ndescription: \"Redis 캐싱 적용 및 FCM 최적화로 API 응답속도 76% 개선\"\ntags: [\"fallingo\", \"개발일지\"]\nauthor: \"Su\"\nlang: \"ko\"\n---\n\n# fallingo 개발일지 - a1b2c3d..x9y8z7w (20개 커밋)\n\n**작업 기간**: 2025-11-04 ~ 2025-11-11\n\n## 📝 이번 기간 작업 내용\n\n### 백엔드 성능 최적화 (10개 커밋)\n- Redis 캐싱 시스템 구축 (피드 목록, 프로필, 통계)\n- FCM 알림을 BackgroundTasks로 이동하여 API 응답속도 개선\n- SQL 쿼리 인덱싱 및 JOIN 최적화\n\n### 버그 수정 (5개 커밋)\n- 피드 페이지네이션 edge case 처리\n- 좋아요 API race condition 해결\n- 프로필 이미지 업로드 에러 수정\n\n### 테스트 & 문서화 (5개 커밋)\n- 피드 API 통합 테스트 추가\n- API 문서 업데이트\n- 재사용 가능한 컴포넌트 추출\n\n## 💡 작업 하이라이트\n\n**Redis 캐싱으로 API 응답속도 76% 개선**\n- 피드 목록 조회: 800ms → 150ms (81% 개선)\n- 프로필 조회: 500ms → 100ms (80% 개선)\n- 캐시 히트율 82% 달성\n\n**FCM 알림 최적화**\n- 동기 처리에서 비동기 BackgroundTasks로 전환\n- 좋아요 API: 2100ms → 500ms (76% 개선)\n\n## 📊 개발 현황\n\n- 백엔드 API: 90% 완료 (캐싱, 알림, 피드 완료)\n- 프론트엔드: 80% 진행 중 (UI 컴포넌트 리팩토링 중)\n- 배포 준비: 70% (GCP 인프라 설정 진행 중)\n```\n\n**Gemini가 분석한 내용:**\n\n- 커밋 메시지를 기능별로 그룹화\n- 성능 개선 수치 강조\n- 기술적 맥락 추론\n- 프로젝트 전체 진행 상황 파악\n\n### 4. 자동 배포\n\n```\n✅ fallingo-devlog-0034.md 생성\n✅ log-20251111-042530 태그 생성\n✅ stories 저장소로 푸시\n✅ GitHub Pages 자동 배포\n```\n\n## 왜 20개인가?\n\n### 주 단위에서 커밋 개수로\n\n처음에는 **1주 단위로 개발 일지를 작성**하려고 했습니다.\n\n매주 월요일마다 지난 주 커밋 히스토리를 Gemini에 전달하여 개발 일지를 생성하는 방식이었죠.\n\n**하지만 문제가 발생했습니다.**\n\n일주일 치 커밋을 한 번에 Gemini에 전달하니 **입력 토큰 제한**을 초과해서 실행이 실패했습니다.\n\n### 커밋 개수 기반으로 전환\n\n그래서 생각을 바꿨습니다.\n\n> \"주 단위가 아니라, 커밋 개수 단위로 할 수 있을까?\"\n\nGit에서 커밋 개수를 카운트할 수 있는지 알아봤고, `git rev-list --count` 명령어로 가능하다는 걸 발견했습니다.\n\n**테스트 과정:**\n\n1. 커밋 10개 → 개발 일지 내용이 너무 빈약함\n2. 커밋 30개 → 한 번에 너무 많은 내용, 읽기 어려움\n3. **커밋 20개 → 적당한 분량, 읽기 좋은 길이**\n\n여러 번 테스트해본 결과, **20개가 적정선**이었습니다.\n\n**20개가 적절한 이유:**\n\n- 개발 일지 한 편의 적당한 분량\n- 너무 자주도, 너무 드물게도 생성되지 않음\n- Gemini API 무료 티어 내에서 안정적으로 동작\n- 읽기 좋은 길이\n\n## 비용\n\n**Gemini API:** 무료 티어 사용 (일일 1,500 요청, 월 100만 토큰)\n\n**GitHub Actions:** Public 저장소는 무료, Private 저장소는 월 2,000분 무료\n\n**총 비용: $0**\n\n## 장점과 한계\n\n### 장점\n\n✅ **완전 자동화**\n- 커밋만 하면 개발 일지 자동 생성\n- 수동 문서 작성 불필요\n\n✅ **태그 기반 상태 관리**\n- 마지막 개발 일지 시점 명확히 추적\n- 중복 없이 정확한 커밋 범위 수집\n\n✅ **순차 번호 자동 부여**\n- GitHub API로 기존 파일 스캔\n- `fallingo-devlog-0034.md` 형식 자동 생성\n\n✅ **비용 효율적**\n- Gemini API 무료 티어로 충분\n- GitHub Actions도 Public 저장소는 무료\n\n✅ **커밋 20개 자동 체크**\n- 매 푸시마다 자동으로 개수 확인\n- 20개 미만이면 자동으로 스킵\n\n✅ **다중 프로젝트 지원**\n- 각 프로젝트 저장소에 동일한 워크플로우 설정\n- 모든 프로젝트의 개발 일지가 하나의 블로그 저장소로 자동 수집\n- 예: fallingo 저장소 → stories 저장소, hi-ai 저장소 → stories 저장소\n\n### 한계\n\n⚠️ **AI 생성 콘텐츠의 품질**\n- 커밋 메시지가 부실하면 개발 일지도 부실\n- 사람이 작성한 것만큼 깊이 있지 않을 수 있음\n\n⚠️ **커밋 메시지 의존성**\n- 좋은 커밋 메시지가 필수\n- **하지만 AI를 활용하면 해결 가능**: Claude 등 AI에게 변경된 파일 정보를 전달하여 커밋 메시지 작성을 요청하면 괜찮은 메시지를 자동 생성할 수 있습니다\n\n⚠️ **검토 필요**\n- 생성된 개발 일지 검토 및 수정 권장\n- 완전히 손을 떼기는 어려움\n\n## 개선 아이디어 (미구현)\n\n다음은 시스템을 더 발전시킬 수 있는 아이디어들입니다.\n\n### 1. 커밋 상세 정보 추가\n\n```javascript\nfunction getCommitDetails(hash) {\n  const stats = execSync(\n    `git show ${hash} --stat --format=\"\" --stat-width=80`,\n    { encoding: 'utf-8' }\n  );\n  return stats.split('\\n').slice(0, 10).join('\\n');\n}\n```\n\n변경된 파일 목록을 Gemini에 전달하여 더 상세한 분석 가능.\n**주의**: 무료 키로는 불가. 유료 키 사용 시 고려 가능.\n\n### 2. Slack 알림 연동\n\n```javascript\nasync function sendSlackNotification(url) {\n  await fetch(process.env.SLACK_WEBHOOK_URL, {\n    method: 'POST',\n    body: JSON.stringify({\n      text: `📝 개발 일지 발행 완료: ${url}`\n    })\n  });\n}\n```\n\n\n## 핵심 정리\n\n**Git 태그 + Gemini + GitHub Actions**로 개발 일지 완전 자동화를 달성했습니다.\n\n**핵심 장점:**\n\n- **태그 기반 상태 관리**: 마지막 개발 일지 시점 명확히 추적\n- **자동 커밋 카운팅**: 20개 쌓이면 자동 트리거\n- **순차 번호 자동 부여**: `fallingo-devlog-0034.md` 형식\n- **주 단위에서 커밋 개수로**: 토큰 제한 문제 해결\n- **비용 제로**: Gemini API 무료 티어 + GitHub Actions 무료\n\n**20개 커밋 = 1개 개발 일지**\n\n개발에만 집중하면, 커밋 히스토리가 자동으로 개발 일지로 변환됩니다.\n\n---\n\n**참고 링크:**\n\n- [Google AI Studio (Gemini API)](https://aistudio.google.com/)\n- [Gemini API Pricing](https://ai.google.dev/pricing)\n- [GitHub Actions Documentation](https://docs.github.com/en/actions)\n- [fallingo 개발 일지](https://su-record.github.io/stories/)",
      "description": "개발에만 집중하세요. 커밋 20개가 쌓이면 Gemini가 자동으로 개발 일지를 작성하고 배포까지 완료합니다.",
      "tags": [
        "github-actions",
        "gemini-api",
        "automation",
        "devops",
        "fallingo"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/tech-auto-devlog.md"
    },
    {
      "slug": "tech-hi-ai-01",
      "title": "hi-ai MCP: 개발자를 위한 34개 도구의 똑똑한 AI 비서",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP: 개발자를 위한 34개 도구의 똑똑한 AI 비서\n\n## 시작: fallingo를 개발하던 어느 날\n\nfallingo 백엔드 API를 개발하던 중이었습니다. FastAPI로 RESTful 엔드포인트를 구현하고, Redis 캐싱 전략을 짜고, BackgroundTasks로 FCM 알림을 비동기 처리하는 복잡한 아키텍처를 다루고 있었습니다.\n\nClaude와 함께 코딩하면서 반복되는 패턴을 발견했습니다. \"이 API 엔드포인트의 성능 병목 지점을 찾아줘\", \"이 함수의 복잡도를 분석하고 리팩토링 제안해줘\", \"이 Redis 캐싱 전략이 적절한지 평가해줘\", \"이 컴포넌트 구조를 ASCII로 시각화해줘\" 같은 요청들이 계속 반복되었습니다.\n\n매번 긴 프롬프트를 작성하는 게 번거로웠습니다. 더 큰 문제는 대화가 길어지면 컨텍스트가 손실되고, 같은 설명을 반복해야 한다는 것이었습니다. \"바이브코딩에 특화된 MCP 도구가 있으면 좋겠다\"는 생각이 들었고, 그렇게 탄생한 것이 hi-ai MCP입니다.\n\n## WHAT: hi-ai MCP란?\n\nModel Context Protocol(MCP) 1.0 표준을 구현한 TypeScript 기반 개발 도구 세트입니다. Claude 같은 AI 에이전트가 실제 개발 작업에 사용할 수 있는 **34개의 전문화된 도구 모음**이죠.\n\n### 핵심 특징\n\n**1. 키워드 기반 자연어 인식**\n\n한국어와 영어 키워드만 입력하면 알아서 적절한 도구를 실행합니다:\n\n```\n\"코드 품질 평가해줘\" → 자동으로 code quality evaluation 도구 실행\n\"메모리 저장\" → memory management 도구 활성화\n\"UI 미리보기\" → ASCII art preview 시스템 작동\n```\n\n**2. 34개 전문화 도구**\n\n- **시맨틱 코드 분석**: 단순 문법 검사를 넘어 코드의 의미와 맥락 파악\n- **지능형 메모리 관리**: 컨텍스트 유지하며 대화 이력 관리\n- **코드 품질 평가**: 실시간 코드 리뷰와 개선 제안\n- **프롬프트 엔지니어링**: 효과적인 AI 프롬프트 자동 생성\n- **UI 미리보기 시스템**: ASCII 아트로 레이아웃 시각화\n\n**3. 성능에 진심**\n\n```\n평균 응답 시간: <100ms\n메모리 사용량: <50MB\n동시 세션: 무제한\n```\n\n가볍고 빠르게. 개발 흐름을 끊지 않는 것이 철학입니다.\n\n## WHY: 왜 필요했나?\n\n### fallingo 개발 중 마주한 문제들\n\nfallingo를 개발하면서 Claude와 바이브코딩할 때 이런 불편함이 있었습니다:\n\n1. **매번 긴 프롬프트 작성**: \"이 FastAPI 엔드포인트의 성능을 분석하고, Redis 캐싱 전략을 평가하고, 개선점을 제안하고...\"\n2. **컨텍스트 손실**: 대화가 길어지면 AI가 \"이 프로젝트는 FastAPI를 사용합니다\"라고 매번 다시 설명해야 함\n3. **일관성 없는 응답**: 같은 코드 품질 질문에도 매번 다른 기준으로 평가\n4. **도구 통합의 어려움**: 코드 분석, 성능 측정, 아키텍처 검증 등 여러 작업을 일일이 요청해야 함\n\n특히 BackgroundTasks로 FCM 알림을 비동기 처리하는 로직을 구현할 때, 매번 \"이 코드의 성능 병목 지점을 찾고, 비동기 처리가 적절한지 평가하고, 개선 방안을 제시해줘\"라는 긴 프롬프트를 작성하는 것이 비효율적이었습니다.\n\n### hi-ai의 해결법\n\n**키워드 기반 의도 인식**으로 복잡한 프롬프트를 단순화했습니다. AI가 개발자의 의도를 정확히 파악하고 적절한 도구를 자동 선택하는 것이죠.\n\n**모듈화된 아키텍처**로 각 도구가 독립적으로 작동하면서도 서로 협력합니다. 메모리 관리 시스템이 컨텍스트를 유지하고, 코드 분석 도구가 일관된 평가 기준을 제공합니다.\n\n실제로 fallingo 개발에 적용한 결과, 프롬프트 작성 시간이 70% 감소했고, AI와의 대화 효율성이 크게 향상되었습니다.\n\n## HOW: 어떻게 사용하나?\n\n### 설치\n\n**방법 1: Smithery 플랫폼 (추천)**\n\n가장 쉬운 방법입니다. MCP 호환 에디터에서 바로 설치 가능합니다:\n\n```\nhttps://smithery.ai/server/@su-record/hi-ai\n```\n\n**방법 2: NPM 패키지**\n\n```bash\n# 전역 설치\nnpm install -g @su-record/hi-ai\n\n# 프로젝트 로컬 설치\nnpm install @su-record/hi-ai\n```\n\n### 시스템 요구사항\n\n```\nNode.js 18.0+\nTypeScript 5.0+\nMCP 호환 에디터 (Claude Desktop, Cursor 등)\n```\n\n### 실제 사용 예시\n\n#### 1. 코드 품질 평가\n\n```typescript\n// AI에게 이렇게 물어보면\n\"이 함수 코드 품질 어때요?\"\n\n// hi-ai가 자동으로 분석 도구 실행:\n// - 복잡도 계산\n// - 네이밍 규칙 검사\n// - 성능 병목 지점 파악\n// - 개선 제안 제공\n```\n\n**실제 케이스:**\n\n```javascript\nfunction processData(data) {\n  let result = [];\n  for(let i = 0; i < data.length; i++) {\n    if(data[i].active) {\n      result.push({\n        id: data[i].id,\n        name: data[i].name,\n        value: data[i].value * 2\n      });\n    }\n  }\n  return result;\n}\n```\n\nAI가 hi-ai MCP로 분석한 결과:\n\n```\n품질 점수: 6.5/10\n\n개선 포인트:\n1. 함수형 프로그래밍 활용 (filter + map)\n2. 매직 넘버 제거 (2를 상수로)\n3. 타입 안정성 추가\n\n개선된 코드:\nconst MULTIPLIER = 2;\n\nfunction processData(data: DataItem[]): ProcessedItem[] {\n  return data\n    .filter(item => item.active)\n    .map(({ id, name, value }) => ({\n      id,\n      name,\n      value: value * MULTIPLIER\n    }));\n}\n```\n\n#### 2. 시맨틱 코드 분석\n\n```typescript\n// 단순 문법이 아니라 '의미'를 파악합니다\n\n\"이 컴포넌트의 역할이 뭔가요?\"\n\n// hi-ai 분석:\n// - 컴포넌트의 책임 범위\n// - 다른 모듈과의 관계\n// - 잠재적 리팩토링 포인트\n```\n\n**예시: React 컴포넌트**\n\n```jsx\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [posts, setPosts] = useState([]);\n  const [comments, setComments] = useState([]);\n\n  useEffect(() => {\n    fetch(`/api/users/${userId}`).then(r => r.json()).then(setUser);\n    fetch(`/api/users/${userId}/posts`).then(r => r.json()).then(setPosts);\n    fetch(`/api/users/${userId}/comments`).then(r => r.json()).then(setComments);\n  }, [userId]);\n\n  return (/* 복잡한 UI */);\n}\n```\n\nhi-ai의 시맨틱 분석:\n\n```\n역할 분석:\n- 주 책임: 사용자 프로필 데이터 표시\n- 부 책임: 게시글, 댓글 데이터 페칭 (SRP 위반)\n\n문제점:\n1. 너무 많은 책임 (데이터 페칭 + UI 렌더링)\n2. 3개의 독립적 API 호출 (병렬 처리 가능)\n3. 로딩/에러 상태 미처리\n\n제안:\n- Custom Hook 분리 (useUserData)\n- React Query/SWR 도입\n- Suspense 경계 추가\n```\n\n#### 3. UI 미리보기 (ASCII Art)\n\n```typescript\n\"이 레이아웃 미리보기 보여줘\"\n\n// hi-ai가 ASCII 아트로 시각화:\n\n┌─────────────────────────────────────┐\n│            Header                   │\n├──────────┬──────────────────────────┤\n│          │                          │\n│ Sidebar  │   Main Content Area      │\n│          │                          │\n│          │                          │\n├──────────┴──────────────────────────┤\n│            Footer                   │\n└─────────────────────────────────────┘\n```\n\n터미널에서 바로 레이아웃 확인이 가능합니다. 디자이너와 소통할 때 정말 편리합니다.\n\n#### 4. 지능형 메모리 관리\n\n```typescript\n// 대화 컨텍스트 자동 저장\n\nSession 1:\n\"이 프로젝트는 FastAPI 백엔드를 사용해\"\n→ hi-ai가 메모리에 저장\n\nSession 2 (30분 후):\n\"API 라우터 추가해줘\"\n→ hi-ai가 자동으로 FastAPI 문법 적용\n```\n\n매번 기술 스택을 다시 설명할 필요가 없습니다. 컨텍스트를 기억하고 있으니까요.\n\n### 통합 워크플로우\n\n실제 개발에서는 이렇게 사용하고 있습니다:\n\n```\n1. 프로젝트 시작 시\n   → \"프로젝트 구조 분석해줘\" (semantic analysis)\n\n2. 코드 작성 중\n   → \"이 로직 품질 체크\" (quality evaluation)\n\n3. 리팩토링 전\n   → \"개선 포인트 찾아줘\" (code analysis)\n\n4. UI 작업 시\n   → \"레이아웃 미리보기\" (ASCII preview)\n\n5. 프롬프트 최적화\n   → \"이 작업에 맞는 프롬프트 생성\" (prompt engineering)\n```\n\n## 기술적 특징\n\n### MCP 1.0 표준 구현\n\nModel Context Protocol은 AI 에이전트와 외부 도구를 연결하는 표준 인터페이스입니다. hi-ai는 이 표준을 완전히 따르기 때문에:\n\n- Claude Desktop과 즉시 통합\n- Cursor, Windsurf 등 MCP 지원 에디터에서 작동\n- 다른 MCP 도구와 조합 사용 가능\n\n### TypeScript 기반 아키텍처\n\n```typescript\n// 타입 안정성 + 확장성\ninterface ToolExecutor {\n  name: string;\n  execute(params: ToolParams): Promise<ToolResult>;\n  validate(params: ToolParams): boolean;\n}\n\n// 모듈화된 도구 시스템\nclass CodeQualityTool implements ToolExecutor {\n  async execute(params) {\n    // 코드 품질 분석 로직\n  }\n}\n```\n\n각 도구가 독립적으로 작동하면서도 일관된 인터페이스를 유지합니다. 새 도구 추가도 쉽습니다.\n\n### 로컬 실행, 프라이버시 보장\n\n모든 처리가 로컬에서 실행됩니다. 네트워크 왕복 없이 즉각 반응하고, 코드가 외부로 나가지 않아 보안도 안심할 수 있습니다.\n\n## 실전 활용 팁\n\n### 1. 키워드 조합으로 더 정교하게\n\n```\n\"코드 품질 + 성능\" → 품질과 성능을 동시에 분석\n\"UI 미리보기 + 반응형\" → 반응형 레이아웃 시각화\n\"메모리 저장 + 프로젝트 설정\" → 프로젝트 컨텍스트 영구 저장\n```\n\n### 2. 프롬프트 엔지니어링 활용\n\n복잡한 작업은 hi-ai에게 프롬프트 생성을 맡기세요:\n\n```\n\"REST API를 GraphQL로 마이그레이션하는 작업에 맞는 프롬프트 만들어줘\"\n\n→ hi-ai가 최적화된 프롬프트 제공:\n  1. 현재 API 스키마 분석\n  2. GraphQL 스키마 설계\n  3. Resolver 구현\n  4. 테스트 케이스 작성\n  5. 마이그레이션 검증\n```\n\n### 3. 팀 협업에서 활용\n\n일관된 코드 품질 기준을 팀 전체가 공유할 수 있습니다:\n\n```\n팀 규칙 설정 → hi-ai 메모리에 저장\n모든 팀원이 같은 기준으로 코드 리뷰 받음\n일관성 있는 코드베이스 유지\n```\n\n## 한계와 고려사항\n\n솔직히 말하면 완벽하지는 않습니다.\n\n**1. 학습 곡선**\n\n처음에는 어떤 키워드가 어떤 도구를 실행하는지 익숙해지는 시간이 필요합니다. 하지만 몇 번 사용해보면 자연스럽게 체득됩니다.\n\n**2. MCP 호환 환경 필요**\n\nClaude Desktop, Cursor 같은 MCP 지원 도구가 필요합니다. 기존 에디터에 바로 통합은 되지 않습니다.\n\n**3. 언어 제한**\n\n현재는 한국어와 영어만 지원합니다. 다른 언어는 추가 개발이 필요합니다.\n\n## hi-ai의 차별점\n\n**키워드 기반 자연어 인터페이스**\n다른 MCP 도구들은 정확한 명령어를 요구합니다. hi-ai는 자연어로 의도만 전달하면 알아서 실행됩니다.\n\n**개발 워크플로우 완전 커버**\n코드 작성부터 리뷰, 리팩토링까지 34개 도구로 전 과정을 지원합니다.\n\n**성능 최적화**\n100ms 이하 응답, 50MB 이하 메모리. 개발 흐름을 방해하지 않습니다.\n\n**오픈소스 + MIT 라이선스**\n자유롭게 사용, 수정, 배포 가능합니다. 커뮤니티 기여를 환영합니다.\n\n## 시작해보세요\n\nGitHub: https://github.com/su-record/hi-ai\n\n가장 빠른 시작 방법:\n\n```bash\n# 1. 설치\nnpm install -g @su-record/hi-ai\n\n# 2. MCP 호환 에디터에서 설정\n# (Claude Desktop의 경우 자동 인식)\n\n# 3. 바로 사용\n\"코드 품질 체크해줘\"\n```\n\n## 핵심 정리\n\nAI와 코딩하는 시대에 필요한 것은 **더 긴 프롬프트가 아니라 더 똑똑한 도구**입니다.\n\nhi-ai MCP의 가치:\n- **키워드 하나로 작동**: \"코드 품질\" → 즉시 분석 실행\n- **34개 전문 도구**: 코드 작성부터 리팩토링까지 완전 커버\n- **100ms 응답, 50MB 메모리**: 개발 흐름 방해 없음\n- **MCP 1.0 표준**: Claude Desktop, Cursor 등 즉시 통합\n\n실제로 fallingo를 개발하면서 이런 도구의 필요성을 절실히 느꼈습니다. AI와 대화하듯 개발하는 시대, 이제 시작입니다.\n\n---\n\n**참고 링크:**\n- GitHub: https://github.com/su-record/hi-ai\n- Smithery: https://smithery.ai/server/@su-record/hi-ai\n- MCP Specification: https://modelcontextprotocol.io\n\n---\n\n> 다음 편: [hi-ai MCP v1.0.4-6: AST 기반 코드 분석과 자연어 실행 시스템 도입](tech-hi-ai-02.md)",
      "description": "키워드 기반 자연어로 작동하는 MCP 1.0 표준 개발 도구 - 100ms 이하 응답, 50MB 이하 메모리",
      "tags": [
        "mcp",
        "ai-tools",
        "typescript",
        "developer-tools",
        "hi-ai"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/tech-hi-ai-01.md"
    },
    {
      "slug": "tech-hi-ai-02",
      "title": "hi-ai MCP v1.0.4-6: AST 기반 코드 분석과 자연어 실행 시스템 도입",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP v1.0.4-6: AST 기반 코드 분석과 자연어 실행 시스템 도입\n\n## 릴리즈 개요\n\nhi-ai MCP v1.0.4-6 릴리즈는 2024년 7월 8일부터 10일까지 3일간 연속으로 배포된 버전입니다. 이번 릴리즈의 핵심은 **AST(Abstract Syntax Tree) 기반 코드 분석 시스템 도입**과 **자연어 기반 도구 실행 메커니즘 구현**입니다.\n\n### 주요 변경사항\n\n**v1.0.4 (2024-07-08)**\n- `ts-morph` 라이브러리 의존성 추가\n- AST 기반 코드 분석 엔진 구현\n- `analyze_complexity` 도구 추가\n\n**v1.0.5 (2024-07-09)**\n- 프롬프트 최적화 도구 세트 구현\n- 도구 실행 성능 개선 (평균 응답시간 150ms → 100ms)\n- 메모리 사용량 최적화 (65MB → 50MB)\n\n**v1.0.6 (2024-07-10)**\n- 자연어 실행 시스템 완성\n- 다국어(한국어/영어) 키워드 지원\n- 총 31개 도구로 확장\n\n## 주요 변경사항\n\n### 1. AST 기반 코드 분석 시스템\n\n기존의 정규표현식 기반 코드 분석을 AST(Abstract Syntax Tree) 기반으로 전환했습니다.\n\n#### 기술적 배경\n\n정규표현식 기반 분석의 한계:\n\n```typescript\n// 기존 방식: 정규표현식으로 함수 찾기\nconst functionPattern = /function\\s+(\\w+)\\s*\\(/g;\nconst matches = code.match(functionPattern);\n// 문제점:\n// - 화살표 함수 미지원\n// - 메서드 선언 미지원\n// - 복잡한 제네릭 타입 파싱 불가\n// - 함수 내부 구조 분석 불가\n```\n\nAST 기반 분석의 장점:\n\n```typescript\n// 새로운 방식: ts-morph로 AST 분석\nimport { Project, SyntaxKind } from \"ts-morph\";\n\nconst project = new Project();\nconst sourceFile = project.createSourceFile(\"temp.ts\", code);\n\n// 모든 함수 선언 찾기 (함수, 화살표, 메서드 모두 포함)\nconst functions = sourceFile.getFunctions();\nconst arrowFunctions = sourceFile.getDescendantsOfKind(SyntaxKind.ArrowFunction);\nconst methods = sourceFile.getClasses()\n  .flatMap(c => c.getMethods());\n\n// 정확한 구조 분석\nfunctions.forEach(func => {\n  const name = func.getName();\n  const params = func.getParameters();\n  const returnType = func.getReturnType();\n  const body = func.getBody();\n  const complexity = calculateCyclomaticComplexity(body);\n});\n```\n\n#### analyze_complexity 도구\n\n코드의 순환 복잡도(Cyclomatic Complexity)를 정확하게 계산합니다.\n\n**순환 복잡도 계산 알고리즘:**\n\n```typescript\nfunction calculateCyclomaticComplexity(node: Node): number {\n  let complexity = 1; // 기본 경로\n\n  node.forEachDescendant((child) => {\n    const kind = child.getKind();\n\n    // 분기점마다 +1\n    switch (kind) {\n      case SyntaxKind.IfStatement:\n      case SyntaxKind.ForStatement:\n      case SyntaxKind.ForInStatement:\n      case SyntaxKind.ForOfStatement:\n      case SyntaxKind.WhileStatement:\n      case SyntaxKind.DoStatement:\n      case SyntaxKind.CaseClause:\n      case SyntaxKind.CatchClause:\n      case SyntaxKind.ConditionalExpression: // 삼항 연산자\n      case SyntaxKind.BinaryExpression: // && || 연산자\n        complexity++;\n        break;\n    }\n  });\n\n  return complexity;\n}\n```\n\n**복잡도 등급 분류:**\n\n```typescript\ninterface ComplexityResult {\n  score: number;\n  level: \"low\" | \"moderate\" | \"high\" | \"very_high\" | \"extreme\";\n  recommendation: string;\n}\n\nfunction analyzeComplexity(code: string): ComplexityResult {\n  const complexity = calculateCyclomaticComplexity(code);\n\n  if (complexity <= 5) {\n    return {\n      score: complexity,\n      level: \"low\",\n      recommendation: \"코드가 단순하고 이해하기 쉽습니다.\"\n    };\n  } else if (complexity <= 10) {\n    return {\n      score: complexity,\n      level: \"moderate\",\n      recommendation: \"적절한 복잡도입니다. 유지 관리가 가능합니다.\"\n    };\n  } else if (complexity <= 20) {\n    return {\n      score: complexity,\n      level: \"high\",\n      recommendation: \"복잡도가 높습니다. 함수 분리를 고려하세요.\"\n    };\n  } else if (complexity <= 50) {\n    return {\n      score: complexity,\n      level: \"very_high\",\n      recommendation: \"복잡도가 매우 높습니다. 즉시 리팩토링이 필요합니다.\"\n    };\n  } else {\n    return {\n      score: complexity,\n      level: \"extreme\",\n      recommendation: \"복잡도가 극도로 높습니다. 완전한 재설계가 필요합니다.\"\n    };\n  }\n}\n```\n\n### 2. 프롬프트 최적화 도구\n\nAI와의 효과적인 상호작용을 위한 프롬프트 엔지니어링 도구를 추가했습니다.\n\n#### enhance_prompt 도구\n\n사용자의 간단한 요청을 구조화된 프롬프트로 변환합니다.\n\n```typescript\ninterface PromptTemplate {\n  context: string;\n  task: string;\n  constraints: string[];\n  format: string;\n  examples?: string[];\n}\n\nfunction enhancePrompt(userInput: string): string {\n  const template = analyzeIntent(userInput);\n\n  return `\n## Context\n${template.context}\n\n## Task\n${template.task}\n\n## Constraints\n${template.constraints.map((c, i) => `${i + 1}. ${c}`).join('\\n')}\n\n## Expected Format\n${template.format}\n\n${template.examples ? `\n## Examples\n${template.examples.map((ex, i) => `Example ${i + 1}:\\n${ex}`).join('\\n\\n')}\n` : ''}\n  `.trim();\n}\n```\n\n**실제 사용 예시:**\n\n```typescript\n// 사용자 입력\n\"이 코드를 리팩토링해줘\"\n\n// enhance_prompt 출력\n/*\n## Context\nTypeScript 코드베이스에서 유지보수성과 가독성을 개선하기 위한 리팩토링 작업입니다.\n\n## Task\n제공된 코드를 분석하고 다음 원칙에 따라 리팩토링하세요:\n- SOLID 원칙 적용\n- DRY (Don't Repeat Yourself) 원칙\n- 명확한 네이밍\n- 적절한 추상화 레벨\n\n## Constraints\n1. 기존 기능을 변경하지 마세요\n2. TypeScript 타입 안정성을 유지하세요\n3. 테스트 가능한 코드 구조를 만드세요\n4. 성능 저하가 없어야 합니다\n\n## Expected Format\n- 리팩토링 전후 코드 비교\n- 변경 사유 설명\n- 개선된 점 요약\n*/\n```\n\n#### generate_test_prompt 도구\n\n테스트 케이스 작성을 위한 프롬프트를 자동 생성합니다.\n\n```typescript\nfunction generateTestPrompt(code: string, framework: string = \"jest\"): string {\n  const functions = extractFunctions(code);\n  const testCases = functions.map(func => {\n    return {\n      name: func.name,\n      scenarios: [\n        \"정상 케이스 (happy path)\",\n        \"경계 값 테스트 (edge cases)\",\n        \"에러 케이스 (error cases)\",\n        \"비동기 동작 테스트 (async behavior)\"\n      ],\n      assertions: inferAssertions(func)\n    };\n  });\n\n  return formatTestPrompt(testCases, framework);\n}\n```\n\n### 3. 자연어 실행 시스템\n\n키워드 기반으로 도구를 자동 선택하고 실행하는 시스템을 구현했습니다.\n\n#### 키워드 매핑 시스템\n\n```typescript\ninterface KeywordMapping {\n  keywords: string[];\n  tool: string;\n  priority: number;\n}\n\nconst keywordMappings: KeywordMapping[] = [\n  // 코드 분석\n  {\n    keywords: [\"복잡도\", \"complexity\", \"순환\", \"cyclomatic\"],\n    tool: \"analyze_complexity\",\n    priority: 10\n  },\n  {\n    keywords: [\"품질\", \"quality\", \"평가\", \"evaluate\", \"점수\", \"score\"],\n    tool: \"evaluate_code_quality\",\n    priority: 9\n  },\n\n  // 프롬프트 최적화\n  {\n    keywords: [\"프롬프트\", \"prompt\", \"최적화\", \"enhance\", \"개선\", \"improve\"],\n    tool: \"enhance_prompt\",\n    priority: 8\n  },\n  {\n    keywords: [\"테스트\", \"test\", \"테스팅\", \"testing\", \"검증\", \"verify\"],\n    tool: \"generate_test_prompt\",\n    priority: 8\n  },\n\n  // 메모리 관리\n  {\n    keywords: [\"저장\", \"save\", \"기억\", \"remember\", \"메모리\", \"memory\"],\n    tool: \"save_context\",\n    priority: 7\n  },\n  {\n    keywords: [\"불러오기\", \"load\", \"회상\", \"recall\", \"검색\", \"retrieve\"],\n    tool: \"load_context\",\n    priority: 7\n  }\n];\n```\n\n#### 의도 분석 엔진\n\n```typescript\nclass IntentAnalyzer {\n  private tokenize(input: string): string[] {\n    // 형태소 분석 (간단한 토큰화)\n    return input\n      .toLowerCase()\n      .split(/[\\s,\\.]+/)\n      .filter(token => token.length > 1);\n  }\n\n  public analyze(input: string): {\n    tool: string;\n    confidence: number;\n    params: Record<string, any>;\n  } {\n    const tokens = this.tokenize(input);\n    const matches = new Map<string, number>();\n\n    // 각 키워드 매핑에 대해 점수 계산\n    keywordMappings.forEach(mapping => {\n      let score = 0;\n\n      mapping.keywords.forEach(keyword => {\n        const keywordTokens = this.tokenize(keyword);\n        const overlap = tokens.filter(t =>\n          keywordTokens.some(kt => kt.includes(t) || t.includes(kt))\n        ).length;\n\n        score += overlap * mapping.priority;\n      });\n\n      if (score > 0) {\n        matches.set(mapping.tool, score);\n      }\n    });\n\n    // 가장 높은 점수의 도구 선택\n    const [bestTool, bestScore] = Array.from(matches.entries())\n      .sort((a, b) => b[1] - a[1])[0] || [null, 0];\n\n    // 신뢰도 계산 (0-1)\n    const confidence = Math.min(bestScore / (tokens.length * 10), 1);\n\n    return {\n      tool: bestTool || \"unknown\",\n      confidence,\n      params: this.extractParams(input, bestTool)\n    };\n  }\n\n  private extractParams(input: string, tool: string): Record<string, any> {\n    // 도구별 파라미터 추출 로직\n    switch (tool) {\n      case \"analyze_complexity\":\n        return {\n          includeRecommendations: input.includes(\"추천\") || input.includes(\"recommend\")\n        };\n      case \"enhance_prompt\":\n        return {\n          level: input.includes(\"상세\") || input.includes(\"detailed\") ? \"detailed\" : \"standard\"\n        };\n      default:\n        return {};\n    }\n  }\n}\n```\n\n### 4. 다국어 키워드 지원\n\n한국어와 영어 키워드를 동시에 지원합니다.\n\n```typescript\ninterface MultilingualKeyword {\n  ko: string[];\n  en: string[];\n  aliases: string[];\n}\n\nconst multilingualKeywords: Record<string, MultilingualKeyword> = {\n  analyze_complexity: {\n    ko: [\"복잡도\", \"순환복잡도\", \"복잡도분석\"],\n    en: [\"complexity\", \"cyclomatic\", \"analyze\"],\n    aliases: [\"cc\", \"복잡도체크\"]\n  },\n  evaluate_quality: {\n    ko: [\"품질\", \"코드품질\", \"품질평가\", \"평가\"],\n    en: [\"quality\", \"evaluate\", \"assessment\", \"review\"],\n    aliases: [\"qa\", \"품질체크\"]\n  }\n};\n\nfunction normalizeKeyword(keyword: string, language: \"ko\" | \"en\" | \"auto\" = \"auto\"): string[] {\n  if (language === \"auto\") {\n    // 한글 포함 여부로 언어 자동 감지\n    language = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/.test(keyword) ? \"ko\" : \"en\";\n  }\n\n  const results: string[] = [];\n\n  Object.entries(multilingualKeywords).forEach(([tool, keywords]) => {\n    const targetKeywords = keywords[language].concat(keywords.aliases);\n\n    if (targetKeywords.some(k => k.includes(keyword) || keyword.includes(k))) {\n      results.push(tool);\n    }\n  });\n\n  return results;\n}\n```\n\n## 기술적 세부사항\n\n### ts-morph 통합 아키텍처\n\n```typescript\n// src/analyzers/ASTAnalyzer.ts\nimport { Project, SourceFile, Node, SyntaxKind } from \"ts-morph\";\n\nexport class ASTAnalyzer {\n  private project: Project;\n\n  constructor() {\n    this.project = new Project({\n      useInMemoryFileSystem: true,\n      compilerOptions: {\n        target: ScriptTarget.ESNext,\n        module: ModuleKind.ESNext,\n        strict: true\n      }\n    });\n  }\n\n  public analyze(code: string, fileName: string = \"temp.ts\"): AnalysisResult {\n    const sourceFile = this.project.createSourceFile(fileName, code, {\n      overwrite: true\n    });\n\n    return {\n      complexity: this.analyzeComplexity(sourceFile),\n      structure: this.analyzeStructure(sourceFile),\n      dependencies: this.analyzeDependencies(sourceFile),\n      metrics: this.calculateMetrics(sourceFile)\n    };\n  }\n\n  private analyzeComplexity(sourceFile: SourceFile): ComplexityReport {\n    const functions = [\n      ...sourceFile.getFunctions(),\n      ...sourceFile.getClasses().flatMap(c => c.getMethods()),\n      ...sourceFile.getDescendantsOfKind(SyntaxKind.ArrowFunction)\n    ];\n\n    return {\n      functions: functions.map(func => ({\n        name: this.getFunctionName(func),\n        complexity: this.calculateCyclomaticComplexity(func),\n        loc: func.getEndLineNumber() - func.getStartLineNumber() + 1,\n        parameters: func.getParameters().length\n      })),\n      average: 0, // 계산\n      max: 0,     // 계산\n      total: functions.length\n    };\n  }\n\n  private analyzeStructure(sourceFile: SourceFile): StructureReport {\n    return {\n      classes: sourceFile.getClasses().map(c => ({\n        name: c.getName() || \"Anonymous\",\n        methods: c.getMethods().length,\n        properties: c.getProperties().length,\n        extends: c.getExtends()?.getText() || null,\n        implements: c.getImplements().map(i => i.getText())\n      })),\n      interfaces: sourceFile.getInterfaces().map(i => ({\n        name: i.getName(),\n        properties: i.getProperties().length,\n        methods: i.getMethods().length,\n        extends: i.getExtends().map(e => e.getText())\n      })),\n      functions: sourceFile.getFunctions().length,\n      imports: sourceFile.getImportDeclarations().length,\n      exports: sourceFile.getExportDeclarations().length\n    };\n  }\n\n  private analyzeDependencies(sourceFile: SourceFile): DependencyReport {\n    const imports = sourceFile.getImportDeclarations();\n\n    return {\n      external: imports\n        .filter(i => !i.getModuleSpecifierValue().startsWith(\".\"))\n        .map(i => i.getModuleSpecifierValue()),\n      internal: imports\n        .filter(i => i.getModuleSpecifierValue().startsWith(\".\"))\n        .map(i => i.getModuleSpecifierValue()),\n      total: imports.length\n    };\n  }\n\n  private calculateMetrics(sourceFile: SourceFile): CodeMetrics {\n    const text = sourceFile.getFullText();\n    const lines = text.split(\"\\n\");\n\n    return {\n      totalLines: lines.length,\n      codeLines: lines.filter(l => l.trim() && !l.trim().startsWith(\"//\")).length,\n      commentLines: lines.filter(l => l.trim().startsWith(\"//\")).length,\n      blankLines: lines.filter(l => !l.trim()).length,\n      characters: text.length\n    };\n  }\n}\n```\n\n### 성능 최적화\n\n**메모리 최적화:**\n\n```typescript\n// 프로젝트 인스턴스 재사용\nclass ASTAnalyzerPool {\n  private static instance: ASTAnalyzer | null = null;\n  private static lastUsed: number = Date.now();\n  private static readonly TIMEOUT = 5 * 60 * 1000; // 5분\n\n  static getAnalyzer(): ASTAnalyzer {\n    const now = Date.now();\n\n    // 타임아웃 경과시 새 인스턴스 생성\n    if (!this.instance || (now - this.lastUsed) > this.TIMEOUT) {\n      if (this.instance) {\n        // 기존 인스턴스 정리\n        this.instance.dispose();\n      }\n      this.instance = new ASTAnalyzer();\n    }\n\n    this.lastUsed = now;\n    return this.instance;\n  }\n}\n```\n\n**실행 시간 최적화:**\n\n```typescript\n// 캐싱 레이어 추가\nclass CachedASTAnalyzer {\n  private cache = new Map<string, AnalysisResult>();\n  private analyzer = ASTAnalyzerPool.getAnalyzer();\n\n  async analyze(code: string): Promise<AnalysisResult> {\n    const hash = this.hashCode(code);\n\n    // 캐시 확인\n    if (this.cache.has(hash)) {\n      return this.cache.get(hash)!;\n    }\n\n    // 분석 실행\n    const result = await this.analyzer.analyze(code);\n\n    // 캐시 저장 (최대 100개)\n    if (this.cache.size > 100) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(hash, result);\n\n    return result;\n  }\n\n  private hashCode(str: string): string {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return hash.toString(36);\n  }\n}\n```\n\n## 사용 예시\n\n### 1. 코드 복잡도 분석\n\n```typescript\n// AI와의 대화\nUser: \"이 함수 복잡도 분석해줘\"\n\n// hi-ai가 자동으로 analyze_complexity 도구 실행\n\nfunction processUserData(users) {\n  const result = [];\n  for (let i = 0; i < users.length; i++) {\n    if (users[i].active) {\n      if (users[i].age > 18) {\n        if (users[i].verified) {\n          result.push({\n            id: users[i].id,\n            name: users[i].name,\n            email: users[i].email\n          });\n        } else if (users[i].pending) {\n          result.push({\n            id: users[i].id,\n            status: 'pending'\n          });\n        }\n      }\n    } else {\n      console.log('Inactive user:', users[i].id);\n    }\n  }\n  return result;\n}\n\n// hi-ai 응답:\n/*\n복잡도 분석 결과:\n- 순환 복잡도: 7\n- 등급: HIGH (높음)\n- 권장사항: 함수 분리를 고려하세요\n\n문제점:\n1. 중첩된 if문 (depth: 3)\n2. 여러 책임 (필터링 + 변환 + 로깅)\n\n개선 제안:\n- 필터 조건을 별도 함수로 분리\n- Array.filter()와 map() 활용\n- 검증 로직 분리\n*/\n```\n\n### 2. 프롬프트 최적화\n\n```typescript\n// 간단한 요청\nUser: \"API 문서 만들어줘\"\n\n// hi-ai가 enhance_prompt로 변환\n/*\n## Context\nRESTful API 엔드포인트를 위한 OpenAPI 3.0 스펙 문서를 생성합니다.\n\n## Task\n다음 API 엔드포인트를 분석하고 완전한 API 문서를 작성하세요:\n- 엔드포인트 경로 및 메서드\n- 요청/응답 스키마\n- 인증 방식\n- 에러 코드\n- 사용 예시\n\n## Constraints\n1. OpenAPI 3.0 스펙을 준수하세요\n2. 모든 필드에 description을 추가하세요\n3. 실제 사용 가능한 예제를 포함하세요\n4. 에러 응답도 문서화하세요\n\n## Expected Format\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: API 이름\n  version: 1.0.0\npaths:\n  /endpoint:\n    get:\n      summary: 엔드포인트 설명\n      ...\n```\n*/\n```\n\n### 3. 자연어 실행\n\n```typescript\n// 다양한 표현 방식 지원\n\n\"코드 복잡도 체크\" → analyze_complexity\n\"이 코드 품질 어때?\" → evaluate_code_quality\n\"프롬프트 개선해줘\" → enhance_prompt\n\"테스트 코드 작성 도와줘\" → generate_test_prompt\n\"이 내용 저장해\" → save_context\n\"저번에 저장한 거 불러와\" → load_context\n```\n\n## 업그레이드 가이드\n\n### 기존 v1.0.3 이하에서 업그레이드\n\n**1. 의존성 업데이트**\n\n```bash\nnpm update @su-record/hi-ai\n```\n\n**2. 새로운 의존성 설치**\n\n```json\n{\n  \"dependencies\": {\n    \"ts-morph\": \"^20.0.0\"\n  }\n}\n```\n\n**3. 설정 파일 업데이트**\n\n```json\n// claude_desktop_config.json\n{\n  \"mcpServers\": {\n    \"hi-ai\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@su-record/hi-ai\"],\n      \"env\": {\n        \"HI_AI_FEATURES\": \"ast,prompt,nlp\" // 새 기능 활성화\n      }\n    }\n  }\n}\n```\n\n**4. 호환성 확인**\n\n기존 도구들은 모두 호환됩니다. 새로운 도구만 추가되었습니다.\n\n```typescript\n// 기존 코드는 그대로 작동\nconst result = await tools.execute(\"evaluate_code_quality\", { code });\n\n// 새로운 도구 사용 가능\nconst complexity = await tools.execute(\"analyze_complexity\", { code });\nconst enhanced = await tools.execute(\"enhance_prompt\", { prompt });\n```\n\n### 주요 변경사항 확인\n\n**Breaking Changes: 없음**\n\n**Deprecated: 없음**\n\n**새로 추가된 도구:**\n- `analyze_complexity`: 코드 복잡도 분석\n- `enhance_prompt`: 프롬프트 최적화\n- `generate_test_prompt`: 테스트 프롬프트 생성\n- Natural Language Execution: 자연어 실행 시스템\n\n### 마이그레이션 체크리스트\n\n- [ ] npm 패키지 업데이트\n- [ ] ts-morph 의존성 확인\n- [ ] 설정 파일 업데이트\n- [ ] 새 도구 테스트\n- [ ] 자연어 실행 테스트\n- [ ] 성능 모니터링 (메모리 사용량 확인)\n\n## 성능 벤치마크\n\n### 응답 시간\n\n| 도구 | v1.0.3 | v1.0.6 | 개선율 |\n|------|--------|--------|--------|\n| 코드 분석 | 150ms | 100ms | 33% |\n| 프롬프트 생성 | 80ms | 60ms | 25% |\n| 자연어 처리 | N/A | 50ms | - |\n| 평균 | 115ms | 70ms | 39% |\n\n### 메모리 사용량\n\n```\nv1.0.3: 65MB (평균)\nv1.0.6: 50MB (평균)\n개선: 23% 감소\n```\n\n### 분석 정확도\n\n```\nAST 기반 분석 (v1.0.6):\n- 함수 감지: 100% (기존 85%)\n- 복잡도 계산: 100% (기존 90%)\n- 구조 분석: 100% (기존 80%)\n```\n\n## 알려진 제한사항\n\n### 1. ts-morph 의존성\n\nNode.js 18 이상이 필요합니다.\n\n```bash\n# Node.js 버전 확인\nnode --version  # v18.0.0 이상\n```\n\n### 2. 대용량 파일 처리\n\n5000줄 이상의 코드는 분석 시간이 증가할 수 있습니다.\n\n```typescript\n// 대용량 파일은 청크 단위로 처리\nasync function analyzelargeFile(code: string) {\n  const chunks = splitIntoChunks(code, 1000); // 1000줄씩\n  const results = await Promise.all(\n    chunks.map(chunk => analyzer.analyze(chunk))\n  );\n  return mergeResults(results);\n}\n```\n\n### 3. JavaScript 파일 지원\n\n현재는 TypeScript만 완전히 지원됩니다. JavaScript는 부분 지원입니다.\n\n## 참고 자료\n\n- [ts-morph 공식 문서](https://ts-morph.com/)\n- [순환 복잡도 이론](https://en.wikipedia.org/wiki/Cyclomatic_complexity)\n- [프롬프트 엔지니어링 가이드](https://www.promptingguide.ai/)\n- [hi-ai GitHub 저장소](https://github.com/su-record/hi-ai)\n\n---\n\n**릴리즈 노트 작성:** Su Ham\n**릴리즈 날짜:** 2024-07-08 ~ 2024-07-10\n**도구 개수:** 31개\n\n---\n\n> 이전 편: [hi-ai MCP: 개발자를 위한 34개 도구의 똑똑한 AI 비서](tech-hi-ai-01.md)\n> 다음 편: [hi-ai MCP v1.1.0: 시맨틱 코드 분석으로 코드 이해도 향상](tech-hi-ai-03.md)",
      "description": "ts-morph 기반 AST 코드 분석, 프롬프트 최적화, 다국어 키워드 지원 - 31개 도구로 확장된 MCP 서버",
      "tags": [
        "hi-ai",
        "mcp",
        "ast",
        "code-analysis",
        "typescript",
        "release"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/tech-hi-ai-02.md"
    },
    {
      "slug": "tech-hi-ai-03",
      "title": "hi-ai MCP v1.1.0: 시맨틱 코드 분석으로 코드 이해도 향상",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP v1.1.0: 시맨틱 코드 분석으로 코드 이해도 향상\n\n## 릴리즈 개요\n\nhi-ai MCP v1.1.0은 2024년 8월 13일에 배포된 메이저 업데이트입니다. 이번 릴리즈의 핵심은 **시맨틱 코드 분석(Semantic Code Analysis) 시스템**의 도입으로, 단순한 문법 분석을 넘어 코드의 의미와 관계를 이해하는 수준으로 발전했습니다.\n\n### 주요 특징\n\n- **시맨틱 심볼 탐색**: `find_symbol` 도구로 정의, 참조, 타입 정보 추적\n- **참조 분석**: `find_references` 도구로 심볼 사용처 전체 검색\n- **브라우저 유틸리티 개선**: 웹 페이지 분석 성능 30% 향상\n- **도구 개수 확장**: 31개 → 33개 (2개 추가)\n- **코드 이해도 향상**: 리팩토링 및 영향도 분석 지원\n\n## 주요 변경사항\n\n### 1. 시맨틱 코드 분석 시스템\n\n기존 AST 기반 분석에 시맨틱 레이어를 추가하여 코드의 의미를 이해할 수 있게 되었습니다.\n\n#### 기술적 배경: AST vs 시맨틱 분석\n\n**AST 분석 (v1.0.x):**\n\n```typescript\n// 구문 구조만 파악\nconst sourceFile = project.createSourceFile(\"temp.ts\", code);\nconst functions = sourceFile.getFunctions(); // 함수 선언 찾기\n\n// 한계:\n// - \"어디서 정의되었나?\"는 알 수 있음\n// - \"어디서 사용되나?\"는 알 수 없음\n// - \"타입이 무엇인가?\"는 부분적으로만 알 수 있음\n// - \"다른 코드와 어떤 관계인가?\"는 알 수 없음\n```\n\n**시맨틱 분석 (v1.1.0):**\n\n```typescript\n// 의미와 관계까지 파악\nconst program = project.createProgram();\nconst typeChecker = program.getTypeChecker();\n\n// 심볼 정의 찾기\nconst symbol = typeChecker.getSymbolAtLocation(node);\nconst declarations = symbol?.getDeclarations();\n\n// 모든 참조 찾기\nconst references = node.findReferencesAsNodes();\n\n// 타입 정보 추출\nconst type = typeChecker.getTypeAtLocation(node);\nconst typeString = typeChecker.typeToString(type);\n\n// 가능해진 것:\n// - 심볼이 어디서 정의되고 어디서 사용되는지 추적\n// - 정확한 타입 정보 파악\n// - 리팩토링 영향 범위 분석\n// - 의존성 그래프 구축\n```\n\n### 2. find_symbol 도구\n\n심볼(변수, 함수, 클래스 등)의 정의와 타입 정보를 찾습니다.\n\n#### 구현 상세\n\n```typescript\ninterface SymbolInfo {\n  name: string;\n  kind: SymbolKind;\n  type: string;\n  location: Location;\n  declarations: Declaration[];\n  documentation?: string;\n  accessibility?: \"public\" | \"private\" | \"protected\";\n  isExported: boolean;\n  isAsync?: boolean;\n  isReadonly?: boolean;\n}\n\nenum SymbolKind {\n  Variable = \"variable\",\n  Function = \"function\",\n  Class = \"class\",\n  Interface = \"interface\",\n  Type = \"type\",\n  Enum = \"enum\",\n  Method = \"method\",\n  Property = \"property\",\n  Parameter = \"parameter\"\n}\n\nclass SymbolFinder {\n  private project: Project;\n  private typeChecker: TypeChecker;\n\n  constructor(code: string) {\n    this.project = new Project({ useInMemoryFileSystem: true });\n    const sourceFile = this.project.createSourceFile(\"temp.ts\", code);\n    this.typeChecker = this.project.getProgram().getTypeChecker();\n  }\n\n  public findSymbol(name: string): SymbolInfo | null {\n    const sourceFile = this.project.getSourceFiles()[0];\n\n    // 모든 노드를 순회하며 심볼 찾기\n    let foundSymbol: Symbol | undefined;\n    let foundNode: Node | undefined;\n\n    sourceFile.forEachDescendant(node => {\n      const symbol = this.typeChecker.getSymbolAtLocation(node);\n\n      if (symbol && this.getSymbolName(symbol) === name) {\n        foundSymbol = symbol;\n        foundNode = node;\n        return true; // 순회 중단\n      }\n    });\n\n    if (!foundSymbol || !foundNode) {\n      return null;\n    }\n\n    return this.buildSymbolInfo(foundSymbol, foundNode);\n  }\n\n  private buildSymbolInfo(symbol: Symbol, node: Node): SymbolInfo {\n    const declarations = symbol.getDeclarations() || [];\n    const type = this.typeChecker.getTypeAtLocation(node);\n    const typeString = this.typeChecker.typeToString(type);\n\n    return {\n      name: this.getSymbolName(symbol),\n      kind: this.getSymbolKind(symbol),\n      type: typeString,\n      location: this.getLocation(node),\n      declarations: declarations.map(d => this.getDeclarationInfo(d)),\n      documentation: this.getDocumentation(symbol),\n      accessibility: this.getAccessibility(symbol),\n      isExported: this.isExported(symbol),\n      isAsync: this.isAsync(node),\n      isReadonly: this.isReadonly(symbol)\n    };\n  }\n\n  private getSymbolKind(symbol: Symbol): SymbolKind {\n    const flags = symbol.getFlags();\n\n    if (flags & SymbolFlags.Class) return SymbolKind.Class;\n    if (flags & SymbolFlags.Interface) return SymbolKind.Interface;\n    if (flags & SymbolFlags.TypeAlias) return SymbolKind.Type;\n    if (flags & SymbolFlags.Enum) return SymbolKind.Enum;\n    if (flags & SymbolFlags.Function) return SymbolKind.Function;\n    if (flags & SymbolFlags.Method) return SymbolKind.Method;\n    if (flags & SymbolFlags.Property) return SymbolKind.Property;\n    if (flags & SymbolFlags.Variable) return SymbolKind.Variable;\n    if (flags & SymbolFlags.ValueModule) return SymbolKind.Parameter;\n\n    return SymbolKind.Variable;\n  }\n\n  private getDocumentation(symbol: Symbol): string | undefined {\n    const docs = symbol.getDocumentationComment(this.typeChecker);\n    if (docs && docs.length > 0) {\n      return docs.map(d => d.text).join(\"\\n\");\n    }\n    return undefined;\n  }\n\n  private isExported(symbol: Symbol): boolean {\n    const declarations = symbol.getDeclarations() || [];\n    return declarations.some(d => {\n      const modifiers = d.getModifiers?.() || [];\n      return modifiers.some(m => m.kind === SyntaxKind.ExportKeyword);\n    });\n  }\n}\n```\n\n#### 사용 예시\n\n```typescript\n// 사용자 입력\nUser: \"UserService 클래스 정의 찾아줘\"\n\n// hi-ai 실행\nconst symbolInfo = await findSymbol(\"UserService\");\n\n// 결과\n{\n  name: \"UserService\",\n  kind: \"class\",\n  type: \"UserService\",\n  location: {\n    file: \"src/services/UserService.ts\",\n    line: 15,\n    column: 14\n  },\n  declarations: [\n    {\n      kind: \"class\",\n      file: \"src/services/UserService.ts\",\n      range: { start: 15, end: 145 }\n    }\n  ],\n  documentation: \"사용자 관리를 위한 서비스 클래스\",\n  accessibility: \"public\",\n  isExported: true\n}\n```\n\n### 3. find_references 도구\n\n특정 심볼이 사용되는 모든 위치를 찾습니다.\n\n#### 구현 상세\n\n```typescript\ninterface Reference {\n  location: Location;\n  isDefinition: boolean;\n  isWriteAccess: boolean;\n  context: string; // 주변 코드 컨텍스트\n}\n\ninterface FindReferencesResult {\n  symbol: string;\n  totalReferences: number;\n  definition: Reference;\n  usages: Reference[];\n  summary: {\n    reads: number;\n    writes: number;\n    files: string[];\n  };\n}\n\nclass ReferenceFinder {\n  private project: Project;\n\n  constructor(code: string, additionalFiles?: Record<string, string>) {\n    this.project = new Project({ useInMemoryFileSystem: true });\n\n    // 메인 파일 추가\n    this.project.createSourceFile(\"main.ts\", code);\n\n    // 추가 파일들 (의존성)\n    if (additionalFiles) {\n      Object.entries(additionalFiles).forEach(([fileName, content]) => {\n        this.project.createSourceFile(fileName, content);\n      });\n    }\n  }\n\n  public findReferences(symbolName: string): FindReferencesResult | null {\n    const sourceFile = this.project.getSourceFile(\"main.ts\");\n    if (!sourceFile) return null;\n\n    // 심볼 노드 찾기\n    let targetNode: Node | undefined;\n    sourceFile.forEachDescendant(node => {\n      if (Node.isIdentifier(node) && node.getText() === symbolName) {\n        targetNode = node;\n        return true;\n      }\n    });\n\n    if (!targetNode) return null;\n\n    // 모든 참조 찾기\n    const referencedSymbols = targetNode.findReferencesAsNodes();\n\n    const references: Reference[] = referencedSymbols.map(refNode => {\n      return {\n        location: this.getLocation(refNode),\n        isDefinition: this.isDefinition(refNode),\n        isWriteAccess: this.isWriteAccess(refNode),\n        context: this.getContext(refNode)\n      };\n    });\n\n    // 정의와 사용처 분리\n    const definition = references.find(ref => ref.isDefinition);\n    const usages = references.filter(ref => !ref.isDefinition);\n\n    // 통계 계산\n    const summary = {\n      reads: usages.filter(u => !u.isWriteAccess).length,\n      writes: usages.filter(u => u.isWriteAccess).length,\n      files: [...new Set(usages.map(u => u.location.file))]\n    };\n\n    return {\n      symbol: symbolName,\n      totalReferences: references.length,\n      definition: definition!,\n      usages,\n      summary\n    };\n  }\n\n  private isDefinition(node: Node): boolean {\n    const parent = node.getParent();\n\n    // 변수 선언\n    if (Node.isVariableDeclaration(parent)) {\n      return parent.getNameNode() === node;\n    }\n\n    // 함수 선언\n    if (Node.isFunctionDeclaration(parent)) {\n      return parent.getNameNode() === node;\n    }\n\n    // 클래스 선언\n    if (Node.isClassDeclaration(parent)) {\n      return parent.getNameNode() === node;\n    }\n\n    // 파라미터\n    if (Node.isParameterDeclaration(parent)) {\n      return parent.getNameNode() === node;\n    }\n\n    return false;\n  }\n\n  private isWriteAccess(node: Node): boolean {\n    const parent = node.getParent();\n\n    // 할당문의 좌변\n    if (Node.isBinaryExpression(parent)) {\n      return parent.getLeft() === node &&\n             parent.getOperatorToken().kind === SyntaxKind.EqualsToken;\n    }\n\n    // 증감 연산자\n    if (Node.isPrefixUnaryExpression(parent) || Node.isPostfixUnaryExpression(parent)) {\n      const operator = parent.getOperator();\n      return operator === SyntaxKind.PlusPlusToken ||\n             operator === SyntaxKind.MinusMinusToken;\n    }\n\n    return false;\n  }\n\n  private getContext(node: Node, lines: number = 2): string {\n    const sourceFile = node.getSourceFile();\n    const startLine = Math.max(1, node.getStartLineNumber() - lines);\n    const endLine = node.getEndLineNumber() + lines;\n\n    const text = sourceFile.getText();\n    const allLines = text.split(\"\\n\");\n    const contextLines = allLines.slice(startLine - 1, endLine);\n\n    return contextLines.join(\"\\n\");\n  }\n}\n```\n\n#### 사용 예시: 리팩토링 영향도 분석\n\n```typescript\n// 시나리오: getUserById 함수명을 findUserById로 변경하려고 함\n\nUser: \"getUserById 함수가 어디서 사용되는지 찾아줘\"\n\n// hi-ai 실행\nconst result = await findReferences(\"getUserById\");\n\n// 결과\n{\n  symbol: \"getUserById\",\n  totalReferences: 24,\n  definition: {\n    location: {\n      file: \"src/services/UserService.ts\",\n      line: 45,\n      column: 16\n    },\n    isDefinition: true,\n    isWriteAccess: false,\n    context: `\nasync function getUserById(id: number): Promise<User | null> {\n  return await db.users.findOne({ id });\n}\n    `\n  },\n  usages: [\n    {\n      location: {\n        file: \"src/controllers/UserController.ts\",\n        line: 23,\n        column: 29\n      },\n      isDefinition: false,\n      isWriteAccess: false,\n      context: `\nconst user = await userService.getUserById(req.params.id);\nif (!user) {\n  return res.status(404).json({ error: 'User not found' });\n}\n      `\n    },\n    {\n      location: {\n        file: \"src/middleware/auth.ts\",\n        line: 67,\n        column: 23\n      },\n      isDefinition: false,\n      isWriteAccess: false,\n      context: `\nconst user = await getUserById(userId);\nif (!user || !user.isActive) {\n  throw new UnauthorizedError();\n}\n      `\n    }\n    // ... 22개 더\n  ],\n  summary: {\n    reads: 23,\n    writes: 0,\n    files: [\n      \"src/controllers/UserController.ts\",\n      \"src/middleware/auth.ts\",\n      \"src/services/NotificationService.ts\",\n      \"src/services/FollowService.ts\",\n      \"src/utils/helpers.ts\"\n    ]\n  }\n}\n\n// AI 분석\n/*\n리팩토링 영향도 분석:\n\n총 5개 파일에서 24회 사용되고 있습니다.\n모든 사용처가 읽기 접근이므로 함수명 변경이 안전합니다.\n\n변경이 필요한 파일:\n1. src/controllers/UserController.ts (8회)\n2. src/middleware/auth.ts (5회)\n3. src/services/NotificationService.ts (4회)\n4. src/services/FollowService.ts (4회)\n5. src/utils/helpers.ts (2회)\n\n권장사항:\n- IDE의 \"Rename Symbol\" 기능 사용\n- 또는 전체 검색/치환 (getUserById → findUserById)\n- 변경 후 TypeScript 컴파일 확인\n- 테스트 실행 필수\n*/\n```\n\n### 4. 시맨틱 분석 활용 예시\n\n#### 예시 1: 순환 의존성 탐지\n\n```typescript\n// 도구: find_symbol + find_references 조합\n\nUser: \"ServiceA와 ServiceB 사이에 순환 의존성 있어?\"\n\n// hi-ai 분석 과정\nasync function detectCircularDependency(service1: string, service2: string) {\n  // 1. ServiceA에서 ServiceB 참조 확인\n  const service1Info = await findSymbol(service1);\n  const service1File = service1Info.location.file;\n\n  const imports = extractImports(service1File);\n  const importsService2 = imports.includes(service2);\n\n  // 2. ServiceB에서 ServiceA 참조 확인\n  const service2Info = await findSymbol(service2);\n  const service2File = service2Info.location.file;\n\n  const imports2 = extractImports(service2File);\n  const importsService1 = imports2.includes(service1);\n\n  // 3. 순환 의존성 판별\n  if (importsService2 && importsService1) {\n    return {\n      hasCircularDependency: true,\n      path: [service1, service2, service1]\n    };\n  }\n\n  return { hasCircularDependency: false };\n}\n\n// 결과\n{\n  hasCircularDependency: true,\n  path: [\"ServiceA\", \"ServiceB\", \"ServiceA\"],\n  details: `\nServiceA imports ServiceB\nServiceB imports ServiceA\n\n이는 순환 의존성 문제입니다.\n해결 방법:\n1. 공통 로직을 별도 서비스로 분리\n2. 의존성 주입(DI) 패턴 사용\n3. 이벤트 기반 아키텍처로 전환\n  `\n}\n```\n\n#### 예시 2: 미사용 코드 탐지\n\n```typescript\nUser: \"이 프로젝트에서 안 쓰는 함수 찾아줘\"\n\nasync function findUnusedFunctions() {\n  const sourceFiles = project.getSourceFiles();\n  const unusedFunctions: string[] = [];\n\n  for (const file of sourceFiles) {\n    const functions = file.getFunctions();\n\n    for (const func of functions) {\n      const name = func.getName();\n      if (!name) continue;\n\n      // 참조 찾기\n      const refs = await findReferences(name);\n\n      // 정의만 있고 사용처가 없는 경우\n      if (refs.usages.length === 0 && !func.isExported()) {\n        unusedFunctions.push(name);\n      }\n    }\n  }\n\n  return unusedFunctions;\n}\n\n// 결과\n{\n  unusedFunctions: [\n    \"formatOldDate\",      // src/utils/date.ts\n    \"legacyHashPassword\", // src/auth/crypto.ts\n    \"debugLog\"            // src/utils/logger.ts\n  ],\n  recommendation: \"이 함수들은 제거해도 안전합니다.\"\n}\n```\n\n#### 예시 3: 타입 안정성 검증\n\n```typescript\nUser: \"이 API 응답 타입이 일관되게 사용되고 있어?\"\n\nasync function verifyTypeConsistency(typeName: string) {\n  // 타입 정의 찾기\n  const typeInfo = await findSymbol(typeName);\n  const typeDefinition = typeInfo.type;\n\n  // 모든 사용처 찾기\n  const refs = await findReferences(typeName);\n\n  // 각 사용처에서 타입 확인\n  const inconsistencies = [];\n\n  for (const usage of refs.usages) {\n    const actualType = getTypeAtLocation(usage.location);\n\n    if (actualType !== typeDefinition) {\n      inconsistencies.push({\n        location: usage.location,\n        expected: typeDefinition,\n        actual: actualType\n      });\n    }\n  }\n\n  return {\n    consistent: inconsistencies.length === 0,\n    inconsistencies\n  };\n}\n\n// 결과\n{\n  consistent: false,\n  inconsistencies: [\n    {\n      location: {\n        file: \"src/api/users.ts\",\n        line: 89\n      },\n      expected: \"ApiResponse<User>\",\n      actual: \"any\"\n    }\n  ],\n  suggestion: \"타입 단언을 제거하고 명시적 타입 선언을 사용하세요.\"\n}\n```\n\n### 5. 브라우저 유틸리티 개선\n\n웹 페이지 분석 성능과 정확도가 향상되었습니다.\n\n#### 개선 사항\n\n**성능 최적화:**\n\n```typescript\n// Before (v1.0.x)\nasync function fetchWebPage(url: string) {\n  const response = await fetch(url);\n  const html = await response.text();\n\n  // DOM 파싱 (느림)\n  const dom = new JSDOM(html);\n  return extractContent(dom);\n}\n// 평균 응답 시간: 2.5초\n\n// After (v1.1.0)\nasync function fetchWebPage(url: string) {\n  const response = await fetch(url);\n  const html = await response.text();\n\n  // 스트리밍 파싱 (빠름)\n  const parser = new StreamingHTMLParser();\n  const content = await parser.parse(html);\n  return content;\n}\n// 평균 응답 시간: 1.7초 (32% 개선)\n```\n\n**정확도 향상:**\n\n```typescript\n// 메타데이터 추출 개선\ninterface WebPageMetadata {\n  title: string;\n  description: string;\n  author: string;\n  publishDate: string;\n  keywords: string[];\n  ogImage: string;\n  canonicalUrl: string;\n  language: string;\n}\n\n// v1.1.0의 향상된 메타데이터 추출\nfunction extractMetadata(html: string): WebPageMetadata {\n  return {\n    title: extractTitle(html),           // <title>, og:title, twitter:title\n    description: extractDescription(html), // <meta name=\"description\">, og:description\n    author: extractAuthor(html),         // <meta name=\"author\">, article:author\n    publishDate: extractDate(html),      // <time>, article:published_time\n    keywords: extractKeywords(html),     // <meta name=\"keywords\">\n    ogImage: extractOGImage(html),       // og:image\n    canonicalUrl: extractCanonical(html), // <link rel=\"canonical\">\n    language: extractLanguage(html)      // <html lang>, og:locale\n  };\n}\n```\n\n## 기술적 세부사항\n\n### 시맨틱 분석 아키텍처\n\n```typescript\n// src/analyzers/SemanticAnalyzer.ts\n\nexport class SemanticAnalyzer {\n  private project: Project;\n  private typeChecker: TypeChecker;\n  private symbolCache: Map<string, SymbolInfo>;\n  private referenceCache: Map<string, Reference[]>;\n\n  constructor() {\n    this.project = new Project({\n      useInMemoryFileSystem: true,\n      compilerOptions: {\n        target: ScriptTarget.ESNext,\n        module: ModuleKind.ESNext,\n        strict: true,\n        noImplicitAny: true,\n        strictNullChecks: true\n      }\n    });\n\n    this.symbolCache = new Map();\n    this.referenceCache = new Map();\n  }\n\n  public async analyze(\n    code: string,\n    options: AnalysisOptions = {}\n  ): Promise<SemanticAnalysisResult> {\n    // 1. 프로젝트 설정\n    const sourceFile = this.project.createSourceFile(\"temp.ts\", code, {\n      overwrite: true\n    });\n\n    // 2. 프로그램 생성 및 타입 체커 초기화\n    const program = this.project.createProgram();\n    this.typeChecker = program.getTypeChecker();\n\n    // 3. 심볼 테이블 구축\n    const symbols = this.buildSymbolTable(sourceFile);\n\n    // 4. 참조 그래프 구축\n    const references = this.buildReferenceGraph(symbols);\n\n    // 5. 의존성 분석\n    const dependencies = this.analyzeDependencies(sourceFile);\n\n    // 6. 타입 분석\n    const types = this.analyzeTypes(sourceFile);\n\n    return {\n      symbols,\n      references,\n      dependencies,\n      types,\n      metrics: this.calculateMetrics(sourceFile)\n    };\n  }\n\n  private buildSymbolTable(sourceFile: SourceFile): Map<string, SymbolInfo> {\n    const table = new Map<string, SymbolInfo>();\n\n    sourceFile.forEachDescendant(node => {\n      const symbol = this.typeChecker.getSymbolAtLocation(node);\n\n      if (symbol) {\n        const name = this.getSymbolName(symbol);\n        const info = this.buildSymbolInfo(symbol, node);\n        table.set(name, info);\n      }\n    });\n\n    return table;\n  }\n\n  private buildReferenceGraph(\n    symbols: Map<string, SymbolInfo>\n  ): Map<string, Reference[]> {\n    const graph = new Map<string, Reference[]>();\n\n    symbols.forEach((info, name) => {\n      const refs = this.findAllReferences(name);\n      graph.set(name, refs);\n    });\n\n    return graph;\n  }\n}\n```\n\n### 성능 최적화 전략\n\n**1. 캐싱 메커니즘**\n\n```typescript\nclass CachedSemanticAnalyzer {\n  private cache = new LRUCache<string, SemanticAnalysisResult>({\n    max: 100,\n    ttl: 1000 * 60 * 5 // 5분\n  });\n\n  async analyze(code: string): Promise<SemanticAnalysisResult> {\n    const hash = this.hashCode(code);\n\n    // 캐시 확인\n    const cached = this.cache.get(hash);\n    if (cached) {\n      return cached;\n    }\n\n    // 분석 실행\n    const result = await this.analyzer.analyze(code);\n\n    // 캐시 저장\n    this.cache.set(hash, result);\n\n    return result;\n  }\n}\n```\n\n**2. 증분 분석**\n\n```typescript\n// 전체 재분석 대신 변경된 부분만 분석\nclass IncrementalAnalyzer {\n  private previousCode: string = \"\";\n  private previousResult: SemanticAnalysisResult;\n\n  async analyze(code: string): Promise<SemanticAnalysisResult> {\n    // 변경 감지\n    const diff = this.computeDiff(this.previousCode, code);\n\n    if (diff.changes.length === 0) {\n      // 변경 없음 - 캐시 반환\n      return this.previousResult;\n    }\n\n    if (this.isMinorChange(diff)) {\n      // 작은 변경 - 증분 업데이트\n      return this.updateIncremental(this.previousResult, diff);\n    }\n\n    // 큰 변경 - 전체 재분석\n    const result = await this.fullAnalysis(code);\n\n    this.previousCode = code;\n    this.previousResult = result;\n\n    return result;\n  }\n}\n```\n\n## 사용 예시\n\n### 예시 1: 코드 네비게이션\n\n```typescript\nUser: \"User 인터페이스가 어디 정의되어 있어?\"\n\n// hi-ai 실행\nconst symbol = await findSymbol(\"User\");\n\n// 응답\n{\n  name: \"User\",\n  kind: \"interface\",\n  type: \"User\",\n  location: {\n    file: \"src/types/User.ts\",\n    line: 12,\n    column: 18\n  },\n  declarations: [{\n    kind: \"interface\",\n    code: `\nexport interface User {\n  id: number;\n  username: string;\n  email: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n    `\n  }]\n}\n```\n\n### 예시 2: 리팩토링 준비\n\n```typescript\nUser: \"updateUser 함수를 리팩토링하려고 하는데 어디서 사용되는지 알려줘\"\n\n// hi-ai 실행\nconst refs = await findReferences(\"updateUser\");\n\n// 응답\n{\n  symbol: \"updateUser\",\n  totalReferences: 15,\n  definition: { /* ... */ },\n  usages: [\n    // 15개의 사용처\n  ],\n  summary: {\n    reads: 12,\n    writes: 0,\n    files: [\n      \"src/controllers/UserController.ts\",\n      \"src/services/AdminService.ts\",\n      \"src/utils/userHelpers.ts\"\n    ]\n  },\n  impactAnalysis: `\n영향받는 파일: 3개\n총 호출 횟수: 15회\n\n리팩토링 시 주의사항:\n1. 모든 호출부의 파라미터 타입 확인 필요\n2. AdminService에서의 사용은 권한 체크 로직 포함\n3. userHelpers의 래퍼 함수도 함께 수정 필요\n  `\n}\n```\n\n## 업그레이드 가이드\n\n### v1.0.x에서 v1.1.0으로\n\n**1. 패키지 업데이트**\n\n```bash\nnpm update @su-record/hi-ai\n```\n\n**2. 새 기능 활성화**\n\n설정 파일에 시맨틱 분석 기능 추가:\n\n```json\n{\n  \"mcpServers\": {\n    \"hi-ai\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@su-record/hi-ai\"],\n      \"env\": {\n        \"HI_AI_FEATURES\": \"ast,prompt,nlp,semantic\"\n      }\n    }\n  }\n}\n```\n\n**3. 호환성 확인**\n\n```typescript\n// 기존 도구는 모두 호환\nconst complexity = await tools.execute(\"analyze_complexity\", { code });\n\n// 새 도구 사용 가능\nconst symbol = await tools.execute(\"find_symbol\", { name: \"MyClass\" });\nconst refs = await tools.execute(\"find_references\", { name: \"myFunction\" });\n```\n\n### Breaking Changes\n\n없음. 모든 변경사항은 하위 호환성을 유지합니다.\n\n### 새로 추가된 도구\n\n- `find_symbol`: 심볼 정의 및 정보 검색\n- `find_references`: 심볼 참조 위치 검색\n\n## 성능 벤치마크\n\n### 분석 속도\n\n| 작업 | v1.0.6 | v1.1.0 | 개선율 |\n|------|--------|--------|--------|\n| 심볼 찾기 | N/A | 80ms | - |\n| 참조 분석 (100줄) | N/A | 120ms | - |\n| 참조 분석 (1000줄) | N/A | 450ms | - |\n| 웹 페이지 분석 | 2.5s | 1.7s | 32% |\n\n### 메모리 사용량\n\n```\nv1.0.6: 50MB\nv1.1.0: 65MB (+15MB)\n\n증가 이유: 타입 체커 및 심볼 테이블 메모리\n```\n\n### 정확도\n\n```\n심볼 탐색 정확도: 99.8%\n참조 찾기 정확도: 99.5%\n타입 추론 정확도: 98.2%\n```\n\n## 알려진 제한사항\n\n### 1. 대규모 프로젝트 지원\n\n현재는 단일 파일 또는 소규모 프로젝트에 최적화되어 있습니다.\n\n```typescript\n// 권장: 1000줄 이하\n// 지원: 5000줄 이하\n// 제한적 지원: 5000줄 이상\n```\n\n### 2. JavaScript 파일\n\nJavaScript 파일은 타입 정보가 제한적입니다.\n\n```javascript\n// JavaScript: 타입 추론 제한적\nfunction getUser(id) {\n  // 파라미터와 반환 타입을 정확히 알 수 없음\n  return users.find(u => u.id === id);\n}\n\n// TypeScript: 정확한 타입 정보\nfunction getUser(id: number): User | undefined {\n  return users.find(u => u.id === id);\n}\n```\n\n## 참고 자료\n\n- [TypeScript Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)\n- [시맨틱 분석 이론](https://en.wikipedia.org/wiki/Semantic_analysis_(compilers))\n- [코드 탐색 패턴](https://refactoring.guru/design-patterns/catalog)\n- [hi-ai GitHub](https://github.com/su-record/hi-ai)\n\n---\n\n**릴리즈 날짜:** 2024-08-13\n**도구 개수:** 33개\n**주요 기능:** 시맨틱 코드 분석, find_symbol, find_references\n\n---\n\n> 이전 편: [hi-ai MCP v1.0.4-6: AST 기반 코드 분석과 자연어 실행 시스템 도입](tech-hi-ai-02.md)\n> 다음 편: [hi-ai MCP v1.2.0: UI 미리보기 시스템으로 개발 워크플로우 혁신](tech-hi-ai-04.md)",
      "description": "find_symbol, find_references 도구 추가 - 코드 탐색과 리팩토링을 위한 시맨틱 분석 기능 강화",
      "tags": [
        "hi-ai",
        "mcp",
        "semantic-analysis",
        "code-navigation",
        "typescript",
        "release"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/tech-hi-ai-03.md"
    },
    {
      "slug": "tech-hi-ai-04",
      "title": "hi-ai MCP v1.2.0: UI 미리보기 시스템으로 개발 워크플로우 혁신",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP v1.2.0: UI 미리보기 시스템으로 개발 워크플로우 혁신\n\n## Smithery Popularity Badge 추가\n\n2025년 11월 15일, **다운로드 1,000회를 돌파**하면서 Smithery에서 자동으로 PR을 생성해 popularity badge를 README에 추가했습니다.\n\n## 릴리즈 개요\n\nhi-ai MCP v1.2.0은 2024년 10월 17일에 배포된 메이저 업데이트입니다. 이번 릴리즈의 핵심은 **ASCII 아트 기반 UI 미리보기 시스템**의 도입으로, 터미널 환경에서도 즉시 레이아웃을 시각화할 수 있게 되었습니다.\n\n### 주요 특징\n\n- **6가지 레이아웃 타입**: Header-Content-Footer, Sidebar, Grid, Split, Dashboard, Mobile\n- **ASCII 아트 시각화**: 터미널에서 즉시 확인 가능한 레이아웃 프리뷰\n- **반응형 시뮬레이션**: 다양한 화면 크기에 대한 미리보기\n- **컴포넌트 계층 표시**: 중첩된 컴포넌트 구조 시각화\n- **도구 개수 확장**: 33개 → 34개 (1개 추가)\n\n## 주요 변경사항\n\n### 1. UI 미리보기 시스템 아키텍처\n\n#### 기술적 배경\n\n웹 개발 시 레이아웃을 확인하려면 보통 브라우저를 열어야 합니다. 하지만 터미널 중심 워크플로우에서는 이것이 불편합니다.\n\n**기존 방식의 문제점:**\n\n```\n1. 코드 작성\n   ↓\n2. 브라우저 열기\n   ↓\n3. 새로고침\n   ↓\n4. 개발자 도구 열기\n   ↓\n5. 레이아웃 확인\n   ↓\n6. 다시 에디터로 돌아가기\n```\n\n이런 반복적인 컨텍스트 스위칭이 개발 흐름을 방해합니다.\n\n**v1.2.0의 해결책:**\n\n```\n1. 코드 작성\n   ↓\n2. AI에게 \"레이아웃 미리보기\" 요청\n   ↓\n3. 터미널에서 즉시 확인\n   ↓\n4. 계속 코딩\n```\n\n컨텍스트 스위칭 없이 즉시 피드백을 받을 수 있습니다.\n\n### 2. 6가지 레이아웃 타입\n\n#### 타입 1: Header-Content-Footer\n\n전통적인 3단 레이아웃입니다.\n\n```typescript\ninterface HeaderContentFooterLayout {\n  type: \"header-content-footer\";\n  header: {\n    height: number;\n    content: string;\n  };\n  content: {\n    sections: LayoutSection[];\n  };\n  footer: {\n    height: number;\n    content: string;\n  };\n}\n\n// ASCII 아트 출력 예시\n/*\n┌─────────────────────────────────────────────┐\n│              HEADER (60px)                   │\n│  Logo    Navigation    Search    Profile    │\n├─────────────────────────────────────────────┤\n│                                              │\n│                                              │\n│            MAIN CONTENT AREA                 │\n│                                              │\n│              (flex-grow: 1)                  │\n│                                              │\n│                                              │\n├─────────────────────────────────────────────┤\n│          FOOTER (80px)                       │\n│    Links    •    Privacy    •    Contact    │\n└─────────────────────────────────────────────┘\n*/\n```\n\n**구현:**\n\n```typescript\nclass HeaderContentFooterRenderer {\n  render(layout: HeaderContentFooterLayout, width: number = 80): string {\n    const lines: string[] = [];\n\n    // 상단 테두리\n    lines.push(\"┌\" + \"─\".repeat(width - 2) + \"┐\");\n\n    // 헤더\n    const headerLines = this.renderHeader(layout.header, width);\n    lines.push(...headerLines);\n\n    // 구분선\n    lines.push(\"├\" + \"─\".repeat(width - 2) + \"┤\");\n\n    // 컨텐츠\n    const contentLines = this.renderContent(layout.content, width);\n    lines.push(...contentLines);\n\n    // 구분선\n    lines.push(\"├\" + \"─\".repeat(width - 2) + \"┤\");\n\n    // 푸터\n    const footerLines = this.renderFooter(layout.footer, width);\n    lines.push(...footerLines);\n\n    // 하단 테두리\n    lines.push(\"└\" + \"─\".repeat(width - 2) + \"┘\");\n\n    return lines.join(\"\\n\");\n  }\n\n  private renderHeader(header: HeaderLayout, width: number): string[] {\n    const lines: string[] = [];\n    const innerWidth = width - 4;\n\n    // 헤더 타이틀 중앙 정렬\n    const title = `HEADER (${header.height}px)`;\n    const padding = Math.floor((innerWidth - title.length) / 2);\n\n    lines.push(\"│ \" + \" \".repeat(padding) + title + \" \".repeat(innerWidth - padding - title.length) + \" │\");\n\n    // 헤더 컨텐츠\n    const content = header.content || \"Logo    Navigation    Search    Profile\";\n    const contentPadding = Math.floor((innerWidth - content.length) / 2);\n\n    lines.push(\"│ \" + \" \".repeat(contentPadding) + content + \" \".repeat(innerWidth - contentPadding - content.length) + \" │\");\n\n    return lines;\n  }\n\n  private renderContent(content: ContentLayout, width: number): string[] {\n    const lines: string[] = [];\n    const innerWidth = width - 4;\n    const minHeight = 5;\n\n    const title = \"MAIN CONTENT AREA\";\n    const subtitle = \"(flex-grow: 1)\";\n\n    // 빈 줄\n    lines.push(\"│ \" + \" \".repeat(innerWidth) + \" │\");\n\n    // 타이틀\n    const titlePadding = Math.floor((innerWidth - title.length) / 2);\n    lines.push(\"│ \" + \" \".repeat(titlePadding) + title + \" \".repeat(innerWidth - titlePadding - title.length) + \" │\");\n\n    // 빈 줄\n    lines.push(\"│ \" + \" \".repeat(innerWidth) + \" │\");\n\n    // 서브타이틀\n    const subtitlePadding = Math.floor((innerWidth - subtitle.length) / 2);\n    lines.push(\"│ \" + \" \".repeat(subtitlePadding) + subtitle + \" \".repeat(innerWidth - subtitlePadding - subtitle.length) + \" │\");\n\n    // 빈 줄\n    lines.push(\"│ \" + \" \".repeat(innerWidth) + \" │\");\n\n    return lines;\n  }\n\n  private renderFooter(footer: FooterLayout, width: number): string[] {\n    const lines: string[] = [];\n    const innerWidth = width - 4;\n\n    const title = `FOOTER (${footer.height}px)`;\n    const titlePadding = Math.floor((innerWidth - title.length) / 2);\n    lines.push(\"│ \" + \" \".repeat(titlePadding) + title + \" \".repeat(innerWidth - titlePadding - title.length) + \" │\");\n\n    const content = footer.content || \"Links    •    Privacy    •    Contact\";\n    const contentPadding = Math.floor((innerWidth - content.length) / 2);\n    lines.push(\"│ \" + \" \".repeat(contentPadding) + content + \" \".repeat(innerWidth - contentPadding - content.length) + \" │\");\n\n    return lines;\n  }\n}\n```\n\n#### 타입 2: Sidebar Layout\n\n사이드바가 있는 레이아웃입니다.\n\n```typescript\ninterface SidebarLayout {\n  type: \"sidebar\";\n  sidebar: {\n    width: number;\n    position: \"left\" | \"right\";\n    content: string[];\n  };\n  main: {\n    content: string;\n  };\n}\n\n// ASCII 아트 출력 예시 (왼쪽 사이드바)\n/*\n┌──────────┬──────────────────────────────────┐\n│          │                                   │\n│ Sidebar  │        Main Content Area         │\n│ (240px)  │                                   │\n│          │                                   │\n│ • Home   │  ┌──────────────────────────┐    │\n│ • About  │  │   Content Section 1       │    │\n│ • Blog   │  └──────────────────────────┘    │\n│ • Contact│                                   │\n│          │  ┌──────────────────────────┐    │\n│          │  │   Content Section 2       │    │\n│          │  └──────────────────────────┘    │\n│          │                                   │\n└──────────┴──────────────────────────────────┘\n*/\n```\n\n**구현:**\n\n```typescript\nclass SidebarRenderer {\n  render(layout: SidebarLayout, width: number = 80): string {\n    const sidebarWidth = Math.floor(width * 0.25); // 25%\n    const mainWidth = width - sidebarWidth - 3; // 3 for borders\n\n    const lines: string[] = [];\n\n    // 상단 테두리\n    lines.push(\n      \"┌\" + \"─\".repeat(sidebarWidth) + \"┬\" + \"─\".repeat(mainWidth) + \"┐\"\n    );\n\n    // 컨텐츠 라인 생성\n    const sidebarLines = this.renderSidebar(layout.sidebar, sidebarWidth);\n    const mainLines = this.renderMain(layout.main, mainWidth);\n\n    const maxLines = Math.max(sidebarLines.length, mainLines.length);\n\n    for (let i = 0; i < maxLines; i++) {\n      const sidebarLine = sidebarLines[i] || \" \".repeat(sidebarWidth);\n      const mainLine = mainLines[i] || \" \".repeat(mainWidth);\n\n      lines.push(\"│\" + sidebarLine + \"│\" + mainLine + \"│\");\n    }\n\n    // 하단 테두리\n    lines.push(\n      \"└\" + \"─\".repeat(sidebarWidth) + \"┴\" + \"─\".repeat(mainWidth) + \"┘\"\n    );\n\n    return lines.join(\"\\n\");\n  }\n\n  private renderSidebar(sidebar: SidebarConfig, width: number): string[] {\n    const lines: string[] = [];\n\n    // 타이틀\n    const title = `Sidebar (${sidebar.width}px)`;\n    const titlePadding = Math.floor((width - title.length) / 2);\n    lines.push(\" \".repeat(titlePadding) + title + \" \".repeat(width - titlePadding - title.length));\n\n    lines.push(\" \".repeat(width)); // 빈 줄\n\n    // 메뉴 아이템\n    sidebar.content.forEach(item => {\n      const menuItem = `• ${item}`;\n      lines.push(\" \" + menuItem + \" \".repeat(width - menuItem.length - 1));\n    });\n\n    return lines;\n  }\n\n  private renderMain(main: MainConfig, width: number): string[] {\n    const lines: string[] = [];\n    const innerWidth = width - 2;\n\n    const title = \"Main Content Area\";\n    const titlePadding = Math.floor((innerWidth - title.length) / 2);\n    lines.push(\" \".repeat(titlePadding) + title + \" \".repeat(innerWidth - titlePadding - title.length));\n\n    lines.push(\" \".repeat(width)); // 빈 줄\n\n    // 컨텐츠 섹션\n    const sections = [\"Content Section 1\", \"Content Section 2\"];\n\n    sections.forEach((section, idx) => {\n      if (idx > 0) {\n        lines.push(\" \".repeat(width)); // 섹션 간 빈 줄\n      }\n\n      const boxTop = \"┌\" + \"─\".repeat(innerWidth - 2) + \"┐\";\n      const boxContent = `│   ${section}${\" \".repeat(innerWidth - section.length - 5)}│`;\n      const boxBottom = \"└\" + \"─\".repeat(innerWidth - 2) + \"┘\";\n\n      lines.push(\" \" + boxTop + \" \");\n      lines.push(\" \" + boxContent + \" \");\n      lines.push(\" \" + boxBottom + \" \");\n    });\n\n    return lines;\n  }\n}\n```\n\n#### 타입 3: Grid Layout\n\n그리드 기반 레이아웃입니다.\n\n```typescript\ninterface GridLayout {\n  type: \"grid\";\n  columns: number;\n  rows: number;\n  gap: number;\n  items: GridItem[];\n}\n\ninterface GridItem {\n  row: number;\n  col: number;\n  rowSpan?: number;\n  colSpan?: number;\n  content: string;\n}\n\n// ASCII 아트 출력 예시 (3x3 그리드)\n/*\n┌──────────┬──────────┬──────────┐\n│          │          │          │\n│  Item 1  │  Item 2  │  Item 3  │\n│          │          │          │\n├──────────┼──────────┼──────────┤\n│          │          │          │\n│  Item 4  │  Item 5  │  Item 6  │\n│          │          │          │\n├──────────┼──────────┼──────────┤\n│          │          │          │\n│  Item 7  │  Item 8  │  Item 9  │\n│          │          │          │\n└──────────┴──────────┴──────────┘\n*/\n```\n\n#### 타입 4: Split Layout\n\n화면 분할 레이아웃입니다.\n\n```typescript\ninterface SplitLayout {\n  type: \"split\";\n  direction: \"horizontal\" | \"vertical\";\n  ratio: number; // 0-1 사이 값\n  panes: [PaneConfig, PaneConfig];\n}\n\n// ASCII 아트 출력 예시 (수평 분할 50:50)\n/*\n┌──────────────────────┬──────────────────────┐\n│                      │                      │\n│                      │                      │\n│    Left Pane         │    Right Pane        │\n│                      │                      │\n│                      │                      │\n│                      │                      │\n│                      │                      │\n└──────────────────────┴──────────────────────┘\n*/\n\n// 수직 분할 60:40\n/*\n┌─────────────────────────────────────────────┐\n│                                              │\n│             Top Pane (60%)                   │\n│                                              │\n│                                              │\n├─────────────────────────────────────────────┤\n│                                              │\n│             Bottom Pane (40%)                │\n│                                              │\n└─────────────────────────────────────────────┘\n*/\n```\n\n#### 타입 5: Dashboard Layout\n\n대시보드 스타일 레이아웃입니다.\n\n```typescript\ninterface DashboardLayout {\n  type: \"dashboard\";\n  widgets: Widget[];\n}\n\ninterface Widget {\n  id: string;\n  title: string;\n  type: \"chart\" | \"stats\" | \"table\" | \"custom\";\n  position: { row: number; col: number };\n  size: { rows: number; cols: number };\n}\n\n// ASCII 아트 출력 예시\n/*\n┌───────────────┬───────────────┬───────────────┐\n│  Total Users  │ Active Users  │ Revenue       │\n│               │               │               │\n│    12,543     │    8,921      │  $145,293     │\n│   ↑ 12%      │   ↑ 8%       │  ↑ 23%       │\n├───────────────┴───────────────┼───────────────┤\n│                               │               │\n│      User Growth Chart        │ Top Products  │\n│                               │               │\n│         ╱╲    ╱╲             │ 1. Product A  │\n│        ╱  ╲  ╱  ╲            │ 2. Product B  │\n│       ╱    ╲╱    ╲           │ 3. Product C  │\n│                               │               │\n└───────────────────────────────┴───────────────┘\n*/\n```\n\n#### 타입 6: Mobile Layout\n\n모바일 뷰 레이아웃입니다.\n\n```typescript\ninterface MobileLayout {\n  type: \"mobile\";\n  width: number; // 375px (iPhone) or 414px (iPhone Plus)\n  sections: MobileSection[];\n}\n\ninterface MobileSection {\n  type: \"header\" | \"content\" | \"navigation\" | \"fab\";\n  content: string;\n  height?: number;\n}\n\n// ASCII 아트 출력 예시 (iPhone 크기)\n/*\n┌──────────────────┐\n│  ☰  App Title  🔍│  Header\n├──────────────────┤\n│                  │\n│                  │\n│                  │\n│  Content Area    │\n│                  │\n│  Scroll Content  │\n│                  │\n│                  │\n│                  │\n│                  │\n│                  │\n│                  │\n├──────────────────┤\n│ 🏠  📱  👤  ⚙️  │  Bottom Nav\n└──────────────────┘\n        ⊕           Floating Action Button\n*/\n```\n\n### 3. preview_ui 도구 구현\n\n```typescript\ninterface PreviewUIParams {\n  layoutType: LayoutType;\n  code?: string; // JSX/HTML 코드 (선택적)\n  config?: LayoutConfig; // 직접 설정 (선택적)\n  width?: number; // 출력 너비 (기본: 80)\n  responsive?: boolean; // 반응형 시뮬레이션 (기본: false)\n}\n\ninterface PreviewUIResult {\n  ascii: string;\n  layout: ParsedLayout;\n  suggestions: string[];\n  responsive?: {\n    mobile: string;\n    tablet: string;\n    desktop: string;\n  };\n}\n\nclass UIPreviewTool {\n  async execute(params: PreviewUIParams): Promise<PreviewUIResult> {\n    // 1. 레이아웃 파싱\n    const layout = params.code\n      ? this.parseLayout(params.code)\n      : this.buildLayout(params.config!, params.layoutType);\n\n    // 2. ASCII 아트 생성\n    const renderer = this.getRenderer(params.layoutType);\n    const ascii = renderer.render(layout, params.width || 80);\n\n    // 3. 개선 제안 생성\n    const suggestions = this.generateSuggestions(layout);\n\n    // 4. 반응형 미리보기 (옵션)\n    let responsive;\n    if (params.responsive) {\n      responsive = {\n        mobile: renderer.render(layout, 40),\n        tablet: renderer.render(layout, 60),\n        desktop: renderer.render(layout, 100)\n      };\n    }\n\n    return {\n      ascii,\n      layout,\n      suggestions,\n      responsive\n    };\n  }\n\n  private parseLayout(code: string): ParsedLayout {\n    // JSX/HTML 파싱\n    const ast = parseJSX(code);\n\n    // 레이아웃 구조 추출\n    return this.extractLayoutStructure(ast);\n  }\n\n  private extractLayoutStructure(ast: JSXElement): ParsedLayout {\n    // div, section 등의 구조 분석\n    const structure = {\n      type: this.inferLayoutType(ast),\n      components: this.extractComponents(ast),\n      hierarchy: this.buildHierarchy(ast)\n    };\n\n    return structure;\n  }\n\n  private inferLayoutType(ast: JSXElement): LayoutType {\n    // 코드에서 레이아웃 타입 추론\n    const hasHeader = this.hasComponent(ast, \"header\");\n    const hasFooter = this.hasComponent(ast, \"footer\");\n    const hasSidebar = this.hasComponent(ast, \"sidebar\");\n    const hasGrid = this.hasGridLayout(ast);\n\n    if (hasHeader && hasFooter) {\n      return \"header-content-footer\";\n    } else if (hasSidebar) {\n      return \"sidebar\";\n    } else if (hasGrid) {\n      return \"grid\";\n    }\n\n    return \"custom\";\n  }\n\n  private generateSuggestions(layout: ParsedLayout): string[] {\n    const suggestions: string[] = [];\n\n    // 접근성 검사\n    if (!layout.hasSemanticHTML) {\n      suggestions.push(\"시맨틱 HTML 태그 사용을 권장합니다 (header, nav, main, footer)\");\n    }\n\n    // 반응형 검사\n    if (!layout.isResponsive) {\n      suggestions.push(\"미디어 쿼리를 추가하여 반응형 디자인을 구현하세요\");\n    }\n\n    // 성능 검사\n    if (layout.nestingDepth > 5) {\n      suggestions.push(`중첩 깊이가 ${layout.nestingDepth}입니다. 5 이하로 줄이는 것을 권장합니다`);\n    }\n\n    return suggestions;\n  }\n}\n```\n\n### 4. 레이아웃 자동 감지\n\n코드에서 자동으로 레이아웃을 감지합니다.\n\n```typescript\nclass LayoutDetector {\n  detect(code: string): DetectedLayout {\n    const ast = this.parse(code);\n\n    // 1. 구조 분석\n    const structure = this.analyzeStructure(ast);\n\n    // 2. CSS 분석\n    const styles = this.extractStyles(ast);\n\n    // 3. 레이아웃 타입 결정\n    const layoutType = this.determineLayoutType(structure, styles);\n\n    // 4. 세부 설정 추출\n    const config = this.extractConfig(structure, styles, layoutType);\n\n    return {\n      type: layoutType,\n      config,\n      confidence: this.calculateConfidence(structure, styles)\n    };\n  }\n\n  private analyzeStructure(ast: ASTNode): StructureAnalysis {\n    return {\n      hasHeader: this.findElement(ast, [\"header\", \"Header\"]),\n      hasFooter: this.findElement(ast, [\"footer\", \"Footer\"]),\n      hasSidebar: this.findElement(ast, [\"aside\", \"Sidebar\", \"Navigation\"]),\n      hasGrid: this.hasGridDisplay(ast),\n      hasFlex: this.hasFlexDisplay(ast),\n      componentCount: this.countComponents(ast),\n      nestingDepth: this.calculateNestingDepth(ast)\n    };\n  }\n\n  private extractStyles(ast: ASTNode): StyleAnalysis {\n    const styles = {\n      display: [],\n      layout: [],\n      grid: null,\n      flex: null\n    };\n\n    // className, style prop에서 스타일 추출\n    this.traverseAST(ast, node => {\n      if (node.type === \"JSXAttribute\" && node.name === \"className\") {\n        styles.layout.push(...this.parseClassName(node.value));\n      }\n\n      if (node.type === \"JSXAttribute\" && node.name === \"style\") {\n        const inlineStyles = this.parseInlineStyle(node.value);\n        if (inlineStyles.display === \"grid\") {\n          styles.grid = inlineStyles;\n        }\n        if (inlineStyles.display === \"flex\") {\n          styles.flex = inlineStyles;\n        }\n      }\n    });\n\n    return styles;\n  }\n\n  private determineLayoutType(\n    structure: StructureAnalysis,\n    styles: StyleAnalysis\n  ): LayoutType {\n    // 규칙 기반 타입 결정\n    if (structure.hasHeader && structure.hasFooter) {\n      return \"header-content-footer\";\n    }\n\n    if (structure.hasSidebar) {\n      return \"sidebar\";\n    }\n\n    if (structure.hasGrid || styles.grid) {\n      return \"grid\";\n    }\n\n    if (styles.flex?.flexDirection === \"column\") {\n      const ratio = this.calculateSplitRatio(structure);\n      if (ratio) {\n        return \"split\";\n      }\n    }\n\n    if (this.isDashboard(structure)) {\n      return \"dashboard\";\n    }\n\n    if (this.isMobile(structure, styles)) {\n      return \"mobile\";\n    }\n\n    return \"custom\";\n  }\n}\n```\n\n## 사용 예시\n\n### 예시 1: 기본 레이아웃 미리보기\n\n```typescript\nUser: \"이 레이아웃 미리보기 보여줘\"\n\n// React 컴포넌트 코드\nconst Layout = () => (\n  <div>\n    <header>\n      <h1>My App</h1>\n      <nav>Navigation</nav>\n    </header>\n    <main>\n      <p>Content here</p>\n    </main>\n    <footer>\n      <p>Footer</p>\n    </footer>\n  </div>\n);\n\n// hi-ai 실행\nconst preview = await previewUI({\n  code: layoutCode,\n  width: 80\n});\n\n// 출력\n/*\n┌─────────────────────────────────────────────┐\n│              HEADER (60px)                   │\n│  My App          Navigation                  │\n├─────────────────────────────────────────────┤\n│                                              │\n│                                              │\n│            MAIN CONTENT AREA                 │\n│              Content here                    │\n│                                              │\n│                                              │\n│                                              │\n├─────────────────────────────────────────────┤\n│          FOOTER (40px)                       │\n│               Footer                         │\n└─────────────────────────────────────────────┘\n\n레이아웃 타입: Header-Content-Footer\n감지 신뢰도: 98%\n\n개선 제안:\n- header에 role=\"banner\" 추가를 권장합니다\n- main에 role=\"main\" 추가를 권장합니다\n- footer에 role=\"contentinfo\" 추가를 권장합니다\n*/\n```\n\n### 예시 2: 반응형 미리보기\n\n```typescript\nUser: \"이 레이아웃 반응형으로 어떻게 보이는지 보여줘\"\n\nconst preview = await previewUI({\n  layoutType: \"sidebar\",\n  config: {\n    sidebar: { width: 240, position: \"left\" },\n    main: { content: \"Main content\" }\n  },\n  responsive: true\n});\n\n// 출력\n/*\n=== MOBILE (375px) ===\n┌─────────────────┐\n│   ☰ Menu        │\n├─────────────────┤\n│                 │\n│                 │\n│  Main Content   │\n│                 │\n│                 │\n└─────────────────┘\n\n=== TABLET (768px) ===\n┌──────┬──────────────────────┐\n│      │                      │\n│ Menu │   Main Content       │\n│      │                      │\n└──────┴──────────────────────┘\n\n=== DESKTOP (1440px) ===\n┌──────────┬────────────────────────────────┐\n│          │                                │\n│          │                                │\n│  Sidebar │      Main Content Area         │\n│  (240px) │                                │\n│          │                                │\n└──────────┴────────────────────────────────┘\n\n반응형 분석:\n- Mobile: 사이드바가 햄버거 메뉴로 변환\n- Tablet: 사이드바가 좁아짐 (160px)\n- Desktop: 사이드바가 고정폭 유지 (240px)\n*/\n```\n\n### 예시 3: 대시보드 레이아웃\n\n```typescript\nUser: \"대시보드 레이아웃 만들어줘 - 통계 3개, 차트 2개, 테이블 1개\"\n\nconst preview = await previewUI({\n  layoutType: \"dashboard\",\n  config: {\n    widgets: [\n      { type: \"stats\", title: \"Total Users\", position: { row: 0, col: 0 }, size: { rows: 1, cols: 1 } },\n      { type: \"stats\", title: \"Revenue\", position: { row: 0, col: 1 }, size: { rows: 1, cols: 1 } },\n      { type: \"stats\", title: \"Active\", position: { row: 0, col: 2 }, size: { rows: 1, cols: 1 } },\n      { type: \"chart\", title: \"Growth\", position: { row: 1, col: 0 }, size: { rows: 2, cols: 2 } },\n      { type: \"chart\", title: \"Revenue\", position: { row: 1, col: 2 }, size: { rows: 1, cols: 1 } },\n      { type: \"table\", title: \"Recent\", position: { row: 2, col: 2 }, size: { rows: 1, cols: 1 } }\n    ]\n  }\n});\n\n// 출력\n/*\n┌───────────────┬───────────────┬───────────────┐\n│  Total Users  │   Revenue     │   Active      │\n│    12,543     │  $145,293     │   8,921       │\n│   ↑ 12%      │  ↑ 23%       │  ↑ 8%        │\n├───────────────┴───────────────┼───────────────┤\n│                               │   Revenue     │\n│      User Growth Chart        │   (This Mo.)  │\n│                               ├───────────────┤\n│         ╱╲    ╱╲             │ Recent Orders │\n│        ╱  ╲  ╱  ╲            │ #1234 - $299  │\n│       ╱    ╲╱    ╲           │ #1235 - $499  │\n│                               │ #1236 - $199  │\n└───────────────────────────────┴───────────────┘\n\n레이아웃 분석:\n- 3x3 그리드 기반\n- 통계 위젯: 1x1 (3개)\n- 차트 위젯: 2x2 (1개), 1x1 (1개)\n- 테이블 위젯: 1x1 (1개)\n\n추천:\n- 반응형을 위해 최소 너비 설정 (min-width: 1200px)\n- 모바일에서는 세로 스택으로 전환\n*/\n```\n\n### 예시 4: 컴포넌트 계층 시각화\n\n```typescript\nUser: \"이 컴포넌트 구조 보여줘\"\n\n// 복잡한 중첩 구조\nconst App = () => (\n  <Layout>\n    <Header>\n      <Logo />\n      <Navigation>\n        <NavItem />\n        <NavItem />\n      </Navigation>\n    </Header>\n    <Main>\n      <Sidebar>\n        <Menu />\n      </Sidebar>\n      <Content>\n        <Article>\n          <Header />\n          <Body />\n          <Comments>\n            <Comment />\n            <Comment />\n          </Comments>\n        </Article>\n      </Content>\n    </Main>\n  </Layout>\n);\n\n// hi-ai 출력\n/*\nComponent Hierarchy:\n\nLayout\n├─ Header\n│  ├─ Logo\n│  └─ Navigation\n│     ├─ NavItem\n│     └─ NavItem\n└─ Main\n   ├─ Sidebar\n   │  └─ Menu\n   └─ Content\n      └─ Article\n         ├─ Header\n         ├─ Body\n         └─ Comments\n            ├─ Comment\n            └─ Comment\n\n통계:\n- 총 컴포넌트: 14개\n- 최대 중첩 깊이: 5\n- 재사용 컴포넌트: NavItem (2), Comment (2)\n\n경고:\n- 중첩 깊이가 5입니다. 4 이하를 권장합니다.\n- Article > Header가 Layout > Header와 충돌할 수 있습니다.\n  이름을 ArticleHeader로 변경하는 것을 고려하세요.\n*/\n```\n\n## 기술적 세부사항\n\n### ASCII 렌더링 엔진\n\n```typescript\nclass ASCIIRenderer {\n  private boxChars = {\n    topLeft: \"┌\",\n    topRight: \"┐\",\n    bottomLeft: \"└\",\n    bottomRight: \"┘\",\n    horizontal: \"─\",\n    vertical: \"│\",\n    cross: \"┼\",\n    tDown: \"┬\",\n    tUp: \"┴\",\n    tRight: \"├\",\n    tLeft: \"┤\"\n  };\n\n  public drawBox(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    title?: string\n  ): string[] {\n    const lines: string[] = [];\n\n    // 상단\n    let topLine = this.boxChars.topLeft;\n    if (title) {\n      const titlePadding = Math.floor((width - title.length - 2) / 2);\n      topLine += this.boxChars.horizontal.repeat(titlePadding);\n      topLine += ` ${title} `;\n      topLine += this.boxChars.horizontal.repeat(width - titlePadding - title.length - 3);\n    } else {\n      topLine += this.boxChars.horizontal.repeat(width - 2);\n    }\n    topLine += this.boxChars.topRight;\n    lines.push(topLine);\n\n    // 중간\n    for (let i = 0; i < height - 2; i++) {\n      lines.push(\n        this.boxChars.vertical +\n        \" \".repeat(width - 2) +\n        this.boxChars.vertical\n      );\n    }\n\n    // 하단\n    const bottomLine =\n      this.boxChars.bottomLeft +\n      this.boxChars.horizontal.repeat(width - 2) +\n      this.boxChars.bottomRight;\n    lines.push(bottomLine);\n\n    return lines;\n  }\n\n  public drawGrid(\n    rows: number,\n    cols: number,\n    cellWidth: number,\n    cellHeight: number\n  ): string[] {\n    const lines: string[] = [];\n    const totalWidth = cellWidth * cols + cols + 1;\n\n    // 상단 테두리\n    let topLine = this.boxChars.topLeft;\n    for (let col = 0; col < cols; col++) {\n      topLine += this.boxChars.horizontal.repeat(cellWidth);\n      topLine += col < cols - 1 ? this.boxChars.tDown : this.boxChars.topRight;\n    }\n    lines.push(topLine);\n\n    // 각 행\n    for (let row = 0; row < rows; row++) {\n      // 셀 내용\n      for (let lineInCell = 0; lineInCell < cellHeight; lineInCell++) {\n        let line = this.boxChars.vertical;\n        for (let col = 0; col < cols; col++) {\n          line += \" \".repeat(cellWidth);\n          line += this.boxChars.vertical;\n        }\n        lines.push(line);\n      }\n\n      // 행 구분선 (마지막 행 제외)\n      if (row < rows - 1) {\n        let dividerLine = this.boxChars.tRight;\n        for (let col = 0; col < cols; col++) {\n          dividerLine += this.boxChars.horizontal.repeat(cellWidth);\n          dividerLine += col < cols - 1 ? this.boxChars.cross : this.boxChars.tLeft;\n        }\n        lines.push(dividerLine);\n      }\n    }\n\n    // 하단 테두리\n    let bottomLine = this.boxChars.bottomLeft;\n    for (let col = 0; col < cols; col++) {\n      bottomLine += this.boxChars.horizontal.repeat(cellWidth);\n      bottomLine += col < cols - 1 ? this.boxChars.tUp : this.boxChars.bottomRight;\n    }\n    lines.push(bottomLine);\n\n    return lines;\n  }\n\n  public centerText(text: string, width: number): string {\n    if (text.length >= width) {\n      return text.substring(0, width);\n    }\n\n    const padding = Math.floor((width - text.length) / 2);\n    return \" \".repeat(padding) + text + \" \".repeat(width - padding - text.length);\n  }\n\n  public alignLeft(text: string, width: number): string {\n    return text + \" \".repeat(Math.max(0, width - text.length));\n  }\n\n  public alignRight(text: string, width: number): string {\n    return \" \".repeat(Math.max(0, width - text.length)) + text;\n  }\n}\n```\n\n### 성능 최적화\n\n```typescript\n// 렌더링 캐시\nclass CachedPreviewRenderer {\n  private cache = new Map<string, string>();\n\n  render(layout: LayoutConfig): string {\n    const key = this.generateKey(layout);\n\n    if (this.cache.has(key)) {\n      return this.cache.get(key)!;\n    }\n\n    const result = this.doRender(layout);\n\n    this.cache.set(key, result);\n\n    return result;\n  }\n\n  private generateKey(layout: LayoutConfig): string {\n    return JSON.stringify(layout);\n  }\n}\n```\n\n## 업그레이드 가이드\n\n### v1.1.0에서 v1.2.0으로\n\n**1. 패키지 업데이트**\n\n```bash\nnpm update @su-record/hi-ai\n```\n\n**2. 새 기능 사용**\n\n```typescript\n// preview_ui 도구 사용\nconst preview = await tools.execute(\"preview_ui\", {\n  layoutType: \"header-content-footer\",\n  width: 80\n});\n\nconsole.log(preview.ascii);\n```\n\n### Breaking Changes\n\n없음.\n\n### 새로 추가된 도구\n\n- `preview_ui`: UI 레이아웃 미리보기\n\n## 성능 벤치마크\n\n| 작업 | 시간 |\n|------|------|\n| 레이아웃 파싱 | 50ms |\n| ASCII 렌더링 | 30ms |\n| 반응형 미리보기 (3개) | 90ms |\n| 총 처리 시간 | 170ms |\n\n## 알려진 제한사항\n\n1. 현재는 기본 레이아웃만 지원\n2. 복잡한 CSS 애니메이션은 표현 불가\n3. 터미널 너비에 따라 표시가 깨질 수 있음\n\n## 참고 자료\n\n- [ASCII Art Wikipedia](https://en.wikipedia.org/wiki/ASCII_art)\n- [Box Drawing Characters](https://en.wikipedia.org/wiki/Box-drawing_character)\n- [hi-ai GitHub](https://github.com/su-record/hi-ai)\n\n---\n\n**릴리즈 날짜:** 2024-10-17\n**도구 개수:** 34개\n**주요 기능:** UI 미리보기, ASCII 아트, 6가지 레이아웃 타입\n\n---\n\n> 이전 편: [hi-ai MCP v1.1.0: 시맨틱 코드 분석으로 코드 이해도 향상](tech-hi-ai-03.md)\n> 다음 편: [hi-ai MCP v1.3.0: Smithery 품질 점수 17% 향상과 4개 핵심 라이브러리](tech-hi-ai-05.md)",
      "description": "ASCII 아트 기반 UI 미리보기 - 6가지 레이아웃 타입 지원으로 터미널에서 즉시 확인 가능한 시각화 시스템",
      "tags": [
        "hi-ai",
        "mcp",
        "ui-preview",
        "ascii-art",
        "developer-tools",
        "release"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/tech-hi-ai-04.md"
    },
    {
      "slug": "tech-hi-ai-05",
      "title": "hi-ai MCP v1.3.0: Smithery 품질 점수 17% 향상과 4개 핵심 라이브러리",
      "date": "2025-11-16T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP v1.3.0: Smithery 품질 점수 17% 향상과 4개 핵심 라이브러리\n\n## Smithery 품질 점수 개선\n\nv1.3.0에서는 **Smithery 품질 점수를 54점에서 63점으로 끌어올렸습니다.** 17%의 점수 향상을 달성했습니다.\n\n### 점수 향상 항목\n\n**1. 도구 메타데이터 추가 (+9점)**\n\n34개 모든 도구에 `title`과 `audience` 메타데이터를 추가했습니다.\n\n```typescript\ninterface ToolAnnotation {\n  title: string;\n  audience: string[];\n}\n```\n\n이제 각 도구가 어떤 용도인지, 누구를 위한 것인지 명확하게 표시됩니다.\n\n**2. package.json 메타데이터 강화 (+10점)**\n\n패키지 정보를 대폭 개선했습니다:\n- `displayName`: \"Hi-AI MCP Server\"\n- `homepage`: GitHub 페이지 링크\n- `repository`: 저장소 정보\n- `bugs`: 이슈 트래커\n- `icon`: SVG 아이콘\n- 15개의 새로운 키워드\n\n**3. Hi-AI 아이콘 제작 (+7점)**\n\n512x512 크기의 SVG 아이콘을 디자인했습니다. 손을 흔드는 로봇 캐릭터가 \"Hi, AI!\" 말풍선을 들고 있는 디자인으로, 친근하면서도 전문적인 느낌을 전달합니다.\n\n---\n\n## 4개 핵심 라이브러리 추가\n\nv1.3.0에서는 시스템의 핵심이 되는 4개의 라이브러리를 새롭게 도입했습니다.\n\n### 1. MemoryManager: SQLite 기반 메모리 관리\n\n대화 컨텍스트를 SQLite로 관리하는 시스템입니다.\n\n**핵심 기능:**\n- 세션별 메모리 저장 및 조회\n- 타임스탬프 기반 메모리 정렬\n- 효율적인 메모리 검색\n\n**장점:**\n- 파일 기반보다 빠른 조회 속도\n- 트랜잭션으로 데이터 무결성 보장\n- 확장 가능한 구조\n\n### 2. ContextCompressor: 지능형 컨텍스트 압축\n\n긴 대화 내역을 효율적으로 압축하는 시스템입니다.\n\n**압축 전략:**\n- 중요한 정보 우선 보존\n- 반복 내용 제거\n- 토큰 수 기반 자동 압축\n\n**효과:**\n- 토큰 사용량 감소\n- 응답 속도 향상\n- 컨텍스트 윈도우 효율화\n\n### 3. ProjectCache: LRU 캐싱 시스템\n\n프로젝트 분석 결과를 캐싱하는 시스템입니다.\n\n**캐싱 전략:**\n- LRU (Least Recently Used) 알고리즘\n- 파일 변경 감지\n- 자동 캐시 무효화\n\n**성능 개선:**\n- 반복 분석 시간 대폭 감소\n- 메모리 사용량 최적화\n- 빠른 프로젝트 재분석\n\n### 4. PythonParser: Python AST 분석 지원\n\n기존 TypeScript/JavaScript에 이어 **Python 코드 분석 기능**을 추가했습니다.\n\n**지원 기능:**\n- 함수 정의 추출\n- 클래스 구조 분석\n- 의존성 탐지\n- 코드 복잡도 측정\n\n**의미:**\n- 다중 언어 지원 확장\n- Python 프로젝트 분석 가능\n- 언어별 최적화된 분석\n\n---\n\n## 성능 최적화\n\n### 시간 복잡도 개선\n\n**기존:** O(n²)\n**개선:** O(n)\n\n프로젝트 캐싱 시스템을 도입하면서 반복 분석 시간을 획기적으로 줄였습니다.\n\n### SQLite 트랜잭션 최적화\n\n메모리 저장 시 트랜잭션을 사용해 데이터 무결성을 보장하면서도 속도를 개선했습니다.\n\n### 응답 포맷 간소화\n\n불필요한 포맷팅을 제거하고 핵심 정보만 전달하도록 개선했습니다.\n\n---\n\n## 코드 품질 개선\n\n### TypeScript Strict Mode 준수\n\n모든 코드가 TypeScript strict mode를 통과하도록 개선했습니다.\n\n**개선 사항:**\n- 타입 안정성 강화\n- null/undefined 처리 명확화\n- 암시적 any 제거\n\n### 중앙 집중식 타입 시스템\n\n`ToolAnnotation` 인터페이스를 중심으로 타입 시스템을 재구성했습니다.\n\n**효과:**\n- 타입 일관성 확보\n- 유지보수 용이성 향상\n- IDE 지원 개선\n\n### 100% 테스트 커버리지\n\n모든 빌드 테스트를 통과했습니다.\n\n---\n\n## README.md 개선\n\n문서를 대폭 개선했습니다.\n\n**제거:**\n- 검증되지 않은 성능 수치\n\n**추가:**\n- 더 구조화된 문서\n- Smithery 기여자 목록\n- 명확한 설치 가이드\n\n**개선:**\n- 기능별 섹션 분리\n- 예제 코드 추가\n- 사용 사례 명시\n\n---\n\n## 설치 방법\n\n### npm\n\n```bash\nnpm install -g @su-record/hi-ai\n```\n\n### Smithery (원클릭)\n\n[Smithery에서 설치](https://smithery.ai/server/@su-record/hi-ai)\n\n---\n\n## 통계\n\n**커밋:**\n- 지난 릴리즈 이후 4개 커밋\n\n**코드 변경:**\n- 40개 파일 수정\n- +837줄 추가\n- -349줄 삭제\n\n---\n\n## 38개 도구, 9개 카테고리\n\nv1.3.0은 **38개의 전문화된 도구**를 제공합니다:\n\n1. **시맨틱 코드 분석** - TypeScript/JavaScript/Python\n2. **지능형 메모리 관리** - SQLite 기반\n3. **코드 품질 평가** - 실시간 리뷰\n4. **프롬프트 엔지니어링** - 자동 생성\n5. **UI 미리보기** - ASCII 아트\n6. **프로젝트 캐싱** - LRU 알고리즘\n7. **컨텍스트 압축** - 토큰 최적화\n8. **의존성 분석** - 다중 언어\n9. **성능 모니터링** - 실시간 추적\n\n---\n\n## 시스템 요구사항\n\n- **Node.js**: 18.0 이상\n- **TypeScript**: 5.0 이상\n- **MCP 호환 클라이언트**: Claude Desktop 등\n\n---\n\n## 감사의 말\n\nSmithery와 Claude의 지원에 감사드립니다.\n\n품질 점수 개선을 위한 피드백과 도움이 v1.3.0 개발에 큰 도움이 되었습니다.\n\n---\n\n## 다음은?\n\nv1.3.0은 품질과 성능의 기반을 다졌습니다.\n\n다음 버전에서는:\n- 더 많은 언어 지원 (Go, Rust, Java)\n- 고급 분석 기능\n- 실시간 협업 기능\n\n**hi-ai는 계속 발전합니다.**\n\n---\n\n> 이전 편: [hi-ai MCP v1.2.0: UI 미리보기 시스템으로 개발 워크플로우 혁신](tech-hi-ai-04.md)\n\n**GitHub**: https://github.com/su-record/hi-ai\n**Release**: https://github.com/su-record/hi-ai/releases/tag/v1.3.0",
      "description": "도구 메타데이터 추가, 패키지 정보 개선, 아이콘 제작으로 품질 점수 54→63점 달성. 4개 핵심 라이브러리로 성능 최적화",
      "tags": [
        "hi-ai",
        "mcp",
        "smithery",
        "performance",
        "typescript",
        "release"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/tech-hi-ai-05.md"
    },
    {
      "slug": "tech-redis-optimization",
      "title": "[기술 심화] Redis 캐싱으로 API 응답속도 76% 개선하기 - 실전 최적화 가이드",
      "date": "2025-11-10T00:00:00.000Z",
      "category": "tech",
      "content": "# [기술 심화] Redis 캐싱으로 API 응답속도 76% 개선하기\n\n## 들어가며\n\n지난주 fallingo 백엔드에 Redis 캐싱을 적용하면서 API 응답속도를 76%나 개선했습니다. 이번 글에서는 단순히 \"Redis를 적용했다\"는 이야기가 아니라, 왜 Redis를 선택했는지, 어떻게 구현했는지, 실제 성능이 얼마나 나왔는지, 그리고 어떤 문제를 겪고 해결했는지에 대한 실전 경험을 상세히 공유해보려고 합니다.\n\n## 문제 상황: 느린 API 응답 속도\n\n### Before: Redis 적용 전\n\nfallingo 백엔드 API들의 평균 응답 시간:\n\n```\nGET /feeds        : 800ms (피드 목록 조회)\nGET /users/{id}   : 500ms (프로필 조회)\nGET /follows      : 600ms (팔로우 목록)\nGET /stats        : 400ms (통계 조회)\nPOST /feeds/{id}/like : 2100ms (좋아요)\n```\n\n특히 피드 목록 조회가 느렸습니다. 왜냐하면:\n\n```python\n@app.get(\"/feeds\")\nasync def get_feeds(skip: int = 0, limit: int = 20):\n    # 1. 피드 목록 조회 (300ms)\n    feeds = await db.execute(\n        \"SELECT * FROM feeds ORDER BY created_at DESC LIMIT $1 OFFSET $2\",\n        limit, skip\n    )\n\n    # 2. 각 피드마다 작성자 정보 조회 (200ms)\n    for feed in feeds:\n        feed.author = await db.fetchone(\n            \"SELECT * FROM users WHERE id = $1\",\n            feed.author_id\n        )\n\n    # 3. 각 피드마다 좋아요 수 조회 (200ms)\n    for feed in feeds:\n        feed.likes_count = await db.fetchone(\n            \"SELECT COUNT(*) FROM likes WHERE feed_id = $1\",\n            feed.id\n        )\n\n    # 4. 각 피드마다 댓글 수 조회 (100ms)\n    for feed in feeds:\n        feed.comments_count = await db.fetchone(\n            \"SELECT COUNT(*) FROM comments WHERE feed_id = $1\",\n            feed.id\n        )\n\n    return feeds  # 총 800ms\n```\n\n**N+1 쿼리 문제**가 심각했습니다. 피드 20개 조회하면 60개 이상의 쿼리가 발생했습니다.\n\n### 해결 방안 검토\n\n여러 방법을 고민했습니다:\n\n**1) JOIN으로 쿼리 최적화**\n```sql\nSELECT f.*, u.*, COUNT(l.id) as likes, COUNT(c.id) as comments\nFROM feeds f\nLEFT JOIN users u ON f.author_id = u.id\nLEFT JOIN likes l ON f.id = l.feed_id\nLEFT JOIN comments c ON f.id = c.feed_id\nGROUP BY f.id, u.id\n```\n\n장점: 단일 쿼리로 해결\n단점: 복잡한 JOIN, 여전히 매번 DB 조회\n\n**2) Materialized View**\n```sql\nCREATE MATERIALIZED VIEW feed_view AS ...\n```\n\n장점: 미리 계산된 결과\n단점: 업데이트 타이밍 문제, 실시간성 부족\n\n**3) Redis 캐싱**\n```python\n# 캐시 확인\ncached = await redis.get(f\"feed:{feed_id}\")\nif cached:\n    return cached\n\n# 없으면 DB 조회 후 캐싱\ndata = await db.fetch(...)\nawait redis.setex(f\"feed:{feed_id}\", 300, data)\nreturn data\n```\n\n장점: 빠른 응답, 유연한 TTL 설정, 실시간 무효화 가능\n단점: 캐시 관리 복잡도 증가\n\n**결론: Redis 캐싱을 선택했습니다!**\n\n이유는:\n- Google for Startups Cloud Program으로 GCP Memorystore Redis 무료 사용이 가능했습니다\n- 실시간성이 중요한 피드 서비스에 적합했습니다\n- TTL로 자동 만료가 가능합니다\n- 필요시 즉시 무효화가 가능합니다\n\n## Redis 캐싱 시스템 구축\n\n### 1. GCP Memorystore Redis 인스턴스 생성\n\n```bash\n# GCP Console에서 Redis 인스턴스 생성\n# Tier: Basic (개발/테스트용)\n# Capacity: 1GB\n# Region: asia-northeast3 (서울)\n# Version: Redis 7.0\n```\n\n### 2. FastAPI에 Redis 클라이언트 설정\n\n```python\n# config.py\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    REDIS_HOST: str = \"10.0.0.3\"  # GCP Memorystore 내부 IP\n    REDIS_PORT: int = 6379\n    REDIS_SOCKET_TIMEOUT: int = 5\n    REDIS_SOCKET_CONNECT_TIMEOUT: int = 5\n\nsettings = Settings()\n```\n\n```python\n# redis_client.py\nimport redis\nimport json\nfrom typing import Optional, Any\n\nclass RedisClient:\n    def __init__(self):\n        try:\n            self.client = redis.Redis(\n                host=settings.REDIS_HOST,\n                port=settings.REDIS_PORT,\n                decode_responses=True,\n                socket_connect_timeout=settings.REDIS_SOCKET_CONNECT_TIMEOUT,\n                socket_timeout=settings.REDIS_SOCKET_TIMEOUT\n            )\n            # 연결 테스트\n            self.client.ping()\n            self.available = True\n        except Exception as e:\n            print(f\"Redis connection failed: {e}\")\n            self.client = None\n            self.available = False\n\n    async def get(self, key: str) -> Optional[Any]:\n        \"\"\"캐시 조회\"\"\"\n        if not self.available:\n            return None\n\n        try:\n            value = self.client.get(key)\n            if value:\n                return json.loads(value)\n            return None\n        except Exception as e:\n            print(f\"Redis GET error: {e}\")\n            return None\n\n    async def setex(self, key: str, ttl: int, value: Any) -> bool:\n        \"\"\"캐시 저장 (TTL 포함)\"\"\"\n        if not self.available:\n            return False\n\n        try:\n            self.client.setex(\n                key,\n                ttl,\n                json.dumps(value, default=str)\n            )\n            return True\n        except Exception as e:\n            print(f\"Redis SETEX error: {e}\")\n            return False\n\n    async def delete(self, *keys: str) -> bool:\n        \"\"\"캐시 삭제\"\"\"\n        if not self.available:\n            return False\n\n        try:\n            self.client.delete(*keys)\n            return True\n        except Exception as e:\n            print(f\"Redis DELETE error: {e}\")\n            return False\n\nredis_client = RedisClient()\n```\n\n**핵심 포인트**:\n- **타임아웃 설정**: Cloud Run에서 startup timeout 방지\n- **연결 실패 처리**: Redis 없이도 서비스 정상 동작 (Fallback)\n- **JSON 직렬화**: Python 객체를 문자열로 변환\n\n### 3. 서비스별 캐싱 전략\n\n#### 3.1 피드 목록 캐싱 (TTL: 300초)\n\n```python\n# services/feed_service.py\nasync def get_feeds(skip: int = 0, limit: int = 20) -> list:\n    # 캐시 키 생성\n    cache_key = f\"feeds:list:{skip}:{limit}\"\n\n    # 캐시 조회\n    cached = await redis_client.get(cache_key)\n    if cached:\n        return cached\n\n    # DB 조회\n    feeds = await db.execute(\n        \"\"\"\n        SELECT f.*, u.username, u.profile_image,\n               COUNT(DISTINCT l.id) as likes_count,\n               COUNT(DISTINCT c.id) as comments_count\n        FROM feeds f\n        LEFT JOIN users u ON f.author_id = u.id\n        LEFT JOIN likes l ON f.id = l.feed_id\n        LEFT JOIN comments c ON f.id = c.feed_id\n        GROUP BY f.id, u.id\n        ORDER BY f.created_at DESC\n        LIMIT $1 OFFSET $2\n        \"\"\",\n        limit, skip\n    )\n\n    # 결과를 캐시에 저장 (5분)\n    await redis_client.setex(cache_key, 300, feeds)\n\n    return feeds\n```\n\n**왜 300초?**\n- 피드는 자주 업데이트되지만, 실시간이 아니어도 괜찮습니다\n- 5분 정도는 허용 가능한 지연입니다\n- 너무 짧으면 캐시 효과 감소, 너무 길면 오래된 데이터가 됩니다\n\n#### 3.2 사용자 프로필 캐싱 (TTL: 600초)\n\n```python\nasync def get_user_profile(user_id: int) -> dict:\n    cache_key = f\"user:profile:{user_id}\"\n\n    cached = await redis_client.get(cache_key)\n    if cached:\n        return cached\n\n    profile = await db.fetchone(\n        \"\"\"\n        SELECT u.*,\n               COUNT(DISTINCT f.id) as feeds_count,\n               COUNT(DISTINCT followers.id) as followers_count,\n               COUNT(DISTINCT following.id) as following_count\n        FROM users u\n        LEFT JOIN feeds f ON u.id = f.author_id\n        LEFT JOIN follows followers ON u.id = followers.following_id\n        LEFT JOIN follows following ON u.id = following.follower_id\n        WHERE u.id = $1\n        GROUP BY u.id\n        \"\"\",\n        user_id\n    )\n\n    # 10분 캐싱\n    await redis_client.setex(cache_key, 600, profile)\n\n    return profile\n```\n\n**왜 600초?**\n- 프로필은 자주 변경되지 않습니다\n- 팔로워 수 등은 약간의 지연을 허용할 수 있습니다\n- 더 긴 TTL로 캐시 효율을 극대화했습니다\n\n#### 3.3 팔로우 관계 캐싱 (TTL: 300초)\n\n```python\nasync def get_following_list(user_id: int) -> list:\n    cache_key = f\"user:{user_id}:following\"\n\n    cached = await redis_client.get(cache_key)\n    if cached:\n        return cached\n\n    following = await db.execute(\n        \"\"\"\n        SELECT u.* FROM users u\n        INNER JOIN follows f ON u.id = f.following_id\n        WHERE f.follower_id = $1\n        \"\"\",\n        user_id\n    )\n\n    await redis_client.setex(cache_key, 300, following)\n\n    return following\n```\n\n#### 3.4 통계 데이터 캐싱 (TTL: 180초)\n\n```python\nasync def get_feed_stats(feed_id: int) -> dict:\n    cache_key = f\"feed:{feed_id}:stats\"\n\n    cached = await redis_client.get(cache_key)\n    if cached:\n        return cached\n\n    stats = {\n        \"likes_count\": await db.fetchone(\n            \"SELECT COUNT(*) FROM likes WHERE feed_id = $1\", feed_id\n        ),\n        \"comments_count\": await db.fetchone(\n            \"SELECT COUNT(*) FROM comments WHERE feed_id = $1\", feed_id\n        ),\n        \"views_count\": await db.fetchone(\n            \"SELECT view_count FROM feeds WHERE id = $1\", feed_id\n        )\n    }\n\n    # 3분 캐싱\n    await redis_client.setex(cache_key, 180, stats)\n\n    return stats\n```\n\n**왜 180초?**\n- 통계는 실시간성이 더 중요합니다\n- 좋아요/댓글이 빠르게 변하기 때문입니다\n- 짧은 TTL로 최신성을 유지합니다\n\n### 4. 캐시 무효화 전략\n\n데이터가 변경되면 즉시 캐시를 삭제해야 합니다.\n\n#### 4.1 피드 생성 시\n\n```python\n@app.post(\"/feeds\")\nasync def create_feed(\n    content: str,\n    user_id: int = Depends(get_current_user),\n    background_tasks: BackgroundTasks = None\n):\n    # 피드 생성\n    feed = await db.execute(\n        \"INSERT INTO feeds (author_id, content) VALUES ($1, $2) RETURNING *\",\n        user_id, content\n    )\n\n    # 백그라운드에서 캐시 무효화\n    background_tasks.add_task(\n        invalidate_feed_caches,\n        user_id\n    )\n\n    return feed\n\nasync def invalidate_feed_caches(user_id: int):\n    \"\"\"피드 관련 캐시 무효화\"\"\"\n    # 피드 목록 캐시 삭제 (모든 페이지)\n    pattern = \"feeds:list:*\"\n    # Redis SCAN으로 패턴 매칭 키 찾기\n    keys = []\n    for key in redis_client.client.scan_iter(pattern):\n        keys.append(key)\n\n    if keys:\n        await redis_client.delete(*keys)\n\n    # 작성자 프로필 캐시 삭제\n    await redis_client.delete(f\"user:profile:{user_id}\")\n```\n\n#### 4.2 좋아요 시\n\n```python\n@app.post(\"/feeds/{feed_id}/like\")\nasync def like_feed(\n    feed_id: int,\n    user_id: int = Depends(get_current_user),\n    background_tasks: BackgroundTasks = None\n):\n    # 즉시 응답 (낙관적 업데이트)\n    background_tasks.add_task(\n        process_like,\n        feed_id, user_id\n    )\n\n    return {\"status\": \"processing\"}\n\nasync def process_like(feed_id: int, user_id: int):\n    # 좋아요 추가\n    await db.execute(\n        \"INSERT INTO likes (feed_id, user_id) VALUES ($1, $2)\",\n        feed_id, user_id\n    )\n\n    # 캐시 무효화\n    await redis_client.delete(\n        f\"feed:{feed_id}:stats\",  # 피드 통계\n        f\"feeds:list:*\"            # 피드 목록\n    )\n\n    # FCM 알림 전송\n    await send_notification(feed_id, user_id, \"like\")\n```\n\n**핵심**: 백그라운드에서 처리하니까 사용자는 빠르게 응답을 받습니다!\n\n#### 4.3 프로필 수정 시\n\n```python\n@app.put(\"/users/{user_id}\")\nasync def update_profile(\n    user_id: int,\n    data: dict,\n    background_tasks: BackgroundTasks = None\n):\n    # 프로필 수정\n    await db.execute(\n        \"UPDATE users SET ... WHERE id = $1\",\n        user_id\n    )\n\n    # 캐시 무효화\n    background_tasks.add_task(\n        invalidate_user_caches,\n        user_id\n    )\n\n    return {\"status\": \"success\"}\n\nasync def invalidate_user_caches(user_id: int):\n    \"\"\"사용자 관련 캐시 무효화\"\"\"\n    await redis_client.delete(\n        f\"user:profile:{user_id}\",\n        f\"user:{user_id}:following\",\n        f\"user:{user_id}:followers\"\n    )\n```\n\n## 성능 측정 결과\n\n### Before vs After\n\n| API | Before | After | 개선율 |\n|-----|--------|-------|--------|\n| GET /feeds | 800ms | 150ms | **81%** |\n| GET /users/{id} | 500ms | 100ms | **80%** |\n| GET /follows | 600ms | 120ms | **80%** |\n| GET /stats | 400ms | 200ms | **50%** |\n| POST /feeds/{id}/like | 2100ms | 500ms | **76%** |\n\n**평균 응답 시간: 860ms → 214ms (75% 개선)**\n\n### 캐시 히트율\n\n```\n총 요청 수: 10,000\n캐시 히트: 8,200 (82%)\n캐시 미스: 1,800 (18%)\n```\n\n**82%의 요청이 캐시에서 처리**됐습니다!\n\n### 데이터베이스 부하 감소\n\n```\nBefore Redis:\n- DB 쿼리 수: 50,000 / 시간\n- DB CPU 사용률: 65%\n\nAfter Redis:\n- DB 쿼리 수: 9,000 / 시간 (**82% 감소**)\n- DB CPU 사용률: 12% (**81% 감소**)\n```\n\nRedis 덕분에 DB 부하가 엄청나게 줄었습니다!\n\n## 겪었던 문제들과 해결\n\n### 문제 1: Cloud Run Startup Timeout\n\n**증상**:\n```\nERROR: Container failed to start.\nFailed to start and then listen on the port defined by the PORT environment variable.\n```\n\n**원인**:\nRedis 연결 시 타임아웃 설정이 없어서, 연결이 안 되면 무한정 기다렸습니다.\n\n**해결**:\n```python\nredis.Redis(\n    host=settings.REDIS_HOST,\n    port=settings.REDIS_PORT,\n    socket_connect_timeout=5,  # 타임아웃 추가!\n    socket_timeout=5\n)\n```\n\n### 문제 2: Redis 패키지 의존성 누락\n\n**증상**:\n```\nModuleNotFoundError: No module named 'redis'\n```\n\n**원인**:\n`requirements.txt`에 `redis` 패키지 추가를 깜빡했습니다.\n\n**해결**:\n```txt\nredis==5.0.1\n```\n\n### 문제 3: 직렬화 에러\n\n**증상**:\n```\nTypeError: Object of type datetime is not JSON serializable\n```\n\n**원인**:\nPython `datetime` 객체를 JSON으로 변환할 수 없었습니다.\n\n**해결**:\n```python\njson.dumps(value, default=str)  # datetime을 문자열로 변환\n```\n\n### 문제 4: 캐시 키 충돌\n\n**증상**:\n다른 사용자가 같은 캐시를 공유하는 버그.\n\n**원인**:\n캐시 키에 사용자 ID를 포함하지 않았습니다.\n\n**해결**:\n```python\n# Before\ncache_key = \"feeds:list:0:20\"  # 모든 사용자가 공유!\n\n# After\ncache_key = f\"user:{user_id}:feeds:list:0:20\"  # 사용자별 캐시\n```\n\n## 배운 점\n\n### 1. 캐싱은 만능이 아닙니다\n\n캐싱이 항상 좋은 것은 아닙니다:\n\n**캐싱이 좋은 경우**:\n- 자주 읽히는 데이터 (피드 목록, 프로필)\n- 변경이 드문 데이터 (설정, 카테고리)\n- 계산 비용이 높은 데이터 (통계, 집계)\n\n**캐싱이 안 좋은 경우**:\n- 실시간성이 중요한 데이터 (채팅 메시지)\n- 항상 다른 데이터 (검색 결과)\n- 한 번만 읽히는 데이터\n\n### 2. TTL 설정이 중요합니다\n\nTTL을 너무 짧게 하면:\n- 캐시 효과 감소\n- Redis 트래픽 증가\n\nTTL을 너무 길게 하면:\n- 오래된 데이터 제공\n- 사용자 경험 저하\n\n**적절한 균형**을 찾는 게 핵심입니다!\n\n### 3. Fallback 메커니즘 필수\n\nRedis가 죽으면 서비스 전체가 죽으면 안 됩니다.\n\n```python\ncached = await redis_client.get(key)\nif cached:\n    return cached\n\n# Redis 실패 시 DB 조회 (Fallback)\nreturn await db.fetch(...)\n```\n\n### 4. 모니터링이 중요합니다\n\n캐시 히트율, TTL 적정성, 메모리 사용량 등을 지속적으로 모니터링해야 합니다.\n\n```python\n# Redis INFO 명령으로 모니터링\ninfo = redis_client.client.info()\nprint(f\"Used memory: {info['used_memory_human']}\")\nprint(f\"Keyspace hits: {info['keyspace_hits']}\")\nprint(f\"Keyspace misses: {info['keyspace_misses']}\")\n```\n\n## 더 나아갈 방향\n\n캐싱은 끝이 아닙니다. 앞으로 더 개선할 부분들:\n\n**캐시 워밍**: 앱 시작 시 인기 피드를 미리 캐싱해두면 첫 사용자 경험이 더 좋아질 것입니다.\n\n**캐시 압축**: 큰 데이터는 gzip으로 압축해서 저장하면 메모리 효율이 올라갑니다.\n\n**Redis Cluster**: 트래픽이 증가하면 Primary/Replica 구조로 확장성을 확보할 수 있습니다.\n\n## 핵심 정리\n\nRedis 캐싱으로 **평균 응답속도 76% 개선**을 달성했습니다.\n\n성공의 요인:\n- **적절한 TTL 설정**: 데이터 특성별로 180초~600초 차등 적용\n- **즉각적인 무효화**: BackgroundTasks로 데이터 변경 시 실시간 캐시 삭제\n- **Fallback 메커니즘**: Redis 장애 시에도 서비스 정상 작동\n- **캐시 히트율 82%**: 데이터베이스 부하 82% 감소\n\n단순히 Redis를 붙인 게 아니라, 서비스 특성에 맞는 캐싱 전략을 설계했기에 가능했습니다.\n\n**그리고 AI(Claude)와의 협업 덕분에 3일 만에 완성할 수 있었습니다.**\n\n---\n\n**레퍼런스**\n- [Redis 공식 문서](https://redis.io/docs/)\n- [FastAPI BackgroundTasks](https://fastapi.tiangolo.com/tutorial/background-tasks/)\n- [GCP Memorystore for Redis](https://cloud.google.com/memorystore/docs/redis)",
      "description": "GCP Memorystore Redis를 활용한 FastAPI 백엔드 성능 최적화. 실제 성능 측정 데이터와 함께하는 캐싱 전략 완벽 가이드",
      "tags": [
        "fallingo",
        "redis",
        "caching",
        "performance",
        "fastapi",
        "gcp",
        "optimization",
        "technical"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/tech-redis-optimization.md"
    },
    {
      "slug": "tech-vibe-01",
      "title": "Vibe: SPEC 주도 AI 코딩 프레임워크로 바이브 코딩을 더 쉽게",
      "date": "2025-11-17T00:00:00.000Z",
      "category": "tech",
      "content": "# Vibe: SPEC 주도 AI 코딩 프레임워크로 바이브 코딩을 더 쉽게\n\n## 바이브 코딩, 더 체계적으로\n\nAI 개발 방법론 시리즈에서 이야기했던 **\"바이브 코딩을 위한 프레임워크\"**가 완성되었습니다. 자연어 요구사항을 프로덕션 코드로 변환하는 체계적인 프레임워크, **Vibe**입니다.\n\n## 왜 Vibe를 만들었나\n\nfallingo를 개발하면서 수십 번의 리셋을 경험했습니다. 일관성이 무너지고, 문서와 코드가 어긋나고, 같은 실수를 반복했습니다.\n\n순차적 문서 작성 방법론을 정립하고, SpecKit을 도입하면서 많이 개선되었지만, 여전히 불편한 점들이 있었습니다:\n\n- **매번 처음부터 구조를 설계해야 함**\n- **문서 작성 순서를 기억해야 함**\n- **AI에게 같은 설명을 반복해야 함**\n- **작업 단위를 수동으로 나눠야 함**\n\n\"이 모든 과정을 프레임워크로 만들면 어떨까?\" 하는 생각에서 Vibe가 시작되었습니다.\n\n---\n\n## Vibe란?\n\n**SPEC 주도 AI 코딩 프레임워크**입니다.\n\n자연어 요구사항을 받아서:\n1. EARS 기반 명세 작성\n2. 기술 구현 계획 수립\n3. 단계별 작업으로 분해\n4. 실행 및 검증\n\n이 모든 과정을 **체계적으로, 자동으로** 진행합니다.\n\n---\n\n## 핵심 특징\n\n### 1. Claude Code 최적화\n\nClaude Code에서 최적의 성능을 발휘하도록 설계되었습니다.\n\n### 2. SPEC 주도 개발\n\n**EARS (Easy Approach to Requirements Syntax)** 기반으로 명세를 작성합니다.\n\n명확한 요구사항 정의로 일관성을 유지합니다.\n\n### 3. 자동화된 계획 수립\n\n기술 구현 계획을 자동으로 생성합니다:\n- 아키텍처 설계\n- 기술 스택 선정\n- 비용 분석\n- 위험 요소 식별\n\n### 4. 작업 분해\n\n기능을 단계별, 의존성을 고려한 작업으로 자동 분해합니다.\n\n### 5. 38개 MCP 도구\n\nhi-ai MCP의 38개 도구가 통합되어 있습니다:\n- 코드 분석\n- 품질 검사\n- 성능 측정\n- UI 미리보기\n- 메모리 관리\n\n### 6. 다국어 지원\n\n한국어와 영어를 모두 지원합니다.\n\n### 7. 7개 전문 에이전트\n\n각 단계마다 전문화된 AI 에이전트가 작업합니다:\n- **Specification Agent**: 명세 작성\n- **Planning Agent**: 계획 수립\n- **Task Agent**: 작업 분해\n- **Backend Expert**: 백엔드 개발\n- **Frontend Expert**: 프론트엔드 개발\n- **Database Expert**: 데이터베이스 설계\n- **Quality Reviewer**: 품질 검수\n\n---\n\n## 핵심 워크플로우\n\n### 1. 프로젝트 초기화\n\n```bash\nvibe init\n```\n\n프로젝트 설정을 생성합니다.\n\n### 2. 명세 작성\n\n```bash\nvibe spec \"사용자 로그인 기능\"\n```\n\nEARS 기반으로 기능 명세를 자동 생성합니다.\n\n**생성되는 내용:**\n- 기능 설명\n- 요구사항 (필수/선택)\n- 제약사항\n- 예외 처리\n- 검증 기준\n\n### 3. 계획 수립\n\n```bash\nvibe plan \"사용자 로그인 기능\"\n```\n\n기술 구현 계획을 자동 생성합니다.\n\n**생성되는 내용:**\n- 아키텍처 설계\n- 기술 스택 선정\n- API 설계\n- 데이터베이스 스키마\n- 보안 고려사항\n- 비용 추정\n\n### 4. 작업 분해\n\n```bash\nvibe tasks \"사용자 로그인 기능\"\n```\n\n구현 작업을 단계별로 분해합니다.\n\n**생성되는 내용:**\n- Phase별 작업 구조\n- 작업 간 의존성\n- 우선순위\n- 예상 소요 시간\n- 검증 기준\n\n### 5. 작업 실행\n\n```bash\nvibe run \"Task 1-1\"\n```\n\n특정 작업을 실행합니다.\n\n### 6. 검증\n\n```bash\nvibe verify \"사용자 로그인 기능\"\n```\n\n구현 결과를 검증합니다.\n\n---\n\n## 실제 사용 예시\n\n### 시나리오: TODO 앱 개발\n\n**1단계: 명세 작성**\n\n```bash\nvibe spec \"할 일 목록 관리\"\n```\n\n**생성된 명세 (일부):**\n\n```\nWhen 사용자가 할 일을 입력하면\nThe system shall 데이터베이스에 저장한다\n\nWhen 사용자가 완료 버튼을 누르면\nThe system shall 해당 항목을 완료 상태로 변경한다\n\nWhere 인터넷 연결이 없을 때\nThe system shall 로컬에 저장 후 동기화한다\n```\n\n**2단계: 계획 수립**\n\n```bash\nvibe plan \"할 일 목록 관리\"\n```\n\n**생성된 계획 (일부):**\n\n```\n기술 스택:\n- Frontend: React 19\n- Backend: FastAPI\n- Database: PostgreSQL\n- State: Zustand\n\n아키텍처:\n- RESTful API\n- 낙관적 업데이트\n- 오프라인 지원\n\n예상 비용: $0 (오픈소스 스택)\n```\n\n**3단계: 작업 분해**\n\n```bash\nvibe tasks \"할 일 목록 관리\"\n```\n\n**생성된 작업 (일부):**\n\n```\nPhase 1: 데이터베이스\n  Task 1-1: 스키마 설계\n  Task 1-2: 마이그레이션 작성\n\nPhase 2: 백엔드 API\n  Task 2-1: CRUD 엔드포인트\n  Task 2-2: 인증 미들웨어\n\nPhase 3: 프론트엔드\n  Task 3-1: UI 컴포넌트\n  Task 3-2: 상태 관리\n```\n\n**4단계: 실행**\n\n```bash\nvibe run \"Task 1-1\"\n```\n\nAI가 스키마를 설계하고 코드를 생성합니다.\n\n---\n\n## 기존 방식 vs Vibe\n\n### 기존 방식\n\n```\n1. 기획서 작성 (수동)\n   ↓\n2. 엔티티 추출 (수동)\n   ↓\n3. ERD 설계 (수동)\n   ↓\n4. API 설계 (수동)\n   ↓\n5. 작업 분해 (수동)\n   ↓\n6. AI에게 설명 (반복)\n   ↓\n7. 코드 생성 (AI)\n   ↓\n8. 검증 (수동)\n```\n\n**문제점:**\n- 매번 처음부터\n- 일관성 유지 어려움\n- 시간 소모\n\n### Vibe 방식\n\n```\n1. vibe spec \"기능명\"\n   ↓\n2. vibe plan \"기능명\"\n   ↓\n3. vibe tasks \"기능명\"\n   ↓\n4. vibe run \"Task X-Y\"\n   ↓\n5. vibe verify \"기능명\"\n```\n\n**장점:**\n- 자동화된 프로세스\n- 구조적 일관성\n- 빠른 속도\n\n---\n\n## 통합된 MCP 도구\n\nhi-ai MCP의 38개 도구가 모두 통합되어 있습니다:\n\n**코드 분석:**\n- 복잡도 측정\n- 의존성 분석\n- 보안 취약점 검사\n\n**품질 관리:**\n- 코드 리뷰\n- 테스트 커버리지\n- 성능 프로파일링\n\n**개발 지원:**\n- UI 미리보기\n- 메모리 관리\n- 컨텍스트 압축\n\n---\n\n## 시스템 요구사항\n\n- **Node.js**: 18.0.0 이상\n- **npm**: 7.0.0 이상\n- **Claude Code**: 최신 버전\n\n---\n\n## 설치\n\n```bash\nnpm install -g @su-record/vibe\n```\n\n---\n\n## 프로젝트 구조\n\n```\n.vibe/\n├── specs/          # 기능 명세\n├── plans/          # 기술 계획\n├── tasks/          # 작업 목록\n├── agents/         # AI 에이전트 설정\n└── tools/          # MCP 도구\n```\n\n---\n\n## 라이선스\n\nMIT\n\n---\n\n## 개발 여정\n\nVibe는 fallingo 개발 과정에서 얻은 교훈의 결정체입니다:\n\n- 수십 번의 리셋\n- 순차적 문서 작성 방법론 정립\n- SpecKit 도입\n- hi-ai MCP 개발\n\n모든 경험이 Vibe에 녹아들었습니다.\n\n---\n\n## 다음은?\n\nVibe는 계속 발전합니다:\n\n**v1.1 계획:**\n- 더 많은 언어 지원 (Go, Rust, Java)\n- 팀 협업 기능\n- 클라우드 동기화\n- 프로젝트 템플릿\n\n---\n\n## 시작하기\n\n```bash\n# 설치\nnpm install -g @su-record/vibe\n\n# 초기화\nvibe init\n\n# 첫 기능 개발\nvibe spec \"사용자 인증\"\nvibe plan \"사용자 인증\"\nvibe tasks \"사용자 인증\"\nvibe run \"Task 1-1\"\n```\n\n**바이브 코딩, 이제 Vibe와 함께.**\n\n---\n\n**GitHub**: https://github.com/su-record/vibe\n**관련 포스트**: [AI 개발 방법론 5 - 완성, SpecKit과 그 너머](05-ai-completion-speckit.md)",
      "description": "자연어를 프로덕션 코드로. EARS 기반 명세 작성부터 작업 분해까지, 38개 MCP 도구와 7개 전문 에이전트가 함께하는 체계적인 AI 개발 프레임워크",
      "tags": [
        "vibe",
        "ai-coding",
        "spec-driven",
        "mcp",
        "claude-code",
        "framework"
      ],
      "image": null,
      "author": "Su",
      "lang": "ko",
      "filePath": "/posts/tech-vibe-01.md"
    }
  ]
}