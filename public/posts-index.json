{
  "posts": [
    {
      "slug": "fallingo-tech-01-redis-optimization",
      "title": "[기술 심화] Redis 캐싱으로 API 응답속도 76% 개선하기 - 실전 최적화 가이드",
      "date": "2025-11-09T00:00:00.000Z",
      "category": "tech",
      "description": "GCP Memorystore Redis를 활용한 FastAPI 백엔드 성능 최적화. 실제 성능 측정 데이터와 함께하는 캐싱 전략 완벽 가이드",
      "tags": [
        "fallingo",
        "redis",
        "caching",
        "performance",
        "fastapi",
        "gcp",
        "optimization",
        "technical"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-11-03",
      "title": "Fallingo 개발일지 - 2025년 11월 1주차 (11.03 ~ 11.09)",
      "date": "2025-11-09T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\nBackgroundTasks 도입으로 API 응답속도 76% 개선 (2100ms → 500ms). Redis 캐싱으로 평균 응답 75% 개선 (800ms → 200ms). 프론트엔드 코드 품질 개선 45개 이슈 해결. 낙관적 업데이트 피드 등록 시스템 구현. Fir",
      "tags": [
        "프론트엔드",
        "GoogleMaps",
        "OCR",
        "최적화"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-10-27",
      "title": "Fallingo 개발일지 - 2025년 10월 4주차 (10.27 ~ 11.02)",
      "date": "2025-11-02T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n드디어 실제 Flutter UI를 프로덕션에 배포했다. Google Places API를 활용한 현실적인 테스트 데이터, SEO 최적화, 광고 시스템까지 완성했다. 54개 커밋, 그중 25개가 버그 수정. CORS, URL 경로, API 연동 등 프론트엔드-백엔드 ",
      "tags": [
        "Flutter",
        "프론트엔드",
        "SEO",
        "광고"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-02-google-for-startups",
      "title": "Google for Startups Cloud Program 승인받기 - 신청부터 승인까지",
      "date": "2025-10-30T00:00:00.000Z",
      "category": "dev-log",
      "description": "Google for Startups Cloud Program 신청 과정과 웹사이트 인증, 그리고 승인까지의 여정. 최대 $350,000 크레딧 지원을 받기까지",
      "tags": [
        "fallingo",
        "google-for-startups",
        "google-cloud",
        "startup"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-10-20",
      "title": "Fallingo 개발일지 - 2025년 10월 3주차 (10.20 ~ 10.26)",
      "date": "2025-10-26T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n가장 바쁜 주(92개 커밋). 프로덕션 배포 파이프라인을 완성하고, 법률 문서 다국어 API, Android 인증 설정을 마무리했다. Poetry에서 Docker로, GitHub Actions에서 Cloud Build로, 그리고 다시 Docker로. 시행착오가 많았",
      "tags": [
        "배포",
        "Docker",
        "CI/CD",
        "문서화"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-09-08",
      "title": "Fallingo 개발일지 - 2025년 9월 2주차 (09.08 ~ 09.14)",
      "date": "2025-09-14T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n백엔드 프로덕션 배포와의 전쟁. Cloud Run 배포를 위한 포트 설정, 환경변수, 도메인 패턴 등 온갖 문제를 해결했다. 44개 커밋 중 21개가 fix였다. 하지만 최종적으로 백엔드 완성도를 높이고 Startup Application 통합을 완료했다.\n\n## ",
      "tags": [
        "배포",
        "CloudRun",
        "DevOps",
        "최적화"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-09-01",
      "title": "Fallingo 개발일지 - 2025년 9월 1주차 (09.01 ~ 09.07)",
      "date": "2025-09-07T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n서비스 출시를 위한 법적 기반과 수익 모델을 완성했다. 법적 문서 시스템, AdMob/AdSense 광고, 종합 보안 시스템을 구축했다. 그리고 핵심 차별화 기능인 티어별 상호작용 반경 시스템을 완성했다. 15개 커밋이지만 각각이 무거운 작업들이었다.\n\n## 주요 ",
      "tags": [
        "법률",
        "광고",
        "보안",
        "포인트시스템"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-08-11",
      "title": "Fallingo 개발일지 - 2025년 8월 2주차 (08.11 ~ 08.17)",
      "date": "2025-08-17T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n가장 많은 커밋(94개)과 가장 많은 버그 수정(47개)이 있었던 주. Identity Platform 인증 시스템을 구현하고, 백엔드 아키텍처를 전면 개선했다. Feed, Restaurant, User API를 모두 완성했다. Redis를 비활성화하고 비용 최적화",
      "tags": [
        "인증",
        "백엔드",
        "아키텍처",
        "GCP"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-08-04",
      "title": "Fallingo 개발일지 - 2025년 8월 1주차 (08.04 ~ 08.10)",
      "date": "2025-08-10T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n백엔드 Phase 1 구현을 완료하고, Flutter 프론트엔드 개발을 본격적으로 시작했다. GCP Load Balancer 경로 기반 라우팅을 설정하고, 프론트엔드-백엔드 통합 배포를 완료했다. 55개 커밋, 그중 26개가 버그 수정이었다. 배포는 역시 만만치 않",
      "tags": [
        "프론트엔드",
        "Flutter",
        "GCP",
        "배포"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-07-28",
      "title": "Fallingo 개발일지 - 2025년 7월 4주차 (07.28 ~ 08.03)",
      "date": "2025-08-03T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\nReset 이후 2주간 새로운 방법론을 정립하고 재시작을 준비했다. 기획 문서를 다시 검토하며 누락된 내용을 발견했고, SpecKit이라는 체계적인 프레임워크를 알게 되었다. 서두르지 않고 탄탄한 기반을 만드는 데 집중했다.\n\n## 주요 작업\n\n### 기획 문서 재",
      "tags": [
        "방법론",
        "문서화",
        "AI개발",
        "SpecKit"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-07-14",
      "title": "Fallingo 개발일지 - 2025년 7월 2주차 (07.14 ~ 07.20)",
      "date": "2025-07-20T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n결정했다. 기획 문서를 제외한 모든 개발 문서와 소스코드를 삭제했다. 커밋: \"reset - del\", \"reset - docs\". 지난 몇 달간의 작업이 사라지는 것을 보는 것은 쉽지 않았지만, 올바른 방향으로 가기 위한 필수적인 선택이었다.\n\n## Reset의 ",
      "tags": [
        "회고",
        "방법론",
        "AI개발",
        "리셋"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-06-23",
      "title": "Fallingo 개발일지 - 2025년 6월 4주차 (06.23 ~ 06.29)",
      "date": "2025-06-29T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n지난주 Phase 3-4를 완료하고 API 구현을 시작했지만, 심각한 일관성 문제를 발견했다. 데이터베이스 스키마와 도메인 모델, API 정의가 서로 맞지 않았다. 몇 달간 개발해온 결과물이지만, 근본적인 문제가 있다는 것을 인정해야 했다.\n\n## 직면한 문제들\n\n",
      "tags": [
        "회고",
        "시스템설계",
        "AI개발"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-06-16",
      "title": "Fallingo 개발일지 - 2025년 6월 3주차 (06.16 ~ 06.22)",
      "date": "2025-06-22T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\nFallingo 프로젝트의 초기 아키텍처를 완성했다. Phase 3-4 개발을 통해 데이터베이스 스키마, 핵심 도메인 모델, 그리고 기본적인 API 구조를 잡았다. 총 25개의 커밋으로 프로젝트의 기반을 다졌다.\n\n## 주요 작업\n\n### 시스템 설계 완료\n- Ph",
      "tags": [
        "백엔드",
        "시스템설계",
        "데이터베이스"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-06-09",
      "title": "Fallingo 개발일지 - 2025년 6월 2주차 (06.09 ~ 06.15)",
      "date": "2025-06-15T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n본격적인 개발이 시작되었다. Fallingo의 기술 아키텍처를 설계하고 개발 가이드 문서를 작성했다. Phase 0부터 Phase 2까지 단계별로 구현하면서 프로젝트의 기반을 다졌다. 프로젝트 구조, 환경 설정, 기본 API 엔드포인트까지 완성했다.\n\n## 주요 작",
      "tags": [
        "시스템설계",
        "백엔드",
        "개발가이드"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-06-02",
      "title": "Fallingo 개발일지 - 2025년 6월 1주차 (06.02 ~ 06.08)",
      "date": "2025-06-08T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n프로젝트의 중요한 전환점이 있었던 주였다. FlavorPoint라는 이름으로 시작했지만, 더 나은 이름을 찾게 되었다. fallingo.app 도메인을 발견하고 구매했고, 프로젝트 이름도 Fallingo로 변경했다. \"falling in go\" - 빠져들다, 몰입하",
      "tags": [
        "기획",
        "리브랜딩",
        "저장소전환"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-week-2025-05-26",
      "title": "Fallingo 개발일지 - 2025년 5월 4주차 (05.26 ~ 06.01)",
      "date": "2025-06-01T00:00:00.000Z",
      "category": "dev-log",
      "description": "## 이번 주 요약\n\n새로운 음식 추천 플랫폼 프로젝트를 시작했다. 프로젝트 이름은 FlavorPoint - \"진짜 맛있는 한 점을 찾다\"는 의미를 담았다. 첫 주는 서비스 기획과 문서화에 집중했다. 제안서부터 시작해 서비스 철학, 비전, 주요 기능까지 체계적으로 정리했다.\n\n## 주요",
      "tags": [
        "기획",
        "서비스설계",
        "문서화"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "fallingo-01-google-dream",
      "title": "나의 꿈은 구글이니까 - 기술스택을 100% 구글로 결정한 이유",
      "date": "2025-05-25T00:00:00.000Z",
      "category": "story",
      "description": "갈 수 없을 것 같은 꿈. 그래서 모든 기술을 구글로 만들기로 했다",
      "tags": [
        "fallingo",
        "google-cloud",
        "dev-journey",
        "dream"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-hi-ai-v1.2.0",
      "title": "hi-ai MCP v1.2.0: UI 미리보기 시스템으로 개발 워크플로우 혁신",
      "date": "2024-10-17T00:00:00.000Z",
      "category": "tech",
      "description": "ASCII 아트 기반 UI 미리보기 - 6가지 레이아웃 타입 지원으로 터미널에서 즉시 확인 가능한 시각화 시스템",
      "tags": [
        "hi-ai",
        "mcp",
        "ui-preview",
        "ascii-art",
        "developer-tools",
        "release"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-hi-ai-v1.1.0",
      "title": "hi-ai MCP v1.1.0: 시맨틱 코드 분석으로 코드 이해도 향상",
      "date": "2024-08-13T00:00:00.000Z",
      "category": "tech",
      "description": "find_symbol, find_references 도구 추가 - 코드 탐색과 리팩토링을 위한 시맨틱 분석 기능 강화",
      "tags": [
        "hi-ai",
        "mcp",
        "semantic-analysis",
        "code-navigation",
        "typescript",
        "release"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "04-speckit-completion",
      "title": "SpecKit으로 완성하기 - 진짜 AI-First 개발",
      "date": "2024-07-20T00:00:00.000Z",
      "category": "methodology",
      "description": "SpecKit 도입으로 문서 품질이 향상되고, 백엔드와 프론트엔드가 완성되기까지",
      "tags": [
        "ai-first",
        "speckit",
        "fallingo",
        "completion"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-hi-ai-v1.0.4-6",
      "title": "hi-ai MCP v1.0.4-6: AST 기반 코드 분석과 자연어 실행 시스템 도입",
      "date": "2024-07-08T00:00:00.000Z",
      "category": "tech",
      "description": "ts-morph 기반 AST 코드 분석, 프롬프트 최적화, 다국어 키워드 지원 - 31개 도구로 확장된 MCP 서버",
      "tags": [
        "hi-ai",
        "mcp",
        "ast",
        "code-analysis",
        "typescript",
        "release"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "03-ai-consistency-solution",
      "title": "AI와 협업하는 새로운 방법론 - 일관성 문제를 해결하다",
      "date": "2024-06-10T00:00:00.000Z",
      "category": "methodology",
      "description": "순차적 문서 작성과 교차 검증으로 AI의 일관성 문제를 극복한 과정",
      "tags": [
        "ai-first",
        "methodology",
        "entity-driven",
        "sequential"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "tech-01-hi-ai-mcp",
      "title": "hi-ai MCP: 개발자를 위한 34개 도구의 똑똑한 AI 비서",
      "date": "2024-06-01T00:00:00.000Z",
      "category": "tech",
      "description": "키워드 기반 자연어로 작동하는 MCP 1.0 표준 개발 도구 - 100ms 이하 응답, 50MB 이하 메모리",
      "tags": [
        "mcp",
        "ai-tools",
        "typescript",
        "developer-tools",
        "hi-ai"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "02-1-mcp-development",
      "title": "MCP 만들기 - AI 일관성 문제를 직접 해결해보다",
      "date": "2024-05-25T00:00:00.000Z",
      "category": "methodology",
      "description": "Claude Projects와 Gemini Gems로도 부족해서, 직접 MCP를 만들어 AI 일관성 문제를 해결하려 했던 과정",
      "tags": [
        "ai-first",
        "mcp",
        "hi-ai",
        "claude",
        "consistency"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "02-ai-document-driven",
      "title": "AI를 위한 문서 작성법 - 왜 일관성이 무너졌을까?",
      "date": "2024-05-15T00:00:00.000Z",
      "category": "methodology",
      "description": "AI가 읽고 일할 수 있는 문서를 만들기까지의 시행착오와 깨달음",
      "tags": [
        "ai-first",
        "prd",
        "documentation",
        "claude"
      ],
      "image": null,
      "lang": "ko"
    },
    {
      "slug": "01-ai-development-start",
      "title": "10년차 프론트엔드 개발자, AI와 앱 만들기 시작하다",
      "date": "2024-04-21T00:00:00.000Z",
      "category": "story",
      "description": "기술을 몰라도 AI와 함께라면? 10년차 개발자가 FastAPI, Flutter를 AI와 배우며 앱을 만든 이야기",
      "tags": [
        "ai-first",
        "vibe-coding",
        "cursor",
        "claude"
      ],
      "image": null,
      "lang": "ko"
    }
  ],
  "totalCount": 26,
  "lastUpdated": "2025-11-09T08:30:16.581Z",
  "fullPosts": [
    {
      "slug": "01-ai-development-start",
      "title": "10년차 프론트엔드 개발자, AI와 앱 만들기 시작하다",
      "date": "2024-04-21T00:00:00.000Z",
      "category": "story",
      "content": "# 10년차 프론트엔드 개발자, AI와 앱 만들기 시작하다\n\n2025년 2월, 유튜브에서 '바이브 코딩'이라는 단어를 처음 접했다. AI가 코딩을 대신한다는 이야기.\n\n반신반의했다.\n\n10년 넘게 프론트엔드를 해왔다. 하지만 백엔드는 문외한이었다. FastAPI? Flutter? 이름만 들어봤다.\n\n## 회사에서 AI를 도입하다\n\n2025년 4월 21일. Cursor를 처음 사용했다.\n\n곧바로 Gemini, Claude로 확장했고, 지금은 주로 Claude를 쓴다.\n\nAI를 도입한 후 달라졌다. 단순 반복 작업은 AI에게 맡기고, 나는 더 본질적인 문제에 집중할 수 있었다.\n\n문이 열렸다. 넓고, 방대하고, 무궁무진한 새로운 세계.\n\n## \"내 앱을 만들어보자\"\n\n5월 말, 결심했다.\n\n> \"AI와 함께 내 앱을 만들어보자. 졸업작품처럼.\"\n\n그런데 한 가지 중요한 결정을 내렸다.\n\n**내가 전혀 모르는 기술 스택으로 만들자.**\n\n### 왜?\n\n많은 사람들이 말했다. \"AI가 모든 것을 개발하기엔 부족하다.\" 그러면서 바이브 코딩이 핫해지는 게 모순 아닌가?\n\nAI는 나보다 훨씬 방대한 지식을 가지고 있다. 왜 안 된다고 할까?\n\n진짜 AI-First 개발을 해보고 싶었다.\n\n## 내 역할: PO, PM, 그리고 검수자\n\n폴링고(Fallingo)를 개발하는 방식:\n\n- **나**: 기획자, PO, PM\n- **AI**: 모든 기술적 코딩 전담\n- **와이프**: 테스터, UI/UX 조언자 (로고, 컬러, 디자인 의견 적극 수용중)\n- **나의 주된 역할**: 검수\n\n기획 초기 단계부터 모든 문서는 AI가 작성했다. 나는 검토하고, 승인하고, 방향을 제시했다.\n\n## 첫 번째 성과: 몇 시간 만에 앱이 돌아가다\n\n개발 초기, AI에게 그냥 \"만들어\"라고 했다.\n\n몇 시간 만에 로컬에서 그럴싸한 앱이 완성됐다.\n\n하지만 디테일이 없었다.\n\n그때 깨달았다.\n\n> \"아! AI가 읽고 개발할 수 있게, **개발 가이드 문서**가 필요한 거구나!\"\n\nPRD(Product Requirements Document)라는 걸 나중에 알았다. 난 그런 것도 모르고 시작한 것이다.\n\n## 앞으로의 여정\n\n이제 시작이었다.\n\n문서를 몇 번씩 갈아엎었다. 일관성 문제로 고민했다. 포기하려던 순간도 있었다.\n\n하지만 결국 찾아냈다.\n\nAI와 협업하는 나만의 방법론을.",
      "description": "기술을 몰라도 AI와 함께라면? 10년차 개발자가 FastAPI, Flutter를 AI와 배우며 앱을 만든 이야기",
      "tags": [
        "ai-first",
        "vibe-coding",
        "cursor",
        "claude"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/01-ai-development-start.md"
    },
    {
      "slug": "02-1-mcp-development",
      "title": "MCP 만들기 - AI 일관성 문제를 직접 해결해보다",
      "date": "2024-05-25T00:00:00.000Z",
      "category": "methodology",
      "content": "# MCP 만들기 - AI 일관성 문제를 직접 해결해보다\n\nClaude Projects와 Gemini Gems에 지침 자료를 등록했더니, 이전보다는 나아졌다.\n\n하지만 여전히 완벽하지 않았다.\n\n문서가 준비되고 개발에 들어가면, 여전히 문제가 생기거나 에러 처리를 못하는 상황이 발생했다.\n\n## 왜 또 일관성이 무너지지?\n\nProjects와 Gems에 이미 다 넣어뒀다:\n\n- 문서 작성법\n- 기획 문서\n- 개발 코드 컨벤션\n- 기술 스택\n\n그런데도 매번 새로운 세션에서 AI는 조금씩 다르게 행동했다.\n\n같은 질문에 다른 답변을 하거나, 같은 요청에 다른 코드를 만들어냈다.\n\n### 진짜 문제: 컨텍스트를 활용하는 방식이 달랐다\n\nAI는 지침 자료를 읽긴 하는데, 어떤 부분을 중요하게 볼지는 매번 달랐다.\n\n어떤 세션에서는 기술 스택에 집중했다. 어떤 세션에서는 코드 컨벤션에 집중했다. 어떤 세션에서는 기획 문서의 핵심 기능만 봤다.\n\n## 그래서 MCP를 만들기로 했다\n\n\"AI가 일관되게 행동하려면, 내가 원하는 방식으로 정보를 제공해야 하는 거 아닐까?\"\n\nMCP (Model Context Protocol)는 AI가 외부 도구나 데이터에 접근할 수 있게 해주는 프로토콜이다.\n\n이걸 활용해서, AI가 폴링고 개발할 때 필요한 정보를 정확하게 제공하는 도구를 만들고 싶었다.\n\n### hi-ai 프로젝트 시작\n\nhttps://github.com/su-record/hi-ai\n\n목표: AI 개발 시 일관성을 유지하기 위한 MCP 도구 만들기\n\n처음엔 간단하게 시작했다:\n\n1. 기획 문서 읽어오기\n2. 엔티티 정보 제공하기\n3. API 명세 가져오기\n4. 코드 컨벤션 체크하기\n\n## MCP를 만들면서 배운 것들\n\n### 1. AI에게 정보를 주는 방식이 중요하다\n\n처음엔 그냥 문서 전체를 던져줬다.\n\n하지만 AI는 필요한 부분만 빠르게 찾을 수 있어야 했다.\n\n키워드 기반 검색을 추가했다. AI가 \"결제 기능\"을 물어보면, 결제 관련 엔티티, API, 비즈니스 로직만 딱 제공한다.\n\n### 2. 메모리 관리가 핵심이더라\n\nAI는 이전 대화를 기억하지만, 컨텍스트 윈도우 한계가 있다.\n\nhi-ai에 인텔리전트 메모리 관리 기능을 넣었다:\n\n- 자주 사용되는 정보는 우선순위 높게\n- 한번 제공한 정보는 다시 제공하지 않고\n- 세션이 바뀌어도 이전 작업 이력 추적\n\n### 3. 의도를 파악하는 게 중요했다\n\nAI가 질문할 때, 진짜 필요한 게 뭔지 파악해야 했다.\n\n\"엔티티 보여줘\"라고 하면:\n- 전체 엔티티 목록?\n- 특정 엔티티의 상세 정보?\n- 엔티티 간 관계도?\n\n의도 인식(Intent Recognition) 기능을 추가했다. 한국어, 영어 모두 지원하게 만들었다.\n\n### 4. 코드 분석도 필요했다\n\n문서만으로는 부족했다. 실제 코드와 문서가 일치하는지 확인이 필요했다.\n\n시맨틱 코드 분석 기능을 넣었다:\n- 코드 품질 체크\n- 컨벤션 준수 여부\n- 문서와 코드 일치성 검증\n\n## 34개의 전문화된 도구\n\n결국 hi-ai는 34개의 도구를 가진 MCP가 됐다:\n\n- 프로젝트 컨텍스트 관리\n- 문서 검색 및 제공\n- 엔티티/API 정보 제공\n- 코드 분석 및 검증\n- 메모리 관리\n- 의도 인식\n\n평균 응답 시간은 100ms 이하로 만들었다. AI가 기다리지 않게.\n\n## 결과는 어땠을까?\n\n솔직히 말하면, 완벽한 해결책은 아니었다.\n\nhi-ai를 사용하니:\n\n### 좋아진 점\n\n- 문서 찾는 시간이 확실히 줄었다\n- 같은 정보를 반복해서 제공할 필요가 없었다\n- 코드 컨벤션 체크가 자동화됐다\n\n### 여전히 남은 문제\n\n- AI가 여전히 요구하지 않은 내용을 추가했다\n- 일관성 문제가 완전히 해결되지는 않았다\n- DB 스키마와 모델이 여전히 일치하지 않을 때가 있었다\n\n## 깨달음: 도구만으로는 부족하다\n\nMCP를 만들면서 깨달았다.\n\n> **AI 일관성 문제는 도구만으로 해결되는 게 아니다.**\n\nAI에게 정보를 주는 방식도 중요하지만, AI에게 작업을 시키는 방식이 더 중요했다.\n\n- 어떤 순서로 문서를 읽게 할 것인가?\n- 어떤 우선순위로 작업하게 할 것인가?\n- 어떻게 검증하고 교차 확인하게 할 것인가?\n\n이 문제는 MCP로 해결할 수 없었다.\n\n방법론이 필요했다.\n\n## 포기하려던 순간\n\n이때가 정말 앱 만드는 걸 포기하려던 때였다.\n\n문서도 만들었다. Projects와 Gems도 활용했다. MCP까지 만들었다.\n\n여전히 일관성 문제는 해결되지 않았다.\n\nDB 스키마와 모델이 일관성을 갖지 못하니까, 수정하고 또 수정하는데 돈만 들었다.\n\n내가 FastAPI, 백엔드 개발, Flutter를 알았다면 어떻게든 해봤을 텐데, 그럴 수 없었다.\n\n### 그래도 계속했다\n\n내 질문하는 능력, 요구사항 전달하는 능력이 문제라고 생각했다.\n\nAI와 대화를 통해 더 나은 방법을 찾아보기로 했다.\n\n지금까지의 실패를 AI에게 설명했다.\n\n그리고 함께 새로운 방법을 찾기 시작했다.\n\n## hi-ai의 현재\n\n지금도 hi-ai는 개발 중이다. 폴링고를 만들면서 계속 개선하고 있다.\n\nMCP 자체는 완벽한 해결책이 아니었지만, AI와 협업하는 방법을 고민하게 만들었다.\n\n그 고민이 결국 새로운 방법론을 찾게 해줬다.",
      "description": "Claude Projects와 Gemini Gems로도 부족해서, 직접 MCP를 만들어 AI 일관성 문제를 해결하려 했던 과정",
      "tags": [
        "ai-first",
        "mcp",
        "hi-ai",
        "claude",
        "consistency"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/02-1-mcp-development.md"
    },
    {
      "slug": "02-ai-document-driven",
      "title": "AI를 위한 문서 작성법 - 왜 일관성이 무너졌을까?",
      "date": "2024-05-15T00:00:00.000Z",
      "category": "methodology",
      "content": "# AI를 위한 문서 작성법\n\nAI에게 \"만들어\"라고 했을 때, 몇 시간 만에 앱이 돌아갔다.\n\n디테일이 없었다.\n\n그때 깨달았다.\n\n> \"AI가 읽고 개발할 수 있게, **개발 가이드 문서**가 필요하구나!\"\n\n## 첫 번째 시도: AI를 위한 개발 가이드\n\nAI에게 요구했다.\n\n**\"AI를 위한 개발 가이드 문서를 작성해줘.\"**\n\nPRD(Product Requirements Document)라는 걸 나중에 알았다. 난 그런 것도 모르고 시작했다.\n\n### 문서를 갈아엎기 시작하다\n\n첫 번째 문서. 괜찮다고 생각했다.\n\n두 번째 검토. 데이터 모델이 통일되지 않았다.\n\n세 번째 수정. 예제 코드가 제각각이었다.\n\n네 번째, 다섯 번째. 개발된 소스코드는 뒤죽박죽이었다.\n\n상당히 많은 횟수로 문서를 갈아엎었다.\n\n## 의문: AI가 작성했는데 왜 일관성이 없지?\n\n왜? AI가 작성했는데 일관성이 떨어지는가?\n\n왜 컨텍스트가 매번 이렇게 달라지는가?\n\n고민 끝에 깨달았다.\n\n> **세션이 바뀔 때마다 AI가 바뀐다.**\n\n## 두 번째 시도: AI가 바뀌어도 일관된 작업을 하게\n\nAI가 바뀌어도 일관된 작업을 할 수 있는 방법을 고민했다.\n\n### 해결책: 지침 자료 등록\n\n- **Claude의 Projects**\n- **Gemini의 Gems**\n- **MCP (Model Context Protocol)**\n\n지침 자료로 등록했다:\n\n1. 문서 작성법\n2. 기획 문서\n3. 개발 코드 컨벤션\n4. 기술 스택\n\n문서를 다시 작성했다. 이전보다는 나아졌다.\n\n## 하지만 여전히 문제는 남았다\n\n문서가 준비되고 개발에 들어가면, 여전히 문제가 생겼다. 에러 처리를 못하는 상황이 발생했다.\n\n### 실험: 예제 코드를 없애보자\n\nAI가 개발하는데 예제 코드가 필요한가?\n\n예제 코드를 다 없애봤다. 갖가지 시도를 했다.\n\n오류가 발생했다. 해결되지 않았다.\n\n이게 현재 AI 기술의 한계인가?\n\n### 진짜 문제: AI가 요구하지 않은 내용을 추가한다\n\nAI가 항상 요구하지 않은 내용을 자꾸 추가하는 게 문제였다.\n\n내가 FastAPI, 백엔드 개발, Flutter를 알았다면 어떻게든 에러를 수정해봤을 것이다.\n\n하지만 그럴 수 없었다.\n\n## 포기의 순간\n\n이때가 앱 만드는 걸 포기하려던 때였다.\n\nDB 스키마와 모델이 일관성을 갖지 못했다. 수정하고 또 수정하는데 돈만 들었다.\n\n### 그래도 계속했다\n\n내 능력이 더 문제라고 생각했다. 내가 질문하고 요구사항을 전달하는 방식.\n\nAI와 대화를 통해 더 나은 방법을 찾아보기로 했다.\n\n지금까지의 실패를 AI에게 설명했다.",
      "description": "AI가 읽고 일할 수 있는 문서를 만들기까지의 시행착오와 깨달음",
      "tags": [
        "ai-first",
        "prd",
        "documentation",
        "claude"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/02-ai-document-driven.md"
    },
    {
      "slug": "03-ai-consistency-solution",
      "title": "AI와 협업하는 새로운 방법론 - 일관성 문제를 해결하다",
      "date": "2024-06-10T00:00:00.000Z",
      "category": "methodology",
      "content": "# AI와 협업하는 새로운 방법론\n\n포기하려던 순간, AI와 대화를 통해 새로운 방법을 찾았다.\n\n지금까지의 실패를 AI에게 설명했다. 함께 더 나은 방법을 찾았다.\n\n## 새로운 문서 작성 방식\n\n기획서가 준비되어 있었다. 몇 개월 진행하며 업데이트된 아이디어가 잘 반영됐는지 확인부터 했다.\n\n### 순차적 문서 작성 프로세스\n\n1. 기획서 업데이트\n2. 엔티티 추출 → 엔티티 문서 작성\n3. ERD 설계 → 데이터 모델 문서 작성\n4. API 정의 → API 문서 작성\n5. 비즈니스 로직 → 비즈니스 로직 문서 작성\n\n핵심: 순서대로, 단계별로.\n\n### 과감한 결정: 모든 것을 제거하다\n\n새로운 구성으로 시작할 때마다, 기획 문서를 제외한 나머지 모든 문서와 개발 소스코드를 모두 제거했다.\n\n세 번째 문서를 삭제할 때, 손이 떨렸다. 일주일의 작업이었다.\n\n하지만 일관성 없는 코드는 독이었다.\n\n## 여전히 남은 문제: 일관성\n\n문서 작성 방식을 바꿨지만, 여전히 일관성 문제가 발생했다.\n\n교차 검증하듯 새롭게 문서를 작성해보면, 항상 이전 문서와 차이점이 발생했다.\n\n어떤 때는 API가 180개였던 적도 있었다.\n\n## 돌파구: 공통된 내용에 집중하다\n\n차이가 발생하는 원인을 AI에게 분석 요청했다.\n\n리포트를 받았다:\n\n> 작업하는 AI마다 문서 제목이나 요약 정보를 통해 먼저 해야 할 일을 정한다.\n> 이 순서가 핵심 기능 위주였다.\n\n공통된 내용이 거의 다 AI가 핵심 기능이라고 판단한 것들이었다.\n\n## 해결책: AI에게 명확한 순서 지시\n\n다시 요청했다.\n\n### 핵심 지시사항\n\n1. 기획서를 최대한 자세하게 읽어라\n2. 반드시 문서 번호대로 순차적으로 읽어라\n\n### 개발 문서 작성 순서 강제\n\n순서대로:\n\n```\n기획서 → 엔티티 → ERD → 데이터모델 → API, 비즈니스로직 → 데이터베이스\n```\n\n몇 번의 복수 검증을 토대로 최종 문서 작성을 완료했다.\n\n## 개발 방식도 변경: 백엔드 먼저\n\n보통의 개발:\n\n- 기획 리뷰 후 인터페이스 정의\n- 백엔드와 프론트가 각각 동시 개발\n- 디자인 완성되면 프론트가 반영\n\n나도 AI에게 동시 개발을 주문했었다. 개발 가이드 문서가 있으니까.\n\n### 하지만 방법을 바꿨다\n\n> 백엔드가 탄탄한 게 먼저다.\n\n단번에 잘 되진 못했다. 다시 시작하는 걸 반복했다.\n\n그래도 어느 정도 백엔드 개발이 진행되던 중, SpecKit을 알게 됐다.",
      "description": "순차적 문서 작성과 교차 검증으로 AI의 일관성 문제를 극복한 과정",
      "tags": [
        "ai-first",
        "methodology",
        "entity-driven",
        "sequential"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/03-ai-consistency-solution.md"
    },
    {
      "slug": "04-speckit-completion",
      "title": "SpecKit으로 완성하기 - 진짜 AI-First 개발",
      "date": "2024-07-20T00:00:00.000Z",
      "category": "methodology",
      "content": "# SpecKit으로 완성하기\n\n백엔드 개발이 어느 정도 진행되던 중, SpecKit을 알게 됐다.\n\n## 기존 문서를 SpecKit에 마이그레이션\n\n기존 문서를 SpecKit에 맞춰 마이그레이션했다.\n\n놀라운 발견.\n\n기획 문서에 유실된 내용이 있었다.\n\n항상 수시로 변경사항이 발생할 때마다 업데이트했지만, 부족했다.\n\n### 유실된 내용을 채우다\n\n유실된 내용을 채우면서, 기존 기획의 방향도 수정하게 됐다.\n\n문서를 다시 재정의하고, 현재 소스를 수정 개발했다.\n\n그렇게 지금의 백엔드가 완성됐다.\n\n## 프론트엔드는 수월하게\n\nAPI와 관련 문서의 완성도가 높으니까, 프론트엔드는 수월하게 진행되는 중이다.\n\n나는 틀린 점을 지적해서 수정을 요청하는 것뿐이다.\n\n### 기술 지식이 없어도\n\n기술에 대한 지식이 없어서 수시로 소스코드 품질에 대해 검토 요청한다. 개발 가이드는 반드시 지켜야 할 사항들을 개발 규칙으로 정의했다.\n\n기술 지식이 없어도, 지금까지의 경험으로 이 정도는 본다:\n\n- 한 파일에 너무 많은 걸 담는다\n- 중복된 소스코드나 재사용이 안 된다\n\n## 폴링고는 어떻게 개발되는가\n\n### 나의 역할\n\n1. 기획에 맞는가?\n2. AI가 작성한 소스코드를 끊임없이 의심하며 요청\n3. UI/UX에 대해 고민하고 결정\n\n물론 항상 AI에게 더 나은 방법을 제안받아서 결정하고 있다.\n\n### 진정한 AI-First, AI-Driven\n\n이게 진정한 AI-First, AI-Driven 개발 아닐까?\n\n- 기획자 = 나\n- 개발자 = AI\n- QA = 나 + 와이프\n- 디자이너 = AI + 와이프\n\n## 핵심 원칙 정리\n\n### 1. 문서 중심 개발\n\n순차적 문서 작성: 기획서 → 엔티티 → ERD → API → 비즈니스 로직\nAI에게 명확한 순서 지시\n\n### 2. 일관성 유지\n\n세션이 바뀌어도 일관성 유지 (Projects, Gems, MCP)\n교차 검증으로 차이점 발견\n\n### 3. 과감한 리셋\n\n일관성 없으면 전체 제거하고 다시 시작\n아까워도 독은 제거\n\n### 4. 백엔드 우선\n\n탄탄한 백엔드가 먼저\nAPI 완성도가 높으면 프론트는 수월\n\n### 5. 끊임없는 의심과 검증\n\nAI 결과물을 맹신하지 않기\n품질 검토 요청\n더 나은 방법 제안 요청\n\n## 결론\n\n기술을 몰라도 AI와 함께라면 앱을 만들 수 있다.\n\n하지만 AI를 효과적으로 활용하는 방법론이 필요하다.\n\n이 과정에서 수십 번 문서를 갈아엎었다. 포기하려던 순간도 있었다.\n\n하지만 결국 찾았다. 나만의 AI-First 개발 방법론을.\n\n이제 여러분 차례다.",
      "description": "SpecKit 도입으로 문서 품질이 향상되고, 백엔드와 프론트엔드가 완성되기까지",
      "tags": [
        "ai-first",
        "speckit",
        "fallingo",
        "completion"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/04-speckit-completion.md"
    },
    {
      "slug": "fallingo-01-google-dream",
      "title": "나의 꿈은 구글이니까 - 기술스택을 100% 구글로 결정한 이유",
      "date": "2025-05-25T00:00:00.000Z",
      "category": "story",
      "content": "# 나의 꿈은 구글이니까\n\n2025년 5월 말, 폴링고(Fallingo) 앱을 만들기로 결심하고 가장 먼저 한 결정이 있었다.\n\n> \"나의 꿈. 하지만, 갈 수 없이 너무 멀리 있기에 내가 만드는 앱의 모든 기술스택을 구글로 결정했다.\"\n\n감상적인 결정이었다.\n\n## 왜 구글인가\n\n어릴 적부터 구글은 '도달할 수 없는 꿈'이었다.\n\n실리콘밸리, 세계 최고의 기술 기업, 혁신의 아이콘... 거창한 말이 아니라 그냥 단순하게 **\"여기서 일하고 싶다\"**는 마음.\n\n하지만 현실은 냉정하다. 나이도 있고, 한국에 있고, 영어도 완벽하지 않다. 갈 수 없이 너무 멀리 있는 곳.\n\n그래서 생각했다.\n\n> \"갈 수는 없지만, 구글의 기술로 내 앱을 만들면 되지 않을까?\"\n\n## 100% 구글 기술 스택\n\n그래서 정했다. **모든 기술을 구글로.**\n\n**백엔드:**\n- FastAPI + Python 3.11+\n- PostgreSQL 15 + PostGIS\n- Cloud Run 배포\n\n**프론트엔드:**\n- Flutter 3.24+\n- Firebase Auth\n\n**AI 서비스:**\n- Vision API (이미지 분석)\n- Gemini (AI 대화)\n- Document AI (문서 처리)\n- Translate API (번역)\n\n**인프라:**\n- Cloud Run (서버리스 컨테이너)\n- Cloud Storage (파일 저장)\n- Cloud SQL (데이터베이스)\n- Memorystore Redis (캐싱)\n\n**지도:**\n- Google Maps Platform\n\n백엔드도 모르고, Flutter도 처음이고, 구글 클라우드는 더더욱 몰랐다.\n\n하지만 **AI와 함께라면 된다고 믿었다.**\n\n## 갈 수 없는 꿈\n\n구글이라는 회사에 들어갈 순 없다.\n\n나이도 있고, 한국에 있고, 영어도 완벽하지 않다.\n\n하지만 구글의 기술로 내 앱을 만들 수는 있다.\n\n---\n\n모르는 게 산더미였다. FastAPI도, Flutter도, Cloud Run도 전부 처음이었다.\n\n하지만 걸음은 이미 시작됐다.\n\n> \"AI와 함께라면, 내가 모르는 기술도 배우면서 만들 수 있지 않을까?\"\n\n그리고 실제로 그렇게 됐다.\n\n**나의 꿈은 구글이니까.**",
      "description": "갈 수 없을 것 같은 꿈. 그래서 모든 기술을 구글로 만들기로 했다",
      "tags": [
        "fallingo",
        "google-cloud",
        "dev-journey",
        "dream"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/fallingo-01-google-dream.md"
    },
    {
      "slug": "fallingo-02-google-for-startups",
      "title": "Google for Startups Cloud Program 승인받기 - 신청부터 승인까지",
      "date": "2025-10-30T00:00:00.000Z",
      "category": "dev-log",
      "content": "# Google for Startups Cloud Program 승인받기\n\n폴링고의 모든 기술 스택을 구글로 결정하고 나니, 당연히 클라우드 비용이 걱정됐다.\n\nCloud Run, Cloud SQL, Vision API, Maps Platform... 합치면 월 비용이 만만치 않을 터였다.\n\n그때 발견한 게 **Google for Startups Cloud Program**이었다.\n\n## Google for Startups Cloud Program이란?\n\n스타트업을 위한 구글의 클라우드 크레딧 지원 프로그램이다.\n\n**지원 내용:**\n- 최대 $350,000 상당의 Google Cloud 및 Firebase 크레딧\n- 2년간 사용 가능\n- Cloud, Firebase, Maps Platform 포함\n- 기술 지원 및 멘토링\n\n**자격 요건:**\n- 설립 10년 이내의 스타트업\n- Series A 펀딩 이전\n- Google Cloud를 처음 사용하거나 초기 단계\n- 공개 웹사이트 보유\n\n폴링고는 모든 조건에 부합했다. 신청하지 않을 이유가 없었다.\n\n## 신청 과정\n\n### 1단계: 초기 신청 (2025-10-27)\n\nGoogle for Startups Cloud Program 신청 페이지에서 기본 정보를 입력했다.\n\n**입력 항목:**\n- 회사명: Sutory (폴링고 운영사)\n- 웹사이트: https://fallingo.app\n- 사업 분야: Social Media / Language Learning\n- 예상 월 사용량\n- 기술 스택\n\n제출 후 몇 시간 뒤, 첫 이메일이 도착했다.\n\n### 2단계: 웹사이트 인증 요청 (Email #1)\n\n> **\"Application received - website verification needed\"**\n\n웹사이트가 실제로 운영 중인지 확인하기 위한 절차였다.\n\n**요구사항:**\n- 공개된 웹사이트 필요\n- 회사 정보가 명시된 About 페이지\n- 연락처 정보\n\n당시 폴링고는 Flutter 앱만 있고 웹사이트가 없었다. 그래서 급하게 `fallingo.app/about.html` 페이지를 만들었다.\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <title>About Fallingo - Sutory</title>\n</head>\n<body>\n  <h1>Fallingo</h1>\n  <p>Social media platform for language learners</p>\n  <p>Company: Sutory</p>\n  <p>Contact: su@fallingo.app</p>\n</body>\n</html>\n```\n\n간단하지만 필요한 정보는 다 담았다. 제출했다.\n\n### 3단계: 추가 정보 요청 (Email #2-6)\n\n웹사이트 인증 후에도 이메일이 계속 왔다.\n\n**Email #2:** 사업자 등록증 요청\n**Email #3:** 예상 사용량 구체화 요청\n**Email #4:** Cloud 사용 계획 설명\n**Email #5:** Maps Platform 사용 목적\n**Email #6:** Firebase 사용 범위\n\n각 이메일마다 요청사항을 작성해서 회신했다. 솔직히 이 과정이 좀 길었다.\n\n**\"혹시 떨어지는 거 아냐?\"**\n\n불안했다. 매번 추가 요청이 올 때마다 탈락 통보가 아닐까 걱정됐다.\n\n### 4단계: 승인! (Email #7)\n\n그리고 드디어, 7번째 이메일:\n\n> **\"You're Approved for the Google for Startups Cloud Program\"**\n\n승인됐다.\n\n순간 가슴이 뛰었다. 구글이 폴링고를 인정해준 느낌이었다.\n\n**승인 내용:**\n- $350,000 Google Cloud 크레딧\n- 2년간 사용 가능\n- Cloud, Firebase, Maps Platform 모두 포함\n- 기술 지원 및 워크샵 참여 기회\n\n## 실제로 얼마나 도움이 됐나?\n\n승인 이후, 폴링고 인프라를 전부 Google Cloud로 구축했다.\n\n**실제 사용 중인 서비스:**\n- Cloud Run: FastAPI 백엔드 서버 ($50/월 예상)\n- Cloud SQL: PostgreSQL 데이터베이스 ($100/월 예상)\n- Cloud Storage: 이미지 저장 ($20/월 예상)\n- Vision API: 이미지 분석 ($30/월 예상)\n- Maps Platform: 지도 및 장소 검색 ($150/월 예상)\n- Firebase Auth: 사용자 인증 (무료)\n\n**월 예상 비용: $350**\n**2년 총 예상 비용: $8,400**\n\n$350,000 크레딧이 있으니, **당분간 인프라 비용 걱정 없이 개발에만 집중**할 수 있게 됐다.\n\n## 신청 팁\n\nGoogle for Startups Cloud Program 신청을 고려하는 스타트업들을 위한 팁:\n\n**1. 공개 웹사이트는 필수**\n- 간단해도 괜찮다\n- About 페이지 + 연락처만 있어도 됨\n- 앱만 있다면 랜딩 페이지라도 만들자\n\n**2. 구체적인 사용 계획 작성**\n- \"Cloud Run으로 API 서버 운영\"\n- \"Vision API로 이미지 분석 기능 구현\"\n- 막연한 계획보다 구체적인 게 좋다\n\n**3. 추가 요청에 빠르게 응답**\n- 보통 2-3일 내 회신\n- 늦으면 신청이 취소될 수 있음\n\n**4. 포기하지 말기**\n- 추가 요청 여러 번 와도 정상임\n- 나도 6번의 추가 요청을 받았음\n\n## 프로그램 활용하기\n\n승인 이후 제공되는 것들:\n\n**크레딧 외 혜택:**\n- Google Cloud 기술 지원\n- 스타트업 워크샵 및 이벤트 초대\n- Google for Startups Campus 네트워킹\n- 멘토링 기회\n\n폴링고는 크레딧뿐 아니라 **Google Cloud 아키텍처 설계에 대한 기술 지원**도 받을 수 있었다.\n\n## 마치며\n\nGoogle for Startups Cloud Program은 **초기 스타트업에게 정말 큰 도움**이 된다.\n\n특히 AI, 지도, 인프라가 필요한 서비스라면 더욱 그렇다.\n\n신청 과정이 길어도, 추가 요청이 여러 번 와도, 포기하지 말고 끝까지 응답하면 된다.\n\n**나의 꿈은 구글이니까.**\n\n구글이라는 회사에 들어갈 순 없지만, 구글의 기술로 내 앱을 만들 수 있다면 그것으로 충분하다.\n\n---\n\n**참고 링크:**\n- [Google for Startups Cloud Program](https://cloud.google.com/startup)\n- [신청 자격 요건](https://cloud.google.com/startup/eligibility)",
      "description": "Google for Startups Cloud Program 신청 과정과 웹사이트 인증, 그리고 승인까지의 여정. 최대 $350,000 크레딧 지원을 받기까지",
      "tags": [
        "fallingo",
        "google-for-startups",
        "google-cloud",
        "startup"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/fallingo-02-google-for-startups.md"
    },
    {
      "slug": "fallingo-tech-01-redis-optimization",
      "title": "[기술 심화] Redis 캐싱으로 API 응답속도 76% 개선하기 - 실전 최적화 가이드",
      "date": "2025-11-09T00:00:00.000Z",
      "category": "tech",
      "content": "# [기술 심화] Redis 캐싱으로 API 응답속도 76% 개선하기\n\n## 들어가며\n\n지난주 폴링고 백엔드에 Redis 캐싱을 적용하면서 **API 응답속도를 76%나 개선**했어.\n\n이번 글에서는 단순히 \"Redis를 적용했다\"는 이야기가 아니라:\n- 왜 Redis를 선택했는지\n- 어떻게 구현했는지\n- 실제 성능이 얼마나 나왔는지\n- 어떤 문제를 겪고 해결했는지\n\n**실전 경험**을 상세히 공유해보려고 해.\n\n## 문제 상황: 느린 API 응답 속도\n\n### Before: Redis 적용 전\n\n폴링고 백엔드 API들의 평균 응답 시간:\n\n```\nGET /feeds        : 800ms (피드 목록 조회)\nGET /users/{id}   : 500ms (프로필 조회)\nGET /follows      : 600ms (팔로우 목록)\nGET /stats        : 400ms (통계 조회)\nPOST /feeds/{id}/like : 2100ms (좋아요)\n```\n\n특히 피드 목록 조회가 느렸어. 왜냐하면:\n\n```python\n@app.get(\"/feeds\")\nasync def get_feeds(skip: int = 0, limit: int = 20):\n    # 1. 피드 목록 조회 (300ms)\n    feeds = await db.execute(\n        \"SELECT * FROM feeds ORDER BY created_at DESC LIMIT $1 OFFSET $2\",\n        limit, skip\n    )\n\n    # 2. 각 피드마다 작성자 정보 조회 (200ms)\n    for feed in feeds:\n        feed.author = await db.fetchone(\n            \"SELECT * FROM users WHERE id = $1\",\n            feed.author_id\n        )\n\n    # 3. 각 피드마다 좋아요 수 조회 (200ms)\n    for feed in feeds:\n        feed.likes_count = await db.fetchone(\n            \"SELECT COUNT(*) FROM likes WHERE feed_id = $1\",\n            feed.id\n        )\n\n    # 4. 각 피드마다 댓글 수 조회 (100ms)\n    for feed in feeds:\n        feed.comments_count = await db.fetchone(\n            \"SELECT COUNT(*) FROM comments WHERE feed_id = $1\",\n            feed.id\n        )\n\n    return feeds  # 총 800ms\n```\n\n**N+1 쿼리 문제**가 심각했어. 피드 20개 조회하면 60개 이상의 쿼리가 발생하더라고.\n\n### 해결 방안 검토\n\n여러 방법을 고민했어:\n\n**1) JOIN으로 쿼리 최적화**\n```sql\nSELECT f.*, u.*, COUNT(l.id) as likes, COUNT(c.id) as comments\nFROM feeds f\nLEFT JOIN users u ON f.author_id = u.id\nLEFT JOIN likes l ON f.id = l.feed_id\nLEFT JOIN comments c ON f.id = c.feed_id\nGROUP BY f.id, u.id\n```\n\n장점: 단일 쿼리로 해결\n단점: 복잡한 JOIN, 여전히 매번 DB 조회\n\n**2) Materialized View**\n```sql\nCREATE MATERIALIZED VIEW feed_view AS ...\n```\n\n장점: 미리 계산된 결과\n단점: 업데이트 타이밍 문제, 실시간성 부족\n\n**3) Redis 캐싱**\n```python\n# 캐시 확인\ncached = await redis.get(f\"feed:{feed_id}\")\nif cached:\n    return cached\n\n# 없으면 DB 조회 후 캐싱\ndata = await db.fetch(...)\nawait redis.setex(f\"feed:{feed_id}\", 300, data)\nreturn data\n```\n\n장점: 빠른 응답, 유연한 TTL 설정, 실시간 무효화 가능\n단점: 캐시 관리 복잡도 증가\n\n**결론: Redis 캐싱 선택!**\n\n왜냐하면:\n- Google for Startups Cloud Program으로 GCP Memorystore Redis 무료 사용 가능\n- 실시간성이 중요한 피드 서비스에 적합\n- TTL로 자동 만료 가능\n- 필요시 즉시 무효화 가능\n\n## Redis 캐싱 시스템 구축\n\n### 1. GCP Memorystore Redis 인스턴스 생성\n\n```bash\n# GCP Console에서 Redis 인스턴스 생성\n# Tier: Basic (개발/테스트용)\n# Capacity: 1GB\n# Region: asia-northeast3 (서울)\n# Version: Redis 7.0\n```\n\n### 2. FastAPI에 Redis 클라이언트 설정\n\n```python\n# config.py\nfrom pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    REDIS_HOST: str = \"10.0.0.3\"  # GCP Memorystore 내부 IP\n    REDIS_PORT: int = 6379\n    REDIS_SOCKET_TIMEOUT: int = 5\n    REDIS_SOCKET_CONNECT_TIMEOUT: int = 5\n\nsettings = Settings()\n```\n\n```python\n# redis_client.py\nimport redis\nimport json\nfrom typing import Optional, Any\n\nclass RedisClient:\n    def __init__(self):\n        try:\n            self.client = redis.Redis(\n                host=settings.REDIS_HOST,\n                port=settings.REDIS_PORT,\n                decode_responses=True,\n                socket_connect_timeout=settings.REDIS_SOCKET_CONNECT_TIMEOUT,\n                socket_timeout=settings.REDIS_SOCKET_TIMEOUT\n            )\n            # 연결 테스트\n            self.client.ping()\n            self.available = True\n        except Exception as e:\n            print(f\"Redis connection failed: {e}\")\n            self.client = None\n            self.available = False\n\n    async def get(self, key: str) -> Optional[Any]:\n        \"\"\"캐시 조회\"\"\"\n        if not self.available:\n            return None\n\n        try:\n            value = self.client.get(key)\n            if value:\n                return json.loads(value)\n            return None\n        except Exception as e:\n            print(f\"Redis GET error: {e}\")\n            return None\n\n    async def setex(self, key: str, ttl: int, value: Any) -> bool:\n        \"\"\"캐시 저장 (TTL 포함)\"\"\"\n        if not self.available:\n            return False\n\n        try:\n            self.client.setex(\n                key,\n                ttl,\n                json.dumps(value, default=str)\n            )\n            return True\n        except Exception as e:\n            print(f\"Redis SETEX error: {e}\")\n            return False\n\n    async def delete(self, *keys: str) -> bool:\n        \"\"\"캐시 삭제\"\"\"\n        if not self.available:\n            return False\n\n        try:\n            self.client.delete(*keys)\n            return True\n        except Exception as e:\n            print(f\"Redis DELETE error: {e}\")\n            return False\n\nredis_client = RedisClient()\n```\n\n**핵심 포인트**:\n- **타임아웃 설정**: Cloud Run에서 startup timeout 방지\n- **연결 실패 처리**: Redis 없이도 서비스 정상 동작 (Fallback)\n- **JSON 직렬화**: Python 객체를 문자열로 변환\n\n### 3. 서비스별 캐싱 전략\n\n#### 3.1 피드 목록 캐싱 (TTL: 300초)\n\n```python\n# services/feed_service.py\nasync def get_feeds(skip: int = 0, limit: int = 20) -> list:\n    # 캐시 키 생성\n    cache_key = f\"feeds:list:{skip}:{limit}\"\n\n    # 캐시 조회\n    cached = await redis_client.get(cache_key)\n    if cached:\n        return cached\n\n    # DB 조회\n    feeds = await db.execute(\n        \"\"\"\n        SELECT f.*, u.username, u.profile_image,\n               COUNT(DISTINCT l.id) as likes_count,\n               COUNT(DISTINCT c.id) as comments_count\n        FROM feeds f\n        LEFT JOIN users u ON f.author_id = u.id\n        LEFT JOIN likes l ON f.id = l.feed_id\n        LEFT JOIN comments c ON f.id = c.feed_id\n        GROUP BY f.id, u.id\n        ORDER BY f.created_at DESC\n        LIMIT $1 OFFSET $2\n        \"\"\",\n        limit, skip\n    )\n\n    # 결과를 캐시에 저장 (5분)\n    await redis_client.setex(cache_key, 300, feeds)\n\n    return feeds\n```\n\n**왜 300초?**\n- 피드는 자주 업데이트되지만, 실시간이 아니어도 괜찮아\n- 5분 정도는 허용 가능한 지연\n- 너무 짧으면 캐시 효과 감소, 너무 길면 오래된 데이터\n\n#### 3.2 사용자 프로필 캐싱 (TTL: 600초)\n\n```python\nasync def get_user_profile(user_id: int) -> dict:\n    cache_key = f\"user:profile:{user_id}\"\n\n    cached = await redis_client.get(cache_key)\n    if cached:\n        return cached\n\n    profile = await db.fetchone(\n        \"\"\"\n        SELECT u.*,\n               COUNT(DISTINCT f.id) as feeds_count,\n               COUNT(DISTINCT followers.id) as followers_count,\n               COUNT(DISTINCT following.id) as following_count\n        FROM users u\n        LEFT JOIN feeds f ON u.id = f.author_id\n        LEFT JOIN follows followers ON u.id = followers.following_id\n        LEFT JOIN follows following ON u.id = following.follower_id\n        WHERE u.id = $1\n        GROUP BY u.id\n        \"\"\",\n        user_id\n    )\n\n    # 10분 캐싱\n    await redis_client.setex(cache_key, 600, profile)\n\n    return profile\n```\n\n**왜 600초?**\n- 프로필은 자주 변경되지 않아\n- 팔로워 수 등은 약간의 지연 허용\n- 더 긴 TTL로 캐시 효율 극대화\n\n#### 3.3 팔로우 관계 캐싱 (TTL: 300초)\n\n```python\nasync def get_following_list(user_id: int) -> list:\n    cache_key = f\"user:{user_id}:following\"\n\n    cached = await redis_client.get(cache_key)\n    if cached:\n        return cached\n\n    following = await db.execute(\n        \"\"\"\n        SELECT u.* FROM users u\n        INNER JOIN follows f ON u.id = f.following_id\n        WHERE f.follower_id = $1\n        \"\"\",\n        user_id\n    )\n\n    await redis_client.setex(cache_key, 300, following)\n\n    return following\n```\n\n#### 3.4 통계 데이터 캐싱 (TTL: 180초)\n\n```python\nasync def get_feed_stats(feed_id: int) -> dict:\n    cache_key = f\"feed:{feed_id}:stats\"\n\n    cached = await redis_client.get(cache_key)\n    if cached:\n        return cached\n\n    stats = {\n        \"likes_count\": await db.fetchone(\n            \"SELECT COUNT(*) FROM likes WHERE feed_id = $1\", feed_id\n        ),\n        \"comments_count\": await db.fetchone(\n            \"SELECT COUNT(*) FROM comments WHERE feed_id = $1\", feed_id\n        ),\n        \"views_count\": await db.fetchone(\n            \"SELECT view_count FROM feeds WHERE id = $1\", feed_id\n        )\n    }\n\n    # 3분 캐싱\n    await redis_client.setex(cache_key, 180, stats)\n\n    return stats\n```\n\n**왜 180초?**\n- 통계는 실시간성이 더 중요해\n- 좋아요/댓글이 빠르게 변하니까\n- 짧은 TTL로 최신성 유지\n\n### 4. 캐시 무효화 전략\n\n데이터가 변경되면 즉시 캐시를 삭제해야 해.\n\n#### 4.1 피드 생성 시\n\n```python\n@app.post(\"/feeds\")\nasync def create_feed(\n    content: str,\n    user_id: int = Depends(get_current_user),\n    background_tasks: BackgroundTasks = None\n):\n    # 피드 생성\n    feed = await db.execute(\n        \"INSERT INTO feeds (author_id, content) VALUES ($1, $2) RETURNING *\",\n        user_id, content\n    )\n\n    # 백그라운드에서 캐시 무효화\n    background_tasks.add_task(\n        invalidate_feed_caches,\n        user_id\n    )\n\n    return feed\n\nasync def invalidate_feed_caches(user_id: int):\n    \"\"\"피드 관련 캐시 무효화\"\"\"\n    # 피드 목록 캐시 삭제 (모든 페이지)\n    pattern = \"feeds:list:*\"\n    # Redis SCAN으로 패턴 매칭 키 찾기\n    keys = []\n    for key in redis_client.client.scan_iter(pattern):\n        keys.append(key)\n\n    if keys:\n        await redis_client.delete(*keys)\n\n    # 작성자 프로필 캐시 삭제\n    await redis_client.delete(f\"user:profile:{user_id}\")\n```\n\n#### 4.2 좋아요 시\n\n```python\n@app.post(\"/feeds/{feed_id}/like\")\nasync def like_feed(\n    feed_id: int,\n    user_id: int = Depends(get_current_user),\n    background_tasks: BackgroundTasks = None\n):\n    # 즉시 응답 (낙관적 업데이트)\n    background_tasks.add_task(\n        process_like,\n        feed_id, user_id\n    )\n\n    return {\"status\": \"processing\"}\n\nasync def process_like(feed_id: int, user_id: int):\n    # 좋아요 추가\n    await db.execute(\n        \"INSERT INTO likes (feed_id, user_id) VALUES ($1, $2)\",\n        feed_id, user_id\n    )\n\n    # 캐시 무효화\n    await redis_client.delete(\n        f\"feed:{feed_id}:stats\",  # 피드 통계\n        f\"feeds:list:*\"            # 피드 목록\n    )\n\n    # FCM 알림 전송\n    await send_notification(feed_id, user_id, \"like\")\n```\n\n**핵심**: 백그라운드에서 처리하니까 사용자는 빠르게 응답을 받아!\n\n#### 4.3 프로필 수정 시\n\n```python\n@app.put(\"/users/{user_id}\")\nasync def update_profile(\n    user_id: int,\n    data: dict,\n    background_tasks: BackgroundTasks = None\n):\n    # 프로필 수정\n    await db.execute(\n        \"UPDATE users SET ... WHERE id = $1\",\n        user_id\n    )\n\n    # 캐시 무효화\n    background_tasks.add_task(\n        invalidate_user_caches,\n        user_id\n    )\n\n    return {\"status\": \"success\"}\n\nasync def invalidate_user_caches(user_id: int):\n    \"\"\"사용자 관련 캐시 무효화\"\"\"\n    await redis_client.delete(\n        f\"user:profile:{user_id}\",\n        f\"user:{user_id}:following\",\n        f\"user:{user_id}:followers\"\n    )\n```\n\n## 성능 측정 결과\n\n### Before vs After\n\n| API | Before | After | 개선율 |\n|-----|--------|-------|--------|\n| GET /feeds | 800ms | 150ms | **81%** |\n| GET /users/{id} | 500ms | 100ms | **80%** |\n| GET /follows | 600ms | 120ms | **80%** |\n| GET /stats | 400ms | 200ms | **50%** |\n| POST /feeds/{id}/like | 2100ms | 500ms | **76%** |\n\n**평균 응답 시간: 860ms → 214ms (75% 개선)**\n\n### 캐시 히트율\n\n```\n총 요청 수: 10,000\n캐시 히트: 8,200 (82%)\n캐시 미스: 1,800 (18%)\n```\n\n**82%의 요청이 캐시에서 처리**됐어!\n\n### 데이터베이스 부하 감소\n\n```\nBefore Redis:\n- DB 쿼리 수: 50,000 / 시간\n- DB CPU 사용률: 65%\n\nAfter Redis:\n- DB 쿼리 수: 9,000 / 시간 (**82% 감소**)\n- DB CPU 사용률: 12% (**81% 감소**)\n```\n\nRedis 덕분에 DB 부하가 엄청나게 줄었어!\n\n## 겪었던 문제들과 해결\n\n### 문제 1: Cloud Run Startup Timeout\n\n**증상**:\n```\nERROR: Container failed to start.\nFailed to start and then listen on the port defined by the PORT environment variable.\n```\n\n**원인**:\nRedis 연결 시 타임아웃 설정이 없어서, 연결 안 되면 무한정 기다림.\n\n**해결**:\n```python\nredis.Redis(\n    host=settings.REDIS_HOST,\n    port=settings.REDIS_PORT,\n    socket_connect_timeout=5,  # 타임아웃 추가!\n    socket_timeout=5\n)\n```\n\n### 문제 2: Redis 패키지 의존성 누락\n\n**증상**:\n```\nModuleNotFoundError: No module named 'redis'\n```\n\n**원인**:\n`requirements.txt`에 `redis` 패키지 추가를 깜빡함.\n\n**해결**:\n```txt\nredis==5.0.1\n```\n\n### 문제 3: 직렬화 에러\n\n**증상**:\n```\nTypeError: Object of type datetime is not JSON serializable\n```\n\n**원인**:\nPython `datetime` 객체를 JSON으로 변환할 수 없음.\n\n**해결**:\n```python\njson.dumps(value, default=str)  # datetime을 문자열로 변환\n```\n\n### 문제 4: 캐시 키 충돌\n\n**증상**:\n다른 사용자가 같은 캐시를 공유하는 버그.\n\n**원인**:\n캐시 키에 사용자 ID를 포함하지 않음.\n\n**해결**:\n```python\n# Before\ncache_key = \"feeds:list:0:20\"  # 모든 사용자가 공유!\n\n# After\ncache_key = f\"user:{user_id}:feeds:list:0:20\"  # 사용자별 캐시\n```\n\n## 배운 점\n\n### 1. 캐싱은 만능이 아니야\n\n캐싱이 항상 좋은 건 아니더라고:\n\n**캐싱이 좋은 경우**:\n- 자주 읽히는 데이터 (피드 목록, 프로필)\n- 변경이 드문 데이터 (설정, 카테고리)\n- 계산 비용이 높은 데이터 (통계, 집계)\n\n**캐싱이 안 좋은 경우**:\n- 실시간성이 중요한 데이터 (채팅 메시지)\n- 항상 다른 데이터 (검색 결과)\n- 한 번만 읽히는 데이터\n\n### 2. TTL 설정이 중요해\n\nTTL을 너무 짧게 하면:\n- 캐시 효과 감소\n- Redis 트래픽 증가\n\nTTL을 너무 길게 하면:\n- 오래된 데이터 제공\n- 사용자 경험 저하\n\n**적절한 균형**을 찾는 게 핵심이야!\n\n### 3. Fallback 메커니즘 필수\n\nRedis가 죽으면 서비스 전체가 죽으면 안 돼.\n\n```python\ncached = await redis_client.get(key)\nif cached:\n    return cached\n\n# Redis 실패 시 DB 조회 (Fallback)\nreturn await db.fetch(...)\n```\n\n### 4. 모니터링이 중요해\n\n캐시 히트율, TTL 적정성, 메모리 사용량 등을 지속적으로 모니터링해야 해.\n\n```python\n# Redis INFO 명령으로 모니터링\ninfo = redis_client.client.info()\nprint(f\"Used memory: {info['used_memory_human']}\")\nprint(f\"Keyspace hits: {info['keyspace_hits']}\")\nprint(f\"Keyspace misses: {info['keyspace_misses']}\")\n```\n\n## 더 나아갈 방향\n\n캐싱은 끝이 아니야. 앞으로 더 개선할 부분들:\n\n**캐시 워밍**: 앱 시작 시 인기 피드를 미리 캐싱해두면 첫 사용자 경험이 더 좋아질 거야.\n\n**캐시 압축**: 큰 데이터는 gzip으로 압축해서 저장하면 메모리 효율이 올라가.\n\n**Redis Cluster**: 트래픽이 증가하면 Primary/Replica 구조로 확장성을 확보할 수 있어.\n\n## 핵심 정리\n\nRedis 캐싱으로 **평균 응답속도 76% 개선**을 달성했어.\n\n성공의 요인:\n- **적절한 TTL 설정**: 데이터 특성별로 180초~600초 차등 적용\n- **즉각적인 무효화**: BackgroundTasks로 데이터 변경 시 실시간 캐시 삭제\n- **Fallback 메커니즘**: Redis 장애 시에도 서비스 정상 작동\n- **캐시 히트율 82%**: 데이터베이스 부하 82% 감소\n\n단순히 Redis를 붙인 게 아니라, 서비스 특성에 맞는 캐싱 전략을 설계했기에 가능했어.\n\n**그리고 AI(Claude)와의 협업 덕분에 3일 만에 완성할 수 있었어.**\n\n---\n\n**레퍼런스**\n- [Redis 공식 문서](https://redis.io/docs/)\n- [FastAPI BackgroundTasks](https://fastapi.tiangolo.com/tutorial/background-tasks/)\n- [GCP Memorystore for Redis](https://cloud.google.com/memorystore/docs/redis)",
      "description": "GCP Memorystore Redis를 활용한 FastAPI 백엔드 성능 최적화. 실제 성능 측정 데이터와 함께하는 캐싱 전략 완벽 가이드",
      "tags": [
        "fallingo",
        "redis",
        "caching",
        "performance",
        "fastapi",
        "gcp",
        "optimization",
        "technical"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/fallingo-tech-01-redis-optimization.md"
    },
    {
      "slug": "fallingo-week-2025-05-26",
      "title": "Fallingo 개발일지 - 2025년 5월 4주차 (05.26 ~ 06.01)",
      "date": "2025-06-01T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n새로운 음식 추천 플랫폼 프로젝트를 시작했다. 프로젝트 이름은 FlavorPoint - \"진짜 맛있는 한 점을 찾다\"는 의미를 담았다. 첫 주는 서비스 기획과 문서화에 집중했다. 제안서부터 시작해 서비스 철학, 비전, 주요 기능까지 체계적으로 정리했다.\n\n## 주요 작업\n\n### 프로젝트 시작 (5/28)\n- flavor-point 저장소 생성\n- 초기 제안서(proposal.md) 작성\n- 프로젝트 방향성 수립\n\n### 서비스 철학 정립 (5/29)\nFlavorPoint의 핵심 가치를 정리했다.\n- 사용자 중심: \"지금, 여기서, 진짜 맛있는 메뉴\"를 가장 쉽고 빠르게\n- 신뢰 기반: 실제 방문객의 현장 인증과 솔직한 추천\n- 메뉴 집중: 점포 평점이 아닌 특정 메뉴의 맛에 집중\n- 경험의 가치: 사용자의 시간과 선택을 최고의 미식 경험으로\n\n### 문서 구조화\n프로젝트 문서를 체계적으로 분리했다.\n- 00_FlavorPoint_철학.md\n- 01_서비스_개요.md\n- 02_서비스_비전_미션.md\n- 03_주요기능.md\n- 04_소셜_네트워크_기능.md\n- 05_차별화_포인트.md\n- 06_기술_스택.md\n- 07_개발_진행_상황.md\n- 08_향후_로드맵.md\n- 09_개인정보_및_위치정보.md\n- 10_문의_및_제안.md\n\n### 핵심 기능 정의\n**실시간 현장 인증 시스템**\n- GPS 기반 위치 인증\n- 카메라로 음식 사진 촬영\n- 메뉴명, 가격, 설명 정보 입력\n- 신뢰도 높은 리뷰 생성\n\n**인스타그램 스타일 피드**\n- 음식 사진 중심의 소셜 피드\n- 하트로 메뉴 추천\n- 댓글과 공유 기능\n- 실시간 인기 메뉴 랭킹\n\n**등급 시스템 설계**\n한국 음식을 기반으로 한 10단계 등급 체계를 구상했다.\n- 일반 등급 (1-7단계): 누룽지 → 비빔밥 → 삼겹살 → 갈비탕 → 모둠회 → 잔칫상 → 수랏상\n- 인플루언서 등급 (8-10단계): 대장금 ⭐ / ⭐⭐ / ⭐⭐⭐\n\n## 기술 스택 결정\n\n**프론트엔드**\n- Flutter 3.x (크로스플랫폼)\n- Material Design 3\n- 인스타그램 스타일 UI\n\n**백엔드**\n- Flask 2.3.3 (Python)\n- RESTful API\n- Mock 데이터로 시작\n\n**향후 계획**\n- Firebase (Firestore, Auth, Storage)\n- Google Cloud Vision API (OCR)\n- AI 기반 추천 시스템\n\n## 배운 점\n\n**왜 FlavorPoint인가**\n\n기존 맛집 앱들을 열어볼 때마다 느껴지는 불편함이 있었다. 조작된 것 같은 리뷰들, 광고인지 리뷰인지 모를 글들, 점포는 별 다섯인데 정작 맛없는 메뉴들. 이 문제를 풀려면 '메뉴'에 집중해야 한다는 생각이 들었다. 점포가 아니라 그 안의 \"맛의 한 점\"을 찾는 서비스. FlavorPoint라는 이름에 그 의미를 담았다.\n\n**현장 인증이라는 선택**\n\nGPS와 카메라로 이루어진 3단계 인증 시스템을 설계하면서 고민이 많았다. 사용자에게 너무 번거로운 건 아닐까. 하지만 신뢰를 만들려면 불편함을 감수해야 한다. 조작하기 어렵지만, 실제 사용자에게는 자연스러운 흐름. 그 균형점을 찾으려 했다.\n\n**누룽지부터 수랏상까지**\n\n게이미피케이션은 필요하지만, 외국 것을 빌려오고 싶지 않았다. 미슐랭 가이드의 성장 체계는 좋지만, 한국 서비스에는 한국적인 것이 어울린다. 누룽지에서 시작해 수랏상까지 오르는 여정. 대장금 별 세 개. 사용자가 등급을 올리며 느낄 성취감을 상상했다.\n\n**빈 에디터 앞에서**\n\n코드를 작성하기 전, 빈 에디터 앞에 앉아 있는 시간이 길었다. 10개가 넘는 문서를 만들며 서비스를 구조화했다. 철학, 비전, 주요 기능, 차별화 포인트까지. 문서를 쓰는 동안 프로젝트가 점점 선명해졌다. 서두르지 않고 생각할 수 있는 시간이었다.",
      "description": "## 이번 주 요약\n\n새로운 음식 추천 플랫폼 프로젝트를 시작했다. 프로젝트 이름은 FlavorPoint - \"진짜 맛있는 한 점을 찾다\"는 의미를 담았다. 첫 주는 서비스 기획과 문서화에 집중했다. 제안서부터 시작해 서비스 철학, 비전, 주요 기능까지 체계적으로 정리했다.\n\n## 주요",
      "tags": [
        "기획",
        "서비스설계",
        "문서화"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-05-26.md"
    },
    {
      "slug": "fallingo-week-2025-06-02",
      "title": "Fallingo 개발일지 - 2025년 6월 1주차 (06.02 ~ 06.08)",
      "date": "2025-06-08T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n프로젝트의 중요한 전환점이 있었던 주였다. FlavorPoint라는 이름으로 시작했지만, 더 나은 이름을 찾게 되었다. fallingo.app 도메인을 발견하고 구매했고, 프로젝트 이름도 Fallingo로 변경했다. \"falling in go\" - 빠져들다, 몰입하다는 의미가 마음에 들었다. 저장소도 새로 만들고 프로젝트 구조를 정리했다.\n\n## 주요 작업\n\n### FlavorPoint 문서 정리 (6/1-6/2)\n마지막으로 FlavorPoint 문서들을 정리했다.\n- 주요 기능 명세 업데이트\n- 소셜 네트워크 기능 세부 정의\n- 차별화 포인트 정리\n- 기술 및 개발 로드맵 작성\n\n문서 파일명도 한글로 정리해서 가독성을 높였다.\n- `03_주요기능.md` → `주요기능.md`\n- `04_소셜_네트워크_기능.md` → `소셜_네트워크_기능.md`\n- `05_차별화_포인트.md` → `차별화_포인트.md`\n\n### Fallingo 저장소 생성 (6/4)\n새로운 저장소를 만들고 프로젝트를 이전했다.\n- fallingo 저장소 생성\n- 기존 문서들 마이그레이션\n- README 업데이트\n\n### 개발 플래닝 시작 (6/2)\n본격적인 개발 계획을 수립하기 시작했다.\n- 개발 단계 정의\n- Phase별 목표 설정\n- 기술 스택 확정\n\n### FlavorPoint 마지막 업데이트 (6/5)\nFlavorPoint 저장소에 마지막 업데이트를 했다.\n- README 최종 정리\n- 프로젝트 방향성 문서화\n- 향후 계획 명시\n\n## 프로젝트 이름 변경 스토리\n\n### FlavorPoint의 한계\nFlavorPoint는 의미는 좋았지만 몇 가지 문제가 있었다.\n- 발음이 길고 복잡함\n- 영문 도메인 확보가 어려움\n- 글로벌 확장을 고려하면 한계가 있음\n\n### Fallingo 발견\n도메인을 찾다가 fallingo.app을 발견했다. 순간 직감적으로 끌렸다.\n\n**falling in go의 의미**\n- falling in: ~에 빠지다, 몰입하다\n- go: 움직이다, 가다, 진행하다\n\n음식에 빠져들고, 맛집 탐험을 떠나고, 미식 여정을 계속하는 의미가 모두 담겨있다. 짧고 발음하기 쉽고, .app 도메인이라 모바일 앱 정체성도 명확하다.\n\n### 도메인 구매 결정\n고민 없이 바로 구매했다. 좋은 이름과 도메인은 프로젝트의 정체성을 만든다. FlavorPoint보다 훨씬 더 직관적이고 기억하기 쉬운 이름이다.\n\n### 저장소 마이그레이션\nflavor-point 저장소는 보관하고, fallingo라는 새 저장소를 만들었다. 새 출발이지만 지금까지의 기획과 고민은 모두 가져갔다.\n\n## 기술 스택 확정\n\n**전체 아키텍처**\n- Frontend: Flutter (iOS/Android)\n- Backend: Flask (Python)\n- Database: Firebase Firestore\n- Auth: Firebase Auth\n- Storage: Firebase Storage\n\n**추가 서비스**\n- Google Cloud Vision API (OCR, 이미지 인식)\n- Google Maps Platform (위치 서비스)\n- Firebase Cloud Messaging (푸시 알림)\n\n## 배운 점\n\n**fallingo.app을 발견한 순간**\n\n도메인을 검색하다가 fallingo.app을 발견했을 때의 느낌을 기억한다. Falling in - 빠져들다. Go - 나아가다. 음식에 빠져들고, 맛집을 찾아 떠나는 여정. FlavorPoint보다 훨씬 직관적이고 발음하기 쉬웠다. 고민 없이 바로 구매했다.\n\n**이름을 바꾸는 용기**\n\nFlavorPoint라는 이름으로 며칠간 작업했지만, 더 나은 이름을 찾았을 때 주저하지 않았다. 아직 개발 초기라 변경 비용이 크지 않았다. 제품이 나온 후라면 훨씬 어려웠을 것이다. 지금이 아니면 안 된다는 생각이 들었다.\n\n**문서가 남긴 것들**\n\nFlavorPoint 시절 작성한 10개 이상의 문서들이 고스란히 자산이 되었다. 서비스 철학, 핵심 기능, 기술 스택. 이름만 바뀌었을 뿐, 지금까지의 고민은 모두 Fallingo로 이어졌다. 문서로 정리해두길 잘했다는 생각이 들었다.\n\n**.app 도메인의 의미**\n\n.app 도메인은 단순한 확장자가 아니다. HTTPS가 필수라 보안이 강화되고, 사용자들이 직관적으로 \"앱\"이라고 인식한다. 추가 비용이 들었지만, 좋은 도메인은 투자할 가치가 있다. Fallingo의 정체성을 만드는 첫 단추였다.",
      "description": "## 이번 주 요약\n\n프로젝트의 중요한 전환점이 있었던 주였다. FlavorPoint라는 이름으로 시작했지만, 더 나은 이름을 찾게 되었다. fallingo.app 도메인을 발견하고 구매했고, 프로젝트 이름도 Fallingo로 변경했다. \"falling in go\" - 빠져들다, 몰입하",
      "tags": [
        "기획",
        "리브랜딩",
        "저장소전환"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-06-02.md"
    },
    {
      "slug": "fallingo-week-2025-06-09",
      "title": "Fallingo 개발일지 - 2025년 6월 2주차 (06.09 ~ 06.15)",
      "date": "2025-06-15T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n본격적인 개발이 시작되었다. Fallingo의 기술 아키텍처를 설계하고 개발 가이드 문서를 작성했다. Phase 0부터 Phase 2까지 단계별로 구현하면서 프로젝트의 기반을 다졌다. 프로젝트 구조, 환경 설정, 기본 API 엔드포인트까지 완성했다.\n\n## 주요 작업\n\n### 프로젝트 재시작 (6/13)\nFallingo로 완전히 넘어와서 프로젝트를 재시작했다.\n- 개발 문서 업데이트\n- 기술 스택 재정리\n- 프로젝트 구조 확정\n\n### 개발 가이드 문서 작성 (6/14)\n체계적인 개발을 위해 Part 0 개발 가이드를 작성했다.\n- 환경 설정 가이드\n- 프로젝트 구조 설계\n- 코딩 컨벤션 정의\n- Git 워크플로우 설정\n\n### Phase 0: 프로젝트 초기 설정 완료 (6/14)\n**백엔드 구조**\n```\nbackend/\n├── app/\n│   ├── main.py          # FastAPI 앱\n│   ├── models/          # 데이터 모델\n│   ├── routes/          # API 라우터\n│   ├── services/        # 비즈니스 로직\n│   └── config.py        # 설정\n├── requirements.txt\n└── README.md\n```\n\n**프론트엔드 구조**\n```\nfrontend/\n├── lib/\n│   ├── main.dart\n│   ├── models/\n│   ├── screens/\n│   ├── services/\n│   └── widgets/\n└── pubspec.yaml\n```\n\n### Phase 1: 시스템 설계 완료 (6/14)\n**데이터베이스 스키마 설계**\n- User (사용자)\n- Feed (음식 피드)\n- Restaurant (음식점)\n- Menu (메뉴)\n- Follow (팔로우)\n- Point (포인트)\n- Tier (등급)\n\n**API 엔드포인트 설계**\n- 인증: /auth/login, /auth/signup\n- 피드: /feeds, /feeds/{id}\n- 사용자: /users/{id}\n- 음식점: /restaurants\n- 팔로우: /follows\n\n### Phase 2: 기본 API 구현 (6/15)\nFastAPI 기반 백엔드 서버 구축을 시작했다.\n\n**주요 모델 정의**\n```python\nclass User(BaseModel):\n    id: str\n    username: str\n    email: str\n    tier: int\n    points: int\n\nclass Feed(BaseModel):\n    id: str\n    user_id: str\n    restaurant_id: str\n    image_url: str\n    description: str\n    location: dict\n```\n\n**기본 엔드포인트 구현**\n- GET /api/health (헬스체크)\n- POST /api/auth/signup (회원가입)\n- POST /api/auth/login (로그인)\n- GET /api/feeds (피드 목록)\n\n### 개발 문서 업데이트 (6/15)\n개발 진행 상황을 문서화했다.\n- 개발_진행_로드맵.md 작성\n- 프롬프트 업데이트 (Claude와의 협업 최적화)\n- 프로젝트 지식 문서 정리\n\n## 기술 스택 변경사항\n\n### Flask → FastAPI\n초기에는 Flask를 고려했지만 FastAPI로 변경했다.\n\n**FastAPI 선택 이유**\n- 자동 API 문서 생성 (Swagger UI)\n- 타입 힌트 기반 검증\n- 비동기 처리 지원\n- 더 빠른 성능\n- 현대적인 Python 개발 방식\n\n### PostgreSQL + PostGIS\n위치 기반 서비스를 위해 PostGIS를 추가했다.\n- 공간 데이터 저장 및 검색\n- 반경 기반 쿼리 (ST_DWithin)\n- 효율적인 위치 인덱싱\n\n## 배운 점\n\n**Phase라는 이정표**\n\n대규모 프로젝트를 한 번에 만들려다 길을 잃었던 경험이 있다. 이번에는 Phase로 나눴다. Phase 0부터 2까지, 각 단계마다 테스트 가능한 결과물이 나왔다. 진행 상황이 보이니 안심이 되었다. 아직 갈 길은 멀지만, 방향은 맞다는 확신이 들었다.\n\n**문서가 만드는 리듬**\n\n개발 가이드를 먼저 작성하고 나서 코드를 짰다. 문서를 쓰는 동안 프로젝트 구조가 머릿속에서 정리되었다. 코드를 작성할 때는 헤매지 않았다. 일관성도 자연스럽게 유지되었다. 문서 우선 개발의 리듬이 몸에 배기 시작했다.\n\n**타입이 잡아주는 것들**\n\nFastAPI의 Pydantic 모델을 사용하면서 타입 안정성을 체감했다. 런타임 오류가 줄어들고, IDE가 자동완성을 정확하게 해줬다. 타입 하나로 수많은 버그를 예방할 수 있다는 것을 알았다.\n\n**PostGIS와의 첫 만남**\n\n위치 기반 서비스를 만들기 위해 PostGIS를 공부했다. 일반 데이터베이스로는 복잡한 공간 쿼리를, PostGIS는 간단하게 처리했다. 반경 500m 내 음식점 찾기, 거리 계산, 공간 인덱싱. 강력한 도구를 만났다는 생각이 들었다.",
      "description": "## 이번 주 요약\n\n본격적인 개발이 시작되었다. Fallingo의 기술 아키텍처를 설계하고 개발 가이드 문서를 작성했다. Phase 0부터 Phase 2까지 단계별로 구현하면서 프로젝트의 기반을 다졌다. 프로젝트 구조, 환경 설정, 기본 API 엔드포인트까지 완성했다.\n\n## 주요 작",
      "tags": [
        "시스템설계",
        "백엔드",
        "개발가이드"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-06-09.md"
    },
    {
      "slug": "fallingo-week-2025-06-16",
      "title": "Fallingo 개발일지 - 2025년 6월 3주차 (06.16 ~ 06.22)",
      "date": "2025-06-22T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\nFallingo 프로젝트의 초기 아키텍처를 완성했다. Phase 3-4 개발을 통해 데이터베이스 스키마, 핵심 도메인 모델, 그리고 기본적인 API 구조를 잡았다. 총 25개의 커밋으로 프로젝트의 기반을 다졌다.\n\n## 주요 작업\n\n### 시스템 설계 완료\n- Phase 1-4 단계별 개발 완료\n- Step 2-4 세부 구현 완성\n- 데이터베이스 스키마 설계\n- 도메인 모델 정의\n\n### 기술 스택 결정\n- Backend: FastAPI (Python 3.11)\n- Database: PostgreSQL 16 + PostGIS 3.3\n- Cloud: Google Cloud Platform\n- 위치 기반 서비스를 위한 PostGIS 확장\n\n### 핵심 도메인 설계\n- User (사용자 관리)\n- Feed (음식 피드)\n- Restaurant (음식점 정보)\n- Follow (팔로우 시스템)\n- Point & Tier (포인트/등급 시스템)\n\n## 배운 점\n\n**공간을 다루는 법**\n\nPostGIS로 공간 데이터를 다루는 법을 배웠다. 반경 기반 검색, 거리 계산, 인덱스 전략. 티어에 따라 다른 상호작용 반경을 설계하면서, 위치 기반 서비스의 복잡함을 알게 되었다. 데이터베이스가 단순히 데이터를 저장하는 것이 아니라, 공간을 이해한다는 것이 신기했다.\n\n**FastAPI라는 선택**\n\nFlask 대신 FastAPI를 선택한 이유는 명확했다. 자동 문서화, 타입 힌트 기반 검증, 비동기 처리 지원. Python의 ML/AI 라이브러리를 활용할 수 있다는 점도 마음에 들었다. 개발 속도가 빨라지는 것을 체감했다.\n\n**25개의 커밋, 하나의 기반**\n\nPhase 0부터 2까지, 25개의 커밋으로 프로젝트의 기반을 다졌다. 데이터베이스 스키마, 도메인 모델, API 구조. 아직 화면은 없지만, 탄탄한 백엔드가 만들어지고 있다는 느낌이 들었다. Claude와 함께 체계적으로 설계할 수 있었다.",
      "description": "## 이번 주 요약\n\nFallingo 프로젝트의 초기 아키텍처를 완성했다. Phase 3-4 개발을 통해 데이터베이스 스키마, 핵심 도메인 모델, 그리고 기본적인 API 구조를 잡았다. 총 25개의 커밋으로 프로젝트의 기반을 다졌다.\n\n## 주요 작업\n\n### 시스템 설계 완료\n- Ph",
      "tags": [
        "백엔드",
        "시스템설계",
        "데이터베이스"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-06-16.md"
    },
    {
      "slug": "fallingo-week-2025-06-23",
      "title": "Fallingo 개발일지 - 2025년 6월 4주차 (06.23 ~ 06.29)",
      "date": "2025-06-29T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n지난주 Phase 3-4를 완료하고 API 구현을 시작했지만, 심각한 일관성 문제를 발견했다. 데이터베이스 스키마와 도메인 모델, API 정의가 서로 맞지 않았다. 몇 달간 개발해온 결과물이지만, 근본적인 문제가 있다는 것을 인정해야 했다.\n\n## 직면한 문제들\n\n### 데이터 모델 불일치\n- User 모델의 필드가 스키마와 다름\n- Restaurant 테이블의 위치 데이터 타입 불일치\n- Follow 관계의 인덱스 전략이 API 요구사항과 맞지 않음\n- Point/Tier 시스템의 계산 로직이 DB 구조를 반영하지 못함\n\n### API 설계의 일관성 부족\n- REST 규칙이 엔드포인트마다 다름\n- 응답 형식이 통일되지 않음\n- 에러 처리 방식이 제각각\n- 페이지네이션 전략이 불분명함\n\n### 문서와 코드의 괴리\n- 기획 문서에 명시된 요구사항이 코드에 누락됨\n- API 문서와 실제 구현이 다름\n- 엔티티 정의 문서가 실제 모델과 맞지 않음\n\n## 원인 분석\n\n**AI 세션마다 다른 컨텍스트**\n- Claude 세션이 바뀔 때마다 이전 결정사항을 잊어버림\n- 프로젝트 지식이나 MCP를 활용했지만 충분하지 않았음\n- 각 세션에서 \"그럴싸한\" 코드를 만들지만 전체 일관성은 없음\n\n**문서 작성 방법론의 문제**\n- 모든 문서를 한 번에 작성하려다 보니 검증이 부족함\n- 문서 간 의존성을 고려하지 않음\n- 핵심 기능 위주로만 작성하고 세부사항은 나중에 추가\n\n**내 역할의 한계**\n- 백엔드/Flutter 기술 지식이 없어 코드 리뷰가 피상적\n- \"동작하는 것처럼 보이면\" 넘어감\n- 통합 테스트 없이 진행\n\n## 고민과 결정\n\n**계속 수정할 것인가, 다시 시작할 것인가**\n\n며칠간 고민했다. 지금까지 몇 달간 작업한 코드를 버린다는 것은 쉽지 않은 결정이다. 하지만 계속 수정하다 보면 더 깊은 늪에 빠질 것 같았다.\n\n**배운 것들**\n- AI와 함께 개발할 때 문서의 일관성이 얼마나 중요한지\n- 순차적 작성과 교차 검증의 필요성\n- 백엔드부터 탄탄하게 만드는 것이 중요함\n- Phase별 개발보다 계층별 개발이 나을 수도 있음\n\n**새로운 방법론 구상**\n\n1. 기획서를 더 상세하게, 순서대로 읽도록 강제\n2. 엔티티 → ERD → 데이터모델 → API 순서를 엄격히 지킴\n3. 각 단계마다 교차 검증 수행\n4. 백엔드를 먼저 완전히 완성한 후 프론트엔드 시작\n5. SpecKit 같은 체계적인 프레임워크 활용 검토\n\n**일단 멈추기**\n\n성급하게 다시 시작하고 싶었다. 하지만 같은 실수를 반복하면 안 된다. 일단 멈추고 생각할 시간이 필요하다. 왜 일관성이 무너졌는지, AI와 어떻게 협업해야 하는지, 문서 작성 체계를 어떻게 바꿔야 하는지. 제대로 배우고 넘어가야 한다. 지금까지의 경험이 헛되지 않도록.",
      "description": "## 이번 주 요약\n\n지난주 Phase 3-4를 완료하고 API 구현을 시작했지만, 심각한 일관성 문제를 발견했다. 데이터베이스 스키마와 도메인 모델, API 정의가 서로 맞지 않았다. 몇 달간 개발해온 결과물이지만, 근본적인 문제가 있다는 것을 인정해야 했다.\n\n## 직면한 문제들\n\n",
      "tags": [
        "회고",
        "시스템설계",
        "AI개발"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-06-23.md"
    },
    {
      "slug": "fallingo-week-2025-07-14",
      "title": "Fallingo 개발일지 - 2025년 7월 2주차 (07.14 ~ 07.20)",
      "date": "2025-07-20T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n결정했다. 기획 문서를 제외한 모든 개발 문서와 소스코드를 삭제했다. 커밋: \"reset - del\", \"reset - docs\". 지난 몇 달간의 작업이 사라지는 것을 보는 것은 쉽지 않았지만, 올바른 방향으로 가기 위한 필수적인 선택이었다.\n\n## Reset의 순간\n\n### 삭제한 것들\n- Phase 1-4 전체 백엔드 코드\n- 데이터베이스 마이그레이션 스크립트\n- API 구현 코드\n- ERD 및 데이터 모델 문서\n- 엔티티 정의 문서\n- API 명세 문서\n- 비즈니스 로직 문서\n\n### 남긴 것들\n- 핵심 기획 문서\n- 요구사항 정의\n- 서비스 컨셉과 방향성\n- 그리고 지난 몇 달간의 경험과 교훈\n\n## 왜 Reset이 필요했는가\n\n**일관성은 타협할 수 없다**\n\n코드를 조금씩 수정해서 맞춰갈 수도 있었다. 하지만 그것은 근본적인 해결책이 아니었다. 데이터베이스 스키마부터 API까지 전체 아키텍처가 유기적으로 연결되어 있어야 하는데, 패치워크처럼 수정하다 보면 더 큰 문제가 생길 것이 분명했다.\n\n**AI와 함께하는 개발의 특수성**\n\n전통적인 개발에서는 개발자가 전체 맥락을 머릿속에 가지고 있다. 하지만 AI와 함께 개발할 때는 문서가 그 역할을 해야 한다. 문서의 일관성이 곧 코드의 일관성이다. 문서가 엉망이면 코드도 엉망일 수밖에 없다.\n\n**속도보다 방향**\n\n빨리 가는 것보다 올바른 방향으로 가는 것이 중요하다. 잘못된 방향으로 아무리 빨리 달려도 목적지에 도착할 수 없다. 지금 멈추고 방향을 바로잡는 것이 결국 더 빠른 길이다.\n\n## 새로운 방법론 정립\n\n### 문서 작성 원칙\n\n**1. 순서의 엄격한 준수**\n```\n기획서 → 엔티티 추출 → ERD 설계 → 데이터 모델 → API 정의 → 비즈니스 로직\n```\n각 단계는 이전 단계가 완전히 검증된 후에만 진행한다.\n\n**2. 교차 검증 프로세스**\n- 같은 문서를 3번 독립적으로 생성\n- 공통 내용과 차이점 분석\n- 차이가 발생한 이유 파악\n- 최종 문서는 검증된 내용만 포함\n\n**3. AI 지침 명확화**\n- \"기획서를 순차적으로 읽을 것\"\n- \"핵심 기능보다 전체 일관성 우선\"\n- \"새로운 기능 추가 금지, 요구사항만 구현\"\n- \"문서 번호 순서대로 처리\"\n\n### 개발 전략 변경\n\n**백엔드 우선 개발**\n- 프론트엔드와 동시 개발 중단\n- 백엔드를 먼저 완전히 완성\n- API가 탄탄해야 프론트엔드도 탄탄함\n\n**단계별 검증**\n- 각 계층마다 완성도 검증\n- 다음 단계로 넘어가기 전 통합 테스트\n- 문제 발견 시 즉시 이전 단계로 복귀\n\n## 배운 교훈\n\n### AI의 한계와 가능성\n\nAI는 놀라운 도구지만 만능이 아니다. 특히:\n- 컨텍스트가 바뀌면 일관성을 유지하기 어려움\n- 명시적으로 요구하지 않으면 자기 판단으로 기능 추가\n- 문서의 순서나 강조점에 따라 결과가 크게 달라짐\n\n하지만 올바른 방법론과 함께라면:\n- 내가 모르는 기술 스택으로도 개발 가능\n- 체계적인 문서를 기반으로 일관된 코드 생성 가능\n- 검증과 피드백 루프를 통해 품질 개선 가능\n\n### Reset의 용기\n\n무언가를 시작하는 것보다 버리는 것이 더 어렵다. 하지만:\n- 잘못된 것을 붙잡고 있는 것은 비용이다\n- 빨리 실패하고, 빨리 배우고, 빨리 수정해야 한다\n- 지금까지의 작업은 삭제되었지만, 경험과 교훈은 남는다\n\n### 방법론의 중요성\n\nAI-First 개발은 새로운 패러다임이다. 기존 개발 방식을 그대로 적용하면 안 된다:\n- 명확하고 체계적인 문서가 핵심\n- 순서와 일관성이 결과를 결정\n- 검증 프로세스가 필수\n\n**이번에는 다르다**\n\n다시 시작할 준비가 되었다. 기획 문서를 검토하고, 엔티티를 추출하고, ERD를 설계할 것이다. 하지만 이번에는 다르다. 순서를 지키고, 검증하고, AI에게 명확한 지침을 줄 것이다. 제대로, 천천히, 확실하게. Reset의 경험이 헛되지 않도록.",
      "description": "## 이번 주 요약\n\n결정했다. 기획 문서를 제외한 모든 개발 문서와 소스코드를 삭제했다. 커밋: \"reset - del\", \"reset - docs\". 지난 몇 달간의 작업이 사라지는 것을 보는 것은 쉽지 않았지만, 올바른 방향으로 가기 위한 필수적인 선택이었다.\n\n## Reset의 ",
      "tags": [
        "회고",
        "방법론",
        "AI개발",
        "리셋"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-07-14.md"
    },
    {
      "slug": "fallingo-week-2025-07-28",
      "title": "Fallingo 개발일지 - 2025년 7월 4주차 (07.28 ~ 08.03)",
      "date": "2025-08-03T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\nReset 이후 2주간 새로운 방법론을 정립하고 재시작을 준비했다. 기획 문서를 다시 검토하며 누락된 내용을 발견했고, SpecKit이라는 체계적인 프레임워크를 알게 되었다. 서두르지 않고 탄탄한 기반을 만드는 데 집중했다.\n\n## 주요 작업\n\n### 기획 문서 재검토\n\n**누락된 내용 발견**\n- 티어별 상호작용 반경의 구체적인 수치\n- 포인트 획득/차감 규칙의 세부 조건\n- 음식점 정보 수집 방식과 데이터 소스\n- 알림 시스템의 상세 요구사항\n- 관리자 기능 정의\n\n**개선한 내용**\n- 각 기능의 우선순위 명확화\n- 사용자 시나리오를 더 구체적으로 작성\n- 예외 상황과 엣지 케이스 추가\n- 성능 요구사항 정의\n\n### SpecKit 도입 검토\n\n**SpecKit이란**\n- AI-First 개발을 위한 체계적인 프레임워크\n- 스펙 → 플랜 → 태스크 → 구현의 명확한 흐름\n- 문서 간 일관성 유지를 위한 검증 도구\n- Constitution을 통한 프로젝트 원칙 정의\n\n**마이그레이션 계획**\n- 기존 기획 문서를 spec.md로 변환\n- 엔티티 추출을 plan.md로 체계화\n- 구현 작업을 tasks.md로 관리\n- Constitution에 개발 원칙과 규칙 정의\n\n**기대 효과**\n- 문서 간 의존성 관리 자동화\n- 일관성 검증 프로세스 내장\n- AI가 따라야 할 명확한 가이드라인\n- 작업 진행 상황 추적 용이\n\n### AI-First 개발 방법론 정리\n\n지난 몇 달간의 경험을 바탕으로 내가 찾은 방법론을 정리했다:\n\n**핵심 원칙**\n\n1. **문서가 곧 코드다**\n   - 문서의 품질이 코드의 품질을 결정\n   - 일관성 있는 문서 = 일관성 있는 코드\n   - AI는 문서를 읽고 코드를 작성\n\n2. **순서를 지켜라**\n   - 각 단계는 독립적이지 않고 연결됨\n   - 이전 단계의 산출물이 다음 단계의 입력\n   - 건너뛰거나 동시에 하면 불일치 발생\n\n3. **검증, 검증, 검증**\n   - 한 번의 작성으로 완벽할 수 없음\n   - 교차 검증을 통한 품질 확보\n   - 문제를 빨리 발견할수록 수정 비용 감소\n\n4. **AI를 의심하라**\n   - AI는 \"그럴싸한\" 것을 잘 만듦\n   - 하지만 그럴싸함과 정확함은 다름\n   - 요구하지 않은 기능 추가를 경계\n\n5. **백엔드부터 탄탄하게**\n   - 데이터 구조가 모든 것의 기반\n   - API가 확정되어야 프론트엔드 개발 가능\n   - 동시 개발은 불일치를 만듦\n\n**실천 방법**\n\n- 각 세션마다 Constitution과 이전 산출물 제공\n- \"기획서를 순서대로 읽을 것\" 명시\n- 새로운 기능 추가 금지, 문서에 있는 것만 구현\n- 각 단계 완료 후 품질 검증 요청\n- 차이점 발견 시 원인 분석 후 재작성\n\n### 개발 환경 재정비\n\n**도구 체계화**\n- Claude Projects: Constitution과 핵심 문서 등록\n- MCP (hi-ai): 프로젝트 문서 접근 자동화\n- Git: 단계별 커밋 전략 수립\n- 테스트 환경: 로컬 개발 환경 표준화\n\n**문서 구조 설계**\n```\n/docs\n  /specs\n    - constitution.md (프로젝트 원칙)\n    - spec.md (기능 명세)\n    - plan.md (구현 계획)\n    - tasks.md (작업 목록)\n  /technical\n    - entities.md (엔티티 정의)\n    - erd.md (ERD)\n    - data-models.md (데이터 모델)\n    - api.md (API 명세)\n    - business-logic.md (비즈니스 로직)\n```\n\n## 배운 점 / 고민\n\n**서두르지 않는 용기**\n\n이전에는 빨리 결과물을 보고 싶어서 서둘렀다. 문서 작성은 대충하고 개발부터 시작했다. 하지만 그 결과는 Reset이었다.\n\n이번에는 다르다. 2주 동안 한 줄의 코드도 작성하지 않았다. 하지만 이 2주가 앞으로 몇 달을 결정할 것이다. 탄탄한 기반 위에서 빠르게 갈 수 있다.\n\n**AI와 함께 성장하기**\n\nAI를 도구로만 생각했다. \"이걸 만들어줘\"라고 요구하면 만들어주는 도구. 하지만 AI와의 협업은 그보다 복잡하다.\n\n- 어떻게 물어봐야 원하는 답을 얻는지\n- 어떤 정보를 제공해야 일관성이 유지되는지\n- 어떤 지침을 주어야 실수를 방지할 수 있는지\n\n이런 것들을 배우는 과정이었다. AI-First 개발은 새로운 스킬셋이 필요한 새로운 패러다임이다.\n\n**실패는 학습이다**\n\nReset은 실패가 아니라 학습이었다. 지난 몇 달간:\n- AI의 한계와 가능성을 이해했다\n- 문서의 중요성을 체감했다\n- 올바른 프로세스를 찾았다\n- 버리는 용기를 배웠다\n\n이제 더 나은 방법으로 다시 시작할 준비가 되었다.\n\n**2주간 한 줄의 코드도 쓰지 않았다**\n\n2주 동안 한 줄의 코드도 작성하지 않았다. 기획 문서를 다시 검토하고, SpecKit을 공부하고, 방법론을 정리했다. 서두르지 않는 것이 용기라는 것을 배웠다. 이 2주가 앞으로 몇 달을 결정할 것이다. 탄탄한 기반 위에서 빠르게 갈 수 있다. 이번에는 다르다. 천천히, 확실하게, 올바르게.",
      "description": "## 이번 주 요약\n\nReset 이후 2주간 새로운 방법론을 정립하고 재시작을 준비했다. 기획 문서를 다시 검토하며 누락된 내용을 발견했고, SpecKit이라는 체계적인 프레임워크를 알게 되었다. 서두르지 않고 탄탄한 기반을 만드는 데 집중했다.\n\n## 주요 작업\n\n### 기획 문서 재",
      "tags": [
        "방법론",
        "문서화",
        "AI개발",
        "SpecKit"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-07-28.md"
    },
    {
      "slug": "fallingo-week-2025-08-04",
      "title": "Fallingo 개발일지 - 2025년 8월 1주차 (08.04 ~ 08.10)",
      "date": "2025-08-10T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n백엔드 Phase 1 구현을 완료하고, Flutter 프론트엔드 개발을 본격적으로 시작했다. GCP Load Balancer 경로 기반 라우팅을 설정하고, 프론트엔드-백엔드 통합 배포를 완료했다. 55개 커밋, 그중 26개가 버그 수정이었다. 배포는 역시 만만치 않았다.\n\n## 주요 작업\n\n### 프론트엔드 기반 구축\n- Flutter 웹 프로젝트 초기화\n- 주요 화면 구현 (Feed, AI 추천, 프로필)\n- Mock API를 활용한 UI 개발\n- Lint 에러 해결 (코드 품질 관리 시작)\n\n### GCP 배포 인프라\n- Load Balancer 경로 기반 라우팅 설정\n  - `/api/*` → 백엔드 Cloud Run\n  - `/*` → 프론트엔드 Cloud Run\n- 프로덕션 환경 변수 관리\n- GitHub Actions 테스트 워크플로우 구축\n\n### AI 추천 기능 추가\n- Mock AI 추천 API 구현\n- Tier 3 (갈비탕) 등급 제한 적용\n- 티어별 기능 접근 제어 로직\n\n### 데이터 & 메타데이터\n- 실제적인 샘플 데이터 추가\n- 파비콘 및 웹 메타데이터 개선\n- SEO 기본 설정\n\n## 배운 점\n\n**환경변수와의 싸움**\n\nFlutter 웹 빌드 시 환경변수 주입이 까다로웠다. `--dart-define`으로 빌드 타임에 주입해야 한다는 것을 알았지만, 프로덕션과 개발 환경을 분리하는 전략을 세우는 데 시간이 걸렸다. 로컬에서 잘 되던 것이 배포하면 안 되는 경험은 여전히 낯설다.\n\n**경로 라우팅의 복잡함**\n\nGCP Load Balancer로 `/api/*`는 백엔드로, `/*`는 프론트엔드로 라우팅하려고 했다. 생각보다 복잡했다. CORS 설정, preflight 요청 처리, URL 스키마 통일. 하나씩 해결하면서 배포 인프라의 복잡함을 체감했다.\n\n**버그 수정이 절반**\n\n55개 커밋 중 26개가 버그 수정이었다. 배포 환경에서만 발생하는 이슈들을 잡는 데 시간이 많이 걸렸다. 로컬과 프로덕션 환경의 차이를 최소화해야 한다는 것을 배웠다. 테스트 자동화의 필요성도 절실히 느꼈다.\n\n**Claude가 작성한 스크립트**\n\n배포 스크립트를 Claude와 함께 작성했다. GCP 설정 베스트 프랙티스를 빠르게 학습할 수 있었다. 하지만 최종 검증은 직접 해야 한다는 것을 잊지 않았다. AI는 훌륭한 조력자지만, 책임은 내가 진다.",
      "description": "## 이번 주 요약\n\n백엔드 Phase 1 구현을 완료하고, Flutter 프론트엔드 개발을 본격적으로 시작했다. GCP Load Balancer 경로 기반 라우팅을 설정하고, 프론트엔드-백엔드 통합 배포를 완료했다. 55개 커밋, 그중 26개가 버그 수정이었다. 배포는 역시 만만치 않",
      "tags": [
        "프론트엔드",
        "Flutter",
        "GCP",
        "배포"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-08-04.md"
    },
    {
      "slug": "fallingo-week-2025-08-11",
      "title": "Fallingo 개발일지 - 2025년 8월 2주차 (08.11 ~ 08.17)",
      "date": "2025-08-17T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n가장 많은 커밋(94개)과 가장 많은 버그 수정(47개)이 있었던 주. Identity Platform 인증 시스템을 구현하고, 백엔드 아키텍처를 전면 개선했다. Feed, Restaurant, User API를 모두 완성했다. Redis를 비활성화하고 비용 최적화도 진행했다.\n\n## 주요 작업\n\n### Identity Platform 인증 시스템\n- GCP Identity Platform 연동 완료\n- JWT 토큰 기반 인증 구현\n- OAuth 소셜 로그인 연동 (Google, Apple)\n- 인증 미들웨어 구현\n\n### 핵심 API 완성\n- **User API**: 회원가입, 프로필, 설정\n- **Feed API**: 피드 생성/조회/수정/삭제, 좋아요, 댓글\n- **Restaurant API**: 음식점 정보, 위치 기반 검색\n- FastAPI 자동 문서화 (Swagger UI)\n\n### 백엔드 아키텍처 개선\n- Cloud SQL Proxy 설정 최적화\n- 환경변수 관리 체계화\n- 데이터베이스 세션 관리 개선\n- Secret 관리 (JWT secret key)\n\n### 코드 품질 관리\n- .gitignore 통합 및 정리\n- 스크립트 폴더 구조화\n- pytest 설정 개선\n- 테스트 환경 설정\n\n## 배운 점\n\n**Identity Platform의 복잡함**\n\nIdentity Platform은 엔터프라이즈급 기능을 제공하지만, 초기 설정이 복잡했다. JWT 검증 로직을 직접 구현해야 했고, 토큰 갱신 전략도 고민해야 했다. Firebase Auth보다 강력하지만, 그만큼 배워야 할 것도 많았다.\n\n**Redis를 포기한 이유**\n\n캐싱을 위해 Redis를 고려했지만, GCP Memorystore는 최소 월 50달러였다. 초기에는 캐싱이 필요 없을 수도 있다는 판단이 들었다. PostgreSQL 쿼리 최적화만으로도 충분할 것 같았다. 필요하면 나중에 추가할 수 있다. 비용과 필요성 사이에서 균형을 찾았다.\n\n**47개의 버그**\n\n94개 커밋 중 47개가 버그 수정이었다. 패키지 의존성 문제, 환경변수 누락, import 이름 오류, pyproject.toml 중복 필드. 대부분이 통합 과정에서 발생했다. 각 기능은 잘 동작하는데, 합치면 문제가 생기는 경험. 통합의 어려움을 체감했다.\n\n**리팩토링의 타이밍**\n\n9개의 리팩토링 커밋이 있었다. 코드가 빠르게 복잡해지는 것을 느꼈다. 초기부터 구조를 잘 잡는 것이 중요하다는 것을 다시 배웠다. 리팩토링은 필요하지만, 처음부터 잘 설계하면 리팩토링을 줄일 수 있다.",
      "description": "## 이번 주 요약\n\n가장 많은 커밋(94개)과 가장 많은 버그 수정(47개)이 있었던 주. Identity Platform 인증 시스템을 구현하고, 백엔드 아키텍처를 전면 개선했다. Feed, Restaurant, User API를 모두 완성했다. Redis를 비활성화하고 비용 최적화",
      "tags": [
        "인증",
        "백엔드",
        "아키텍처",
        "GCP"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-08-11.md"
    },
    {
      "slug": "fallingo-week-2025-09-01",
      "title": "Fallingo 개발일지 - 2025년 9월 1주차 (09.01 ~ 09.07)",
      "date": "2025-09-07T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n서비스 출시를 위한 법적 기반과 수익 모델을 완성했다. 법적 문서 시스템, AdMob/AdSense 광고, 종합 보안 시스템을 구축했다. 그리고 핵심 차별화 기능인 티어별 상호작용 반경 시스템을 완성했다. 15개 커밋이지만 각각이 무거운 작업들이었다.\n\n## 주요 작업\n\n### 법적 문서 시스템\n- 이용약관, 개인정보처리방침 API\n- 다국어 지원 준비 (한국어/영어)\n- 버전 관리 시스템\n- 법적 동의 체크 로직\n\n### AdMob/AdSense 광고 시스템\n- 모바일: AdMob 연동\n- 웹: AdSense 연동\n- 피드 사이 광고 삽입 로직\n- 광고 수익 추적 준비\n\n### 종합 보안 시스템\n- CSRF 보호\n- Rate limiting\n- SQL Injection 방지\n- XSS 방지\n- CORS 설정 강화\n\n### 티어별 상호작용 반경 시스템\n- 티어에 따른 좋아요 반경 제한\n  - Tier 1: 제한 없음\n  - Tier 2: 500m\n  - Tier 3: 1km\n  - Tier 4+: 점진적 확대\n- PostGIS를 활용한 거리 계산\n- 중복 포인트 지급 방지 시스템\n\n### 포인트 정책 수정\n- 받는 행위에는 포인트 보상 유지\n- 게이미피케이션 밸런스 조정\n- 악용 방지 로직\n\n## 배운 점\n\n**서비스 출시의 조건들**\n\n법적 문서를 작성하면서 서비스 출시가 단순히 기능 구현만으로 끝나지 않는다는 것을 알았다. 이용약관, 개인정보처리방침. 변호사 검토는 나중에라도, 기본 틀은 필요했다. API로 제공하면 업데이트가 용이하다는 것도 배웠다.\n\n**광고와 UX 사이**\n\nAdMob과 AdSense를 동시에 연동했다. 모바일과 웹, 플랫폼마다 다른 SDK를 사용해야 했다. 광고 빈도 조절이 중요했다. 너무 자주 나오면 사용자가 떠나고, 너무 적으면 수익이 없다. 그 균형점을 찾아야 한다.\n\n**티어 시스템의 딜레마**\n\n티어별 상호작용 반경을 설계하면서 고민이 많았다. 너무 제한적이면 유저가 이탈할 것 같고, 너무 관대하면 게이미피케이션의 의미가 없다. 실제 데이터를 보고 조정해야 한다는 결론을 내렸다. 일단 만들고, 관찰하고, 개선하자.\n\n**PostGIS로 거리 재기**\n\n`ST_DWithin` 함수로 반경 내 음식점을 찾았다. GIST 인덱스로 최적화하고, meter 단위 변환에 주의했다. 공간 데이터를 다루는 법을 조금씩 익혀가고 있다.\n\n**중복 포인트의 함정**\n\n같은 행동에 여러 번 포인트를 지급하면 안 된다. 데이터베이스 unique constraint와 트랜잭션 처리로 방지했다. 게이미피케이션 시스템의 악용 가능성을 염두에 두고 설계해야 한다는 것을 배웠다.",
      "description": "## 이번 주 요약\n\n서비스 출시를 위한 법적 기반과 수익 모델을 완성했다. 법적 문서 시스템, AdMob/AdSense 광고, 종합 보안 시스템을 구축했다. 그리고 핵심 차별화 기능인 티어별 상호작용 반경 시스템을 완성했다. 15개 커밋이지만 각각이 무거운 작업들이었다.\n\n## 주요 ",
      "tags": [
        "법률",
        "광고",
        "보안",
        "포인트시스템"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-09-01.md"
    },
    {
      "slug": "fallingo-week-2025-09-08",
      "title": "Fallingo 개발일지 - 2025년 9월 2주차 (09.08 ~ 09.14)",
      "date": "2025-09-14T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n백엔드 프로덕션 배포와의 전쟁. Cloud Run 배포를 위한 포트 설정, 환경변수, 도메인 패턴 등 온갖 문제를 해결했다. 44개 커밋 중 21개가 fix였다. 하지만 최종적으로 백엔드 완성도를 높이고 Startup Application 통합을 완료했다.\n\n## 주요 작업\n\n### Cloud Run 배포 문제 해결\n- PORT 환경변수 충돌 문제\n- 컨테이너 시작 최적화\n- TrustedHost 미들웨어 설정\n- Cloud Run 도메인 패턴 추가\n\n### 백엔드 아키텍처 최적화\n- 5단계 Startup Application 통합\n- 6단계 기본 API 라우터 통합\n- GCP 기반 스케폴딩 완성\n- 프로덕션 준비 완료\n\n### 배포 안정성 개선\n- 헬스체크 엔드포인트 강화\n- 컨테이너 시작 시간 단축\n- 에러 로깅 개선\n- 모니터링 설정\n\n## 배운 점\n\n**PORT 환경변수의 비밀**\n\nCloud Run이 PORT 환경변수를 자동으로 주입한다는 것을 몰랐다. FastAPI는 기본 8000 포트를 사용하는데, Cloud Run은 다른 포트를 요구했다. 환경변수에서 PORT를 읽어오는 간단한 코드 한 줄로 해결했지만, 찾는 데 시간이 걸렸다.\n\n**TrustedHost와 보안 사이**\n\nCloud Run의 도메인 패턴은 복잡했다. `*.run.app`, `*.a.run.app` 등 여러 패턴. 와일드카드 설정이 필요했지만, 보안도 고려해야 했다. 편의성과 보안 사이에서 균형을 찾는 과정이었다.\n\n**로컬에서는 잘 되는데**\n\n로컬에서는 잘 되는데 배포하면 실패하는 경험. Cloud Run 로그를 확인하고, 환경변수 차이를 확인하고, 네트워크 설정을 확인했다. 44개 커밋 중 21개가 버그 수정이었다. 스테이징 환경의 필요성을 절실히 느꼈다.\n\n**라우터 통합의 완성**\n\nFastAPI의 모듈화 구조를 활용해 API 라우터를 통합했다. 각 도메인별로 라우터를 분리하니 코드가 깔끔해졌다. Startup Application 통합도 완료했다. 백엔드의 완성도가 높아지는 것을 느꼈다.",
      "description": "## 이번 주 요약\n\n백엔드 프로덕션 배포와의 전쟁. Cloud Run 배포를 위한 포트 설정, 환경변수, 도메인 패턴 등 온갖 문제를 해결했다. 44개 커밋 중 21개가 fix였다. 하지만 최종적으로 백엔드 완성도를 높이고 Startup Application 통합을 완료했다.\n\n## ",
      "tags": [
        "배포",
        "CloudRun",
        "DevOps",
        "최적화"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-09-08.md"
    },
    {
      "slug": "fallingo-week-2025-10-20",
      "title": "Fallingo 개발일지 - 2025년 10월 3주차 (10.20 ~ 10.26)",
      "date": "2025-10-26T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n가장 바쁜 주(92개 커밋). 프로덕션 배포 파이프라인을 완성하고, 법률 문서 다국어 API, Android 인증 설정을 마무리했다. Poetry에서 Docker로, GitHub Actions에서 Cloud Build로, 그리고 다시 Docker로. 시행착오가 많았지만 최종적으로 안정적인 배포 시스템을 구축했다.\n\n## 주요 작업\n\n### 프로덕션 Dockerfile 완성\n- Multi-stage build 적용\n- Poetry → Docker 직접 빌드로 변경\n- 이미지 크기 최적화\n- 빌드 시간 단축\n\n### 배포 워크플로우 개선\n- Cloud Build 시도 → Docker 직접 빌드로 회귀\n- GitHub Actions 최적화\n- 환경변수 관리 개선\n- 시크릿 관리 강화\n\n### 법률 문서 다국어 API\n- 이용약관, 개인정보처리방침\n- 한국어/영어 지원\n- 버전 관리 시스템\n- API 엔드포인트 완성\n\n### Android 인증 설정\n- Firebase Android SDK 연동\n- SHA-1 fingerprint 등록\n- Google Play 콘솔 설정\n- OAuth 클라이언트 ID 발급\n\n### 코드 품질 관리\n- spec-kit 도입\n- 17개 도메인 스펙 생성\n- 자동 문서 생성 시스템\n- NO TODO 정책 (완전한 스펙)\n\n### API 구조 개선\n- `/v1` 경로 제거 (단순화)\n- API_V1_PREFIX → API_PREFIX\n- Follow 서비스 Facade 패턴 적용 (999 → 208 lines)\n- 코드 가독성 향상\n\n### 테스트 데이터 시딩\n- 시딩 스크립트 추가\n- 개발/테스트 환경 데이터\n- 현실적인 샘플 데이터\n\n## 배운 점\n\n**Poetry를 포기한 날**\n\nPoetry는 로컬 개발에 좋았지만, Docker와 궁합이 안 좋았다. poetry.lock 관리 문제, 빌드 캐싱 비효율. 결국 requirements.txt로 돌아갔다. 새로운 도구가 항상 좋은 것은 아니다. 때로는 전통적인 방법이 더 안정적이다.\n\n**Cloud Build의 유혹과 포기**\n\nCloud Build는 GCP 네이티브라 좋아 보였다. 하지만 설정이 복잡하고 디버깅이 어려웠다. Docker 직접 빌드가 더 단순하고 안정적이었다. 화려한 것보다 단순한 것이 좋을 때가 있다.\n\n**Multi-stage build의 마법**\n\nMulti-stage build로 이미지 크기를 50% 줄였다. 빌드 도구는 제외하고, 런타임만 포함시켰다. 보안도 향상되었다. Dockerfile 몇 줄로 이런 효과를 낼 수 있다는 것이 신기했다.\n\n**999줄에서 208줄로**\n\nFollow 서비스를 Facade 패턴으로 리팩토링했다. 999줄이 208줄로, 79% 감소했다. 복잡한 로직을 서비스 레이어로 분리하니 API 레이어가 단순해졌다. 코드를 읽는 것이 편해졌다.\n\n**92개 커밋, 44개 버그**\n\n가장 바쁜 주였다. 92개 커밋 중 44개가 버그 수정이었다. Poetry.lock, Cloud Build, Dockerfile, 환경변수. 배포는 역시 어렵다. 하지만 하나씩 해결하며 안정적인 시스템을 만들어가고 있다.",
      "description": "## 이번 주 요약\n\n가장 바쁜 주(92개 커밋). 프로덕션 배포 파이프라인을 완성하고, 법률 문서 다국어 API, Android 인증 설정을 마무리했다. Poetry에서 Docker로, GitHub Actions에서 Cloud Build로, 그리고 다시 Docker로. 시행착오가 많았",
      "tags": [
        "배포",
        "Docker",
        "CI/CD",
        "문서화"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-10-20.md"
    },
    {
      "slug": "fallingo-week-2025-10-27",
      "title": "Fallingo 개발일지 - 2025년 10월 4주차 (10.27 ~ 11.02)",
      "date": "2025-11-02T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\n드디어 실제 Flutter UI를 프로덕션에 배포했다. Google Places API를 활용한 현실적인 테스트 데이터, SEO 최적화, 광고 시스템까지 완성했다. 54개 커밋, 그중 25개가 버그 수정. CORS, URL 경로, API 연동 등 프론트엔드-백엔드 통합의 어려움을 체감했다.\n\n## 주요 작업\n\n### Flutter UI 프로덕션 배포\n- 실제 UI를 Cloud Run에 배포\n- Fallingo 로고로 브랜딩 업데이트\n- 프로덕션 도메인 (fallingo.app) 연결\n- 프론트엔드 README 작성\n\n### 현실적인 테스트 데이터\n- Google Places API 연동\n- 실제 음식점 데이터 수집\n- 위치 기반 샘플 데이터\n- Admin API 시딩 엔드포인트 추가\n\n### SEO 최적화\n- robots.txt 추가\n- sitemap.xml 생성\n- meta tags 최적화\n- 검색 엔진 최적화\n\n### 광고 시스템 완성\n- 피드 사이 광고 삽입\n- 웹/모바일 모두 지원\n- AdMob/AdSense 준비 완료\n\n### 이메일 화이트리스트\n- 초기 테스터 관리\n- 특정 이메일만 가입 허용\n- 베타 테스트 준비\n\n### API URL 최종 정리\n- 프로덕션 도메인으로 통일\n- `/api` 경로 정리\n- CORS 설정 수정\n- Trailing slash 처리\n\n## 배운 점\n\n**CORS와의 끝없는 싸움**\n\nCORS는 언제나 까다롭다. 프로덕션 도메인, 와일드카드, Preflight 요청. 하나씩 추가하며 해결했지만, 여전히 예상치 못한 문제가 생긴다. 백엔드와 프론트엔드가 대화하려면 CORS를 넘어야 한다.\n\n**Trailing Slash의 함정**\n\nFastAPI는 `/feeds`와 `/feeds/`를 다르게 본다. 자동 리다이렉트가 CORS preflight와 충돌했다. 모든 1depth API는 slash 없이 통일하기로 했다. 작은 디테일이 큰 문제를 만든다.\n\n**/api/api/feeds의 실수**\n\n환경변수에 `/api`를 포함시켰는데, 클라이언트 코드에서 `/api/feeds`를 추가하며 `/api/api/feeds`가 되었다. 웃긴 실수지만 찾는 데 시간이 걸렸다. URL 경로 관리는 신중해야 한다.\n\n**Google Places로 현실감 더하기**\n\nGoogle Places API로 실제 음식점 데이터를 수집했다. 위치, 주소, 전화번호. 테스트 데이터가 현실적이니 개발하는 맛이 났다. 하지만 API 비용을 주의해야 한다.\n\n**54개 커밋, 25개 버그**\n\n드디어 Flutter UI를 프로덕션에 배포했다. 54개 커밋 중 25개가 버그 수정이었다. CORS, URL 경로, API 연동. 프론트엔드와 백엔드를 통합하는 것은 여전히 어렵다. 하지만 fallingo.app에 접속하면 실제 UI가 보인다.",
      "description": "## 이번 주 요약\n\n드디어 실제 Flutter UI를 프로덕션에 배포했다. Google Places API를 활용한 현실적인 테스트 데이터, SEO 최적화, 광고 시스템까지 완성했다. 54개 커밋, 그중 25개가 버그 수정. CORS, URL 경로, API 연동 등 프론트엔드-백엔드 ",
      "tags": [
        "Flutter",
        "프론트엔드",
        "SEO",
        "광고"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-10-27.md"
    },
    {
      "slug": "fallingo-week-2025-11-03",
      "title": "Fallingo 개발일지 - 2025년 11월 1주차 (11.03 ~ 11.09)",
      "date": "2025-11-09T00:00:00.000Z",
      "category": "dev-log",
      "content": "## 이번 주 요약\n\nBackgroundTasks 도입으로 API 응답속도 76% 개선 (2100ms → 500ms). Redis 캐싱으로 평균 응답 75% 개선 (800ms → 200ms). 프론트엔드 코드 품질 개선 45개 이슈 해결. 낙관적 업데이트 피드 등록 시스템 구현. Firebase API 키 보안 강화. 30개 커밋.\n\n## 주요 작업\n\n### 11.08: BackgroundTasks 도입 (응답속도 76% 개선)\n\n**문제**: 좋아요 API가 2100ms 걸렸다. FCM 알림 전송 때문이었다.\n\n**해결**: FastAPI BackgroundTasks로 비동기 처리\n\n```python\n@app.post(\"/feeds/{id}/like\")\nasync def like_feed(\n    feed_id: int,\n    background_tasks: BackgroundTasks  # FastAPI 자동 주입\n):\n    # 즉시 응답 (500ms)\n    background_tasks.add_task(process_like, feed_id, user_id)\n    return {\"status\": \"processing\"}\n\nasync def process_like(feed_id, user_id):\n    # 백그라운드 작업\n    await db.execute(\"INSERT INTO likes ...\")\n    await send_fcm_notification(...)\n    await invalidate_cache(...)\n```\n\n**결과**: 2100ms → 500ms (76% 개선)\n\n**확대 적용**: 팔로우 API, 피드 생성 API에도 적용\n\n### 11.08~11.09: Redis 캐싱 시스템 구축\n\n**GCP Memorystore Redis 설정**:\n- Tier: Basic (개발/테스트)\n- Capacity: 1GB\n- Region: asia-northeast3 (서울)\n- Version: Redis 7.0\n\n**캐싱 전략**:\n```python\n# 피드 목록 (TTL: 300초)\ncache_key = f\"feeds:list:{skip}:{limit}\"\ncached = await redis_client.get(cache_key)\nif cached:\n    return cached\n\n# 프로필 (TTL: 600초)\ncache_key = f\"user:profile:{user_id}\"\n\n# 통계 (TTL: 180초)\ncache_key = f\"feed:{feed_id}:stats\"\n```\n\n**문제 해결**:\n1. **Cloud Run Startup Timeout**: Redis 연결 타임아웃 5초 추가\n2. **의존성 누락**: `requirements.txt`에 `redis==5.0.1` 추가\n3. **직렬화 에러**: `json.dumps(value, default=str)` 로 datetime 처리\n4. **캐시 키 충돌**: 사용자별 캐시 키 분리\n\n**성능 측정**:\n| API | Before | After | 개선율 |\n|-----|--------|-------|--------|\n| GET /feeds | 800ms | 150ms | **81%** |\n| GET /users/{id} | 500ms | 100ms | **80%** |\n| POST /feeds/{id}/like | 2100ms | 500ms | **76%** |\n\n### 11.09: 낙관적 업데이트 피드 등록 시스템\n\n**문제**: 피드 생성 시 사용자가 기다려야 했음\n\n**해결**: 낙관적 업데이트 (Optimistic Update) 패턴\n\n```dart\n// 1. 즉시 UI 업데이트\nfinal tempFeed = Feed(id: 'temp_${DateTime.now()}', ...);\n_feeds.insert(0, tempFeed);\nnotifyListeners();\n\n// 2. 백그라운드 API 호출\ntry {\n  final realFeed = await apiService.createFeed(...);\n  // 성공 시 temp를 real로 교체\n} catch (e) {\n  // 실패 시 롤백\n  _feeds.removeWhere((f) => f.id == tempFeed.id);\n}\n```\n\n**효과**: 사용자는 즉시 피드를 보고, 백그라운드에서 처리됨\n\n### 11.09: 프론트엔드 코드 품질 개선 (45개 이슈)\n\n**Phase 1: 높은 우선순위 (15개)**\n- Deprecated API 5개 업데이트\n- Unused import 8개 제거\n- 변수명 컨벤션 2개 수정\n\n**Phase 2: Black 포맷팅 (30개)**\n- Python 백엔드 코드 Black 포맷팅 적용\n- 인코딩 수정 (`# -*- coding: utf-8 -*-`)\n- EOF 개행 추가\n\n**검색 화면 빌드 에러 수정**:\n```dart\n// Before\nfinal results = await searchService.search(query);\nreturn results;  // Type mismatch\n\n// After\nfinal results = await searchService.search(query);\nreturn results.cast<Restaurant>();\n```\n\n**결과**: Lint 에러 45개 → 0개\n\n### 11.09: Firebase API 키 보안 강화\n\n**문제**: `GoogleService-Info.plist` 파일이 GitHub에 노출됨\n\n**해결**:\n1. 노출된 파일 히스토리에서 완전 제거\n2. `.gitignore`에 Firebase 설정 파일 추가\n3. 환경 변수로 관리하도록 변경\n\n```gitignore\n# Firebase\nios/Runner/GoogleService-Info.plist\nandroid/app/google-services.json\n```\n\n### 11.09: Frontend 남은 작업 명세서 작성\n\n**문서화**: `docs/frontend/REMAINING_TASKS.md` 작성\n\n**남은 작업 8가지**:\n1. 카메라 화면 구현\n2. 지도 화면 구현 (지도 마커 → 바텀시트 피드 리스트)\n3. 피드 작성 화면 구현\n4. 알림 화면 구현\n5. API 연동 테스트 (8개 화면)\n6. FCM 푸시 알림 구현\n7. 코드 품질 개선 (45개 이슈 해결 완료)\n8. E2E 테스트 시나리오\n\n**명확화**: 레스토랑 상세 화면은 없음. 지도 마커 클릭 시 바텀시트에서 피드 리스트만 표시.\n\n### 기타 작업\n\n**Pre-commit Hooks 설정**:\n- `no-commit-to-branch` 훅 제거 (워크플로우 간소화)\n- Black 포맷터 자동 실행\n- Lint 자동 검사\n\n**백엔드 코드 품질**:\n- `follow_action_service.py` → `follow_service.py` 이름 변경\n- 심각한 에러 4개 수정\n- 소스코드 품질 분석 리포트 작성\n\n## 배운 점\n\n**2100ms에서 500ms로 - BackgroundTasks의 마법**\n\n좋아요 API가 2100ms 걸렸다. FCM 알림을 동기로 보내고 있었기 때문이다.\n\nBackgroundTasks를 도입했다. 즉시 응답하고, 알림은 백그라운드에서 보냈다. 2100ms → 500ms. 76% 개선.\n\n사용자는 기다리지 않는다. 시스템은 조용히 일한다. 비동기 작업의 힘을 체감했다.\n\n**800ms에서 150ms로 - Redis 캐싱**\n\n피드 목록 API가 800ms 걸렸다. N+1 쿼리 문제였다.\n\nRedis 캐싱을 도입했다. 피드 목록 300초, 프로필 600초, 통계 180초. TTL로 신선도를 조절했다.\n\n800ms → 150ms. 81% 개선. 캐시 히트율 82%.\n\n숫자로 증명되는 성능 개선. 사용자는 느낄 수 있을까.\n\n**낙관적 업데이트 - 즉각적인 피드백**\n\n피드를 생성하면 사용자는 기다렸다. API 응답을 기다리는 동안 아무것도 할 수 없었다.\n\n낙관적 업데이트를 적용했다. 즉시 UI를 업데이트하고, 백그라운드에서 API를 호출한다. 실패하면 롤백한다.\n\n사용자는 즉시 자신의 피드를 본다. 기다림이 사라졌다.\n\n**45개 이슈를 0개로 - 코드 품질**\n\nLint 에러 45개. Deprecated API, unused import, 포맷팅 불일치.\n\nPhase 1로 높은 우선순위 15개를 해결했다. Phase 2로 Black 포맷팅을 적용해 30개를 정리했다.\n\n45개 → 0개. Pre-commit hooks로 재발을 방지했다. 코드가 깨끗해졌다.\n\n**보안 - Firebase API 키 노출 사건**\n\nGoogleService-Info.plist가 GitHub에 노출되었다. Firebase API 키가 포함된 파일이었다.\n\n즉시 히스토리에서 제거하고 .gitignore에 추가했다. 환경 변수로 관리하도록 변경했다.\n\n실수는 배움의 기회다. 보안은 한 번의 실수로 무너진다.\n\n**문서화 - 남은 작업 명확화**\n\n프론트엔드 남은 작업이 막연했다. \"거의 다 됐다\"는 정확한 표현이 아니다.\n\nREMAINING_TASKS.md를 작성했다. 남은 작업 8가지, 각 화면별 상세 설명, 4주 개발 로드맵.\n\n명확해졌다. 얼마나 남았는지 알 수 있다. 문서는 팀의 언어다.\n\n**30개 커밋**\n\n11월 1주차. BackgroundTasks, Redis, 낙관적 업데이트, 코드 품질, 보안, 문서화.\n\n30개 커밋으로 성능과 품질을 동시에 잡았다.\n\nFallingo가 더 빨라지고, 더 깨끗해졌다.",
      "description": "## 이번 주 요약\n\nBackgroundTasks 도입으로 API 응답속도 76% 개선 (2100ms → 500ms). Redis 캐싱으로 평균 응답 75% 개선 (800ms → 200ms). 프론트엔드 코드 품질 개선 45개 이슈 해결. 낙관적 업데이트 피드 등록 시스템 구현. Fir",
      "tags": [
        "프론트엔드",
        "GoogleMaps",
        "OCR",
        "최적화"
      ],
      "image": null,
      "author": null,
      "lang": "ko",
      "filePath": "/posts/fallingo-week-2025-11-03.md"
    },
    {
      "slug": "tech-01-hi-ai-mcp",
      "title": "hi-ai MCP: 개발자를 위한 34개 도구의 똑똑한 AI 비서",
      "date": "2024-06-01T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP: 개발자를 위한 34개 도구의 똑똑한 AI 비서\n\nAI와 코딩하다 보면 반복되는 패턴이 있어.\n\n\"이 코드 품질 어떤데?\", \"이 함수 의미 분석해줘\", \"UI 미리보기 좀 보여줘\"\n\n매번 긴 프롬프트 작성하기 귀찮잖아. 그래서 만든 게 **hi-ai MCP**야.\n\n## WHAT: hi-ai MCP가 뭔데?\n\nModel Context Protocol(MCP) 1.0 표준을 구현한 TypeScript 기반 개발 도구 세트. Claude 같은 AI 에이전트가 실제 개발 작업에 사용할 수 있는 **34개의 전문화된 도구 모음**이야.\n\n### 핵심 특징\n\n**1. 키워드 기반 자연어 인식**\n\n한국어와 영어 키워드만 입력하면 알아서 적절한 도구를 실행해:\n\n```\n\"코드 품질 평가해줘\" → 자동으로 code quality evaluation 도구 실행\n\"메모리 저장\" → memory management 도구 활성화\n\"UI 미리보기\" → ASCII art preview 시스템 작동\n```\n\n**2. 34개 전문화 도구**\n\n- **시맨틱 코드 분석**: 단순 문법 검사를 넘어 코드의 의미와 맥락 파악\n- **지능형 메모리 관리**: 컨텍스트 유지하며 대화 이력 관리\n- **코드 품질 평가**: 실시간 코드 리뷰와 개선 제안\n- **프롬프트 엔지니어링**: 효과적인 AI 프롬프트 자동 생성\n- **UI 미리보기 시스템**: ASCII 아트로 레이아웃 시각화\n\n**3. 성능에 진심**\n\n```\n평균 응답 시간: <100ms\n메모리 사용량: <50MB\n동시 세션: 무제한\n```\n\n가볍고 빠르게. 개발 흐름을 끊지 않는 게 철학이야.\n\n## WHY: 왜 필요한가?\n\n### 문제 상황\n\nAI와 코딩할 때 이런 경험 있지?\n\n1. **매번 긴 프롬프트 작성**: \"이 코드의 품질을 분석하고, 개선점을 제안하고, 성능 이슈를 찾고...\"\n2. **컨텍스트 손실**: 대화가 길어지면 AI가 이전 내용을 까먹음\n3. **일관성 없는 응답**: 같은 질문에도 매번 다른 대답\n4. **도구 통합의 어려움**: 여러 개발 도구를 AI와 연결하기 복잡함\n\n### hi-ai의 해결법\n\n**키워드 기반 의도 인식**으로 복잡한 프롬프트를 단순화했어. AI가 개발자의 의도를 정확히 파악하고 적절한 도구를 자동 선택하는 거지.\n\n**모듈화된 아키텍처**로 각 도구가 독립적으로 작동하면서도 서로 협력해. 메모리 관리 시스템이 컨텍스트를 유지하고, 코드 분석 도구가 일관된 평가 기준을 제공하니까.\n\n## HOW: 어떻게 사용하나?\n\n### 설치\n\n**방법 1: Smithery 플랫폼 (추천)**\n\n가장 쉬운 방법이야. MCP 호환 에디터에서 바로 설치 가능:\n\n```\nhttps://smithery.ai/server/@su-record/hi-ai\n```\n\n**방법 2: NPM 패키지**\n\n```bash\n# 전역 설치\nnpm install -g @su-record/hi-ai\n\n# 프로젝트 로컬 설치\nnpm install @su-record/hi-ai\n```\n\n### 시스템 요구사항\n\n```\nNode.js 18.0+\nTypeScript 5.0+\nMCP 호환 에디터 (Claude Desktop, Cursor 등)\n```\n\n### 실제 사용 예시\n\n#### 1. 코드 품질 평가\n\n```typescript\n// AI에게 이렇게 물어봐\n\"이 함수 코드 품질 어때?\"\n\n// hi-ai가 자동으로 분석 도구 실행:\n// - 복잡도 계산\n// - 네이밍 규칙 검사\n// - 성능 병목 지점 파악\n// - 개선 제안 제공\n```\n\n**실제 케이스:**\n\n```javascript\nfunction processData(data) {\n  let result = [];\n  for(let i = 0; i < data.length; i++) {\n    if(data[i].active) {\n      result.push({\n        id: data[i].id,\n        name: data[i].name,\n        value: data[i].value * 2\n      });\n    }\n  }\n  return result;\n}\n```\n\nAI가 hi-ai MCP로 분석한 결과:\n\n```\n품질 점수: 6.5/10\n\n개선 포인트:\n1. 함수형 프로그래밍 활용 (filter + map)\n2. 매직 넘버 제거 (2를 상수로)\n3. 타입 안정성 추가\n\n개선된 코드:\nconst MULTIPLIER = 2;\n\nfunction processData(data: DataItem[]): ProcessedItem[] {\n  return data\n    .filter(item => item.active)\n    .map(({ id, name, value }) => ({\n      id,\n      name,\n      value: value * MULTIPLIER\n    }));\n}\n```\n\n#### 2. 시맨틱 코드 분석\n\n```typescript\n// 단순 문법이 아니라 '의미'를 파악해\n\n\"이 컴포넌트의 역할이 뭐야?\"\n\n// hi-ai 분석:\n// - 컴포넌트의 책임 범위\n// - 다른 모듈과의 관계\n// - 잠재적 리팩토링 포인트\n```\n\n**예시: React 컴포넌트**\n\n```jsx\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [posts, setPosts] = useState([]);\n  const [comments, setComments] = useState([]);\n\n  useEffect(() => {\n    fetch(`/api/users/${userId}`).then(r => r.json()).then(setUser);\n    fetch(`/api/users/${userId}/posts`).then(r => r.json()).then(setPosts);\n    fetch(`/api/users/${userId}/comments`).then(r => r.json()).then(setComments);\n  }, [userId]);\n\n  return (/* 복잡한 UI */);\n}\n```\n\nhi-ai의 시맨틱 분석:\n\n```\n역할 분석:\n- 주 책임: 사용자 프로필 데이터 표시\n- 부 책임: 게시글, 댓글 데이터 페칭 (SRP 위반)\n\n문제점:\n1. 너무 많은 책임 (데이터 페칭 + UI 렌더링)\n2. 3개의 독립적 API 호출 (병렬 처리 가능)\n3. 로딩/에러 상태 미처리\n\n제안:\n- Custom Hook 분리 (useUserData)\n- React Query/SWR 도입\n- Suspense 경계 추가\n```\n\n#### 3. UI 미리보기 (ASCII Art)\n\n```typescript\n\"이 레이아웃 미리보기 보여줘\"\n\n// hi-ai가 ASCII 아트로 시각화:\n\n┌─────────────────────────────────────┐\n│            Header                   │\n├──────────┬──────────────────────────┤\n│          │                          │\n│ Sidebar  │   Main Content Area      │\n│          │                          │\n│          │                          │\n├──────────┴──────────────────────────┤\n│            Footer                   │\n└─────────────────────────────────────┘\n```\n\n터미널에서 바로 레이아웃 확인 가능. 디자이너와 소통할 때 진짜 편해.\n\n#### 4. 지능형 메모리 관리\n\n```typescript\n// 대화 컨텍스트 자동 저장\n\nSession 1:\n\"이 프로젝트는 FastAPI 백엔드를 사용해\"\n→ hi-ai가 메모리에 저장\n\nSession 2 (30분 후):\n\"API 라우터 추가해줘\"\n→ hi-ai가 자동으로 FastAPI 문법 적용\n```\n\n매번 기술 스택을 다시 설명할 필요 없어. 컨텍스트를 기억하고 있으니까.\n\n### 통합 워크플로우\n\n실제 개발에서는 이렇게 쓰고 있어:\n\n```\n1. 프로젝트 시작 시\n   → \"프로젝트 구조 분석해줘\" (semantic analysis)\n\n2. 코드 작성 중\n   → \"이 로직 품질 체크\" (quality evaluation)\n\n3. 리팩토링 전\n   → \"개선 포인트 찾아줘\" (code analysis)\n\n4. UI 작업 시\n   → \"레이아웃 미리보기\" (ASCII preview)\n\n5. 프롬프트 최적화\n   → \"이 작업에 맞는 프롬프트 생성\" (prompt engineering)\n```\n\n## 기술적 특징\n\n### MCP 1.0 표준 구현\n\nModel Context Protocol은 AI 에이전트와 외부 도구를 연결하는 표준 인터페이스야. hi-ai는 이 표준을 완전히 따르기 때문에:\n\n- Claude Desktop과 즉시 통합\n- Cursor, Windsurf 등 MCP 지원 에디터에서 작동\n- 다른 MCP 도구와 조합 사용 가능\n\n### TypeScript 기반 아키텍처\n\n```typescript\n// 타입 안정성 + 확장성\ninterface ToolExecutor {\n  name: string;\n  execute(params: ToolParams): Promise<ToolResult>;\n  validate(params: ToolParams): boolean;\n}\n\n// 모듈화된 도구 시스템\nclass CodeQualityTool implements ToolExecutor {\n  async execute(params) {\n    // 코드 품질 분석 로직\n  }\n}\n```\n\n각 도구가 독립적으로 작동하면서도 일관된 인터페이스 유지. 새 도구 추가도 쉽고.\n\n### 로컬 실행, 프라이버시 보장\n\n모든 처리가 로컬에서 실행돼. 네트워크 왕복 없이 즉각 반응하고, 코드가 외부로 나가지 않아 보안도 안심.\n\n## 실전 활용 팁\n\n### 1. 키워드 조합으로 더 정교하게\n\n```\n\"코드 품질 + 성능\" → 품질과 성능을 동시에 분석\n\"UI 미리보기 + 반응형\" → 반응형 레이아웃 시각화\n\"메모리 저장 + 프로젝트 설정\" → 프로젝트 컨텍스트 영구 저장\n```\n\n### 2. 프롬프트 엔지니어링 활용\n\n복잡한 작업은 hi-ai에게 프롬프트 생성을 맡겨:\n\n```\n\"REST API를 GraphQL로 마이그레이션하는 작업에 맞는 프롬프트 만들어줘\"\n\n→ hi-ai가 최적화된 프롬프트 제공:\n  1. 현재 API 스키마 분석\n  2. GraphQL 스키마 설계\n  3. Resolver 구현\n  4. 테스트 케이스 작성\n  5. 마이그레이션 검증\n```\n\n### 3. 팀 협업에서 활용\n\n일관된 코드 품질 기준을 팀 전체가 공유할 수 있어:\n\n```\n팀 규칙 설정 → hi-ai 메모리에 저장\n모든 팀원이 같은 기준으로 코드 리뷰 받음\n일관성 있는 코드베이스 유지\n```\n\n## 한계와 고려사항\n\n솔직히 말하면 완벽하진 않아.\n\n**1. 학습 곡선**\n\n처음엔 어떤 키워드가 어떤 도구를 실행하는지 익숙해지는 시간이 필요해. 하지만 몇 번 써보면 자연스럽게 체득돼.\n\n**2. MCP 호환 환경 필요**\n\nClaude Desktop, Cursor 같은 MCP 지원 도구가 필요해. 기존 에디터에 바로 통합은 안 돼.\n\n**3. 언어 제한**\n\n현재는 한국어와 영어만 지원. 다른 언어는 추가 개발 필요.\n\n## hi-ai의 차별점\n\n**키워드 기반 자연어 인터페이스**\n다른 MCP 도구들은 정확한 명령어를 요구해. hi-ai는 자연어로 의도만 전달하면 알아서 실행.\n\n**개발 워크플로우 완전 커버**\n코드 작성부터 리뷰, 리팩토링까지 34개 도구로 전 과정 지원.\n\n**성능 최적화**\n100ms 이하 응답, 50MB 이하 메모리. 개발 흐름을 방해하지 않아.\n\n**오픈소스 + MIT 라이선스**\n자유롭게 사용, 수정, 배포 가능. 커뮤니티 기여 환영.\n\n## 시작해보자\n\nGitHub: https://github.com/su-record/hi-ai\n\n가장 빠른 시작:\n\n```bash\n# 1. 설치\nnpm install -g @su-record/hi-ai\n\n# 2. MCP 호환 에디터에서 설정\n# (Claude Desktop의 경우 자동 인식)\n\n# 3. 바로 사용\n\"코드 품질 체크해줘\"\n```\n\n## 핵심 정리\n\nAI와 코딩하는 시대에 필요한 건 **더 긴 프롬프트가 아니라 더 똑똑한 도구**.\n\nhi-ai MCP의 가치:\n- **키워드 하나로 작동**: \"코드 품질\" → 즉시 분석 실행\n- **34개 전문 도구**: 코드 작성부터 리팩토링까지 완전 커버\n- **100ms 응답, 50MB 메모리**: 개발 흐름 방해 없음\n- **MCP 1.0 표준**: Claude Desktop, Cursor 등 즉시 통합\n\n실제로 Fallingo 개발하면서 이런 도구의 필요성을 절실히 느꼈어. AI와 대화하듯 개발하는 시대, 이제 시작이야.\n\n---\n\n**참고 링크:**\n- GitHub: https://github.com/su-record/hi-ai\n- Smithery: https://smithery.ai/server/@su-record/hi-ai\n- MCP Specification: https://modelcontextprotocol.io",
      "description": "키워드 기반 자연어로 작동하는 MCP 1.0 표준 개발 도구 - 100ms 이하 응답, 50MB 이하 메모리",
      "tags": [
        "mcp",
        "ai-tools",
        "typescript",
        "developer-tools",
        "hi-ai"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/tech-01-hi-ai-mcp.md"
    },
    {
      "slug": "tech-hi-ai-v1.0.4-6",
      "title": "hi-ai MCP v1.0.4-6: AST 기반 코드 분석과 자연어 실행 시스템 도입",
      "date": "2024-07-08T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP v1.0.4-6: AST 기반 코드 분석과 자연어 실행 시스템 도입\n\n## 릴리즈 개요\n\nhi-ai MCP v1.0.4-6 릴리즈는 2024년 7월 8일부터 10일까지 3일간 연속으로 배포된 버전입니다. 이번 릴리즈의 핵심은 **AST(Abstract Syntax Tree) 기반 코드 분석 시스템 도입**과 **자연어 기반 도구 실행 메커니즘 구현**입니다.\n\n### 주요 변경사항\n\n**v1.0.4 (2024-07-08)**\n- `ts-morph` 라이브러리 의존성 추가\n- AST 기반 코드 분석 엔진 구현\n- `analyze_complexity` 도구 추가\n\n**v1.0.5 (2024-07-09)**\n- 프롬프트 최적화 도구 세트 구현\n- 도구 실행 성능 개선 (평균 응답시간 150ms → 100ms)\n- 메모리 사용량 최적화 (65MB → 50MB)\n\n**v1.0.6 (2024-07-10)**\n- 자연어 실행 시스템 완성\n- 다국어(한국어/영어) 키워드 지원\n- 총 31개 도구로 확장\n\n## 주요 변경사항\n\n### 1. AST 기반 코드 분석 시스템\n\n기존의 정규표현식 기반 코드 분석을 AST(Abstract Syntax Tree) 기반으로 전환했습니다.\n\n#### 기술적 배경\n\n정규표현식 기반 분석의 한계:\n\n```typescript\n// 기존 방식: 정규표현식으로 함수 찾기\nconst functionPattern = /function\\s+(\\w+)\\s*\\(/g;\nconst matches = code.match(functionPattern);\n// 문제점:\n// - 화살표 함수 미지원\n// - 메서드 선언 미지원\n// - 복잡한 제네릭 타입 파싱 불가\n// - 함수 내부 구조 분석 불가\n```\n\nAST 기반 분석의 장점:\n\n```typescript\n// 새로운 방식: ts-morph로 AST 분석\nimport { Project, SyntaxKind } from \"ts-morph\";\n\nconst project = new Project();\nconst sourceFile = project.createSourceFile(\"temp.ts\", code);\n\n// 모든 함수 선언 찾기 (함수, 화살표, 메서드 모두 포함)\nconst functions = sourceFile.getFunctions();\nconst arrowFunctions = sourceFile.getDescendantsOfKind(SyntaxKind.ArrowFunction);\nconst methods = sourceFile.getClasses()\n  .flatMap(c => c.getMethods());\n\n// 정확한 구조 분석\nfunctions.forEach(func => {\n  const name = func.getName();\n  const params = func.getParameters();\n  const returnType = func.getReturnType();\n  const body = func.getBody();\n  const complexity = calculateCyclomaticComplexity(body);\n});\n```\n\n#### analyze_complexity 도구\n\n코드의 순환 복잡도(Cyclomatic Complexity)를 정확하게 계산합니다.\n\n**순환 복잡도 계산 알고리즘:**\n\n```typescript\nfunction calculateCyclomaticComplexity(node: Node): number {\n  let complexity = 1; // 기본 경로\n\n  node.forEachDescendant((child) => {\n    const kind = child.getKind();\n\n    // 분기점마다 +1\n    switch (kind) {\n      case SyntaxKind.IfStatement:\n      case SyntaxKind.ForStatement:\n      case SyntaxKind.ForInStatement:\n      case SyntaxKind.ForOfStatement:\n      case SyntaxKind.WhileStatement:\n      case SyntaxKind.DoStatement:\n      case SyntaxKind.CaseClause:\n      case SyntaxKind.CatchClause:\n      case SyntaxKind.ConditionalExpression: // 삼항 연산자\n      case SyntaxKind.BinaryExpression: // && || 연산자\n        complexity++;\n        break;\n    }\n  });\n\n  return complexity;\n}\n```\n\n**복잡도 등급 분류:**\n\n```typescript\ninterface ComplexityResult {\n  score: number;\n  level: \"low\" | \"moderate\" | \"high\" | \"very_high\" | \"extreme\";\n  recommendation: string;\n}\n\nfunction analyzeComplexity(code: string): ComplexityResult {\n  const complexity = calculateCyclomaticComplexity(code);\n\n  if (complexity <= 5) {\n    return {\n      score: complexity,\n      level: \"low\",\n      recommendation: \"코드가 단순하고 이해하기 쉽습니다.\"\n    };\n  } else if (complexity <= 10) {\n    return {\n      score: complexity,\n      level: \"moderate\",\n      recommendation: \"적절한 복잡도입니다. 유지 관리가 가능합니다.\"\n    };\n  } else if (complexity <= 20) {\n    return {\n      score: complexity,\n      level: \"high\",\n      recommendation: \"복잡도가 높습니다. 함수 분리를 고려하세요.\"\n    };\n  } else if (complexity <= 50) {\n    return {\n      score: complexity,\n      level: \"very_high\",\n      recommendation: \"복잡도가 매우 높습니다. 즉시 리팩토링이 필요합니다.\"\n    };\n  } else {\n    return {\n      score: complexity,\n      level: \"extreme\",\n      recommendation: \"복잡도가 극도로 높습니다. 완전한 재설계가 필요합니다.\"\n    };\n  }\n}\n```\n\n### 2. 프롬프트 최적화 도구\n\nAI와의 효과적인 상호작용을 위한 프롬프트 엔지니어링 도구를 추가했습니다.\n\n#### enhance_prompt 도구\n\n사용자의 간단한 요청을 구조화된 프롬프트로 변환합니다.\n\n```typescript\ninterface PromptTemplate {\n  context: string;\n  task: string;\n  constraints: string[];\n  format: string;\n  examples?: string[];\n}\n\nfunction enhancePrompt(userInput: string): string {\n  const template = analyzeIntent(userInput);\n\n  return `\n## Context\n${template.context}\n\n## Task\n${template.task}\n\n## Constraints\n${template.constraints.map((c, i) => `${i + 1}. ${c}`).join('\\n')}\n\n## Expected Format\n${template.format}\n\n${template.examples ? `\n## Examples\n${template.examples.map((ex, i) => `Example ${i + 1}:\\n${ex}`).join('\\n\\n')}\n` : ''}\n  `.trim();\n}\n```\n\n**실제 사용 예시:**\n\n```typescript\n// 사용자 입력\n\"이 코드를 리팩토링해줘\"\n\n// enhance_prompt 출력\n/*\n## Context\nTypeScript 코드베이스에서 유지보수성과 가독성을 개선하기 위한 리팩토링 작업입니다.\n\n## Task\n제공된 코드를 분석하고 다음 원칙에 따라 리팩토링하세요:\n- SOLID 원칙 적용\n- DRY (Don't Repeat Yourself) 원칙\n- 명확한 네이밍\n- 적절한 추상화 레벨\n\n## Constraints\n1. 기존 기능을 변경하지 마세요\n2. TypeScript 타입 안정성을 유지하세요\n3. 테스트 가능한 코드 구조를 만드세요\n4. 성능 저하가 없어야 합니다\n\n## Expected Format\n- 리팩토링 전후 코드 비교\n- 변경 사유 설명\n- 개선된 점 요약\n*/\n```\n\n#### generate_test_prompt 도구\n\n테스트 케이스 작성을 위한 프롬프트를 자동 생성합니다.\n\n```typescript\nfunction generateTestPrompt(code: string, framework: string = \"jest\"): string {\n  const functions = extractFunctions(code);\n  const testCases = functions.map(func => {\n    return {\n      name: func.name,\n      scenarios: [\n        \"정상 케이스 (happy path)\",\n        \"경계 값 테스트 (edge cases)\",\n        \"에러 케이스 (error cases)\",\n        \"비동기 동작 테스트 (async behavior)\"\n      ],\n      assertions: inferAssertions(func)\n    };\n  });\n\n  return formatTestPrompt(testCases, framework);\n}\n```\n\n### 3. 자연어 실행 시스템\n\n키워드 기반으로 도구를 자동 선택하고 실행하는 시스템을 구현했습니다.\n\n#### 키워드 매핑 시스템\n\n```typescript\ninterface KeywordMapping {\n  keywords: string[];\n  tool: string;\n  priority: number;\n}\n\nconst keywordMappings: KeywordMapping[] = [\n  // 코드 분석\n  {\n    keywords: [\"복잡도\", \"complexity\", \"순환\", \"cyclomatic\"],\n    tool: \"analyze_complexity\",\n    priority: 10\n  },\n  {\n    keywords: [\"품질\", \"quality\", \"평가\", \"evaluate\", \"점수\", \"score\"],\n    tool: \"evaluate_code_quality\",\n    priority: 9\n  },\n\n  // 프롬프트 최적화\n  {\n    keywords: [\"프롬프트\", \"prompt\", \"최적화\", \"enhance\", \"개선\", \"improve\"],\n    tool: \"enhance_prompt\",\n    priority: 8\n  },\n  {\n    keywords: [\"테스트\", \"test\", \"테스팅\", \"testing\", \"검증\", \"verify\"],\n    tool: \"generate_test_prompt\",\n    priority: 8\n  },\n\n  // 메모리 관리\n  {\n    keywords: [\"저장\", \"save\", \"기억\", \"remember\", \"메모리\", \"memory\"],\n    tool: \"save_context\",\n    priority: 7\n  },\n  {\n    keywords: [\"불러오기\", \"load\", \"회상\", \"recall\", \"검색\", \"retrieve\"],\n    tool: \"load_context\",\n    priority: 7\n  }\n];\n```\n\n#### 의도 분석 엔진\n\n```typescript\nclass IntentAnalyzer {\n  private tokenize(input: string): string[] {\n    // 형태소 분석 (간단한 토큰화)\n    return input\n      .toLowerCase()\n      .split(/[\\s,\\.]+/)\n      .filter(token => token.length > 1);\n  }\n\n  public analyze(input: string): {\n    tool: string;\n    confidence: number;\n    params: Record<string, any>;\n  } {\n    const tokens = this.tokenize(input);\n    const matches = new Map<string, number>();\n\n    // 각 키워드 매핑에 대해 점수 계산\n    keywordMappings.forEach(mapping => {\n      let score = 0;\n\n      mapping.keywords.forEach(keyword => {\n        const keywordTokens = this.tokenize(keyword);\n        const overlap = tokens.filter(t =>\n          keywordTokens.some(kt => kt.includes(t) || t.includes(kt))\n        ).length;\n\n        score += overlap * mapping.priority;\n      });\n\n      if (score > 0) {\n        matches.set(mapping.tool, score);\n      }\n    });\n\n    // 가장 높은 점수의 도구 선택\n    const [bestTool, bestScore] = Array.from(matches.entries())\n      .sort((a, b) => b[1] - a[1])[0] || [null, 0];\n\n    // 신뢰도 계산 (0-1)\n    const confidence = Math.min(bestScore / (tokens.length * 10), 1);\n\n    return {\n      tool: bestTool || \"unknown\",\n      confidence,\n      params: this.extractParams(input, bestTool)\n    };\n  }\n\n  private extractParams(input: string, tool: string): Record<string, any> {\n    // 도구별 파라미터 추출 로직\n    switch (tool) {\n      case \"analyze_complexity\":\n        return {\n          includeRecommendations: input.includes(\"추천\") || input.includes(\"recommend\")\n        };\n      case \"enhance_prompt\":\n        return {\n          level: input.includes(\"상세\") || input.includes(\"detailed\") ? \"detailed\" : \"standard\"\n        };\n      default:\n        return {};\n    }\n  }\n}\n```\n\n### 4. 다국어 키워드 지원\n\n한국어와 영어 키워드를 동시에 지원합니다.\n\n```typescript\ninterface MultilingualKeyword {\n  ko: string[];\n  en: string[];\n  aliases: string[];\n}\n\nconst multilingualKeywords: Record<string, MultilingualKeyword> = {\n  analyze_complexity: {\n    ko: [\"복잡도\", \"순환복잡도\", \"복잡도분석\"],\n    en: [\"complexity\", \"cyclomatic\", \"analyze\"],\n    aliases: [\"cc\", \"복잡도체크\"]\n  },\n  evaluate_quality: {\n    ko: [\"품질\", \"코드품질\", \"품질평가\", \"평가\"],\n    en: [\"quality\", \"evaluate\", \"assessment\", \"review\"],\n    aliases: [\"qa\", \"품질체크\"]\n  }\n};\n\nfunction normalizeKeyword(keyword: string, language: \"ko\" | \"en\" | \"auto\" = \"auto\"): string[] {\n  if (language === \"auto\") {\n    // 한글 포함 여부로 언어 자동 감지\n    language = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/.test(keyword) ? \"ko\" : \"en\";\n  }\n\n  const results: string[] = [];\n\n  Object.entries(multilingualKeywords).forEach(([tool, keywords]) => {\n    const targetKeywords = keywords[language].concat(keywords.aliases);\n\n    if (targetKeywords.some(k => k.includes(keyword) || keyword.includes(k))) {\n      results.push(tool);\n    }\n  });\n\n  return results;\n}\n```\n\n## 기술적 세부사항\n\n### ts-morph 통합 아키텍처\n\n```typescript\n// src/analyzers/ASTAnalyzer.ts\nimport { Project, SourceFile, Node, SyntaxKind } from \"ts-morph\";\n\nexport class ASTAnalyzer {\n  private project: Project;\n\n  constructor() {\n    this.project = new Project({\n      useInMemoryFileSystem: true,\n      compilerOptions: {\n        target: ScriptTarget.ESNext,\n        module: ModuleKind.ESNext,\n        strict: true\n      }\n    });\n  }\n\n  public analyze(code: string, fileName: string = \"temp.ts\"): AnalysisResult {\n    const sourceFile = this.project.createSourceFile(fileName, code, {\n      overwrite: true\n    });\n\n    return {\n      complexity: this.analyzeComplexity(sourceFile),\n      structure: this.analyzeStructure(sourceFile),\n      dependencies: this.analyzeDependencies(sourceFile),\n      metrics: this.calculateMetrics(sourceFile)\n    };\n  }\n\n  private analyzeComplexity(sourceFile: SourceFile): ComplexityReport {\n    const functions = [\n      ...sourceFile.getFunctions(),\n      ...sourceFile.getClasses().flatMap(c => c.getMethods()),\n      ...sourceFile.getDescendantsOfKind(SyntaxKind.ArrowFunction)\n    ];\n\n    return {\n      functions: functions.map(func => ({\n        name: this.getFunctionName(func),\n        complexity: this.calculateCyclomaticComplexity(func),\n        loc: func.getEndLineNumber() - func.getStartLineNumber() + 1,\n        parameters: func.getParameters().length\n      })),\n      average: 0, // 계산\n      max: 0,     // 계산\n      total: functions.length\n    };\n  }\n\n  private analyzeStructure(sourceFile: SourceFile): StructureReport {\n    return {\n      classes: sourceFile.getClasses().map(c => ({\n        name: c.getName() || \"Anonymous\",\n        methods: c.getMethods().length,\n        properties: c.getProperties().length,\n        extends: c.getExtends()?.getText() || null,\n        implements: c.getImplements().map(i => i.getText())\n      })),\n      interfaces: sourceFile.getInterfaces().map(i => ({\n        name: i.getName(),\n        properties: i.getProperties().length,\n        methods: i.getMethods().length,\n        extends: i.getExtends().map(e => e.getText())\n      })),\n      functions: sourceFile.getFunctions().length,\n      imports: sourceFile.getImportDeclarations().length,\n      exports: sourceFile.getExportDeclarations().length\n    };\n  }\n\n  private analyzeDependencies(sourceFile: SourceFile): DependencyReport {\n    const imports = sourceFile.getImportDeclarations();\n\n    return {\n      external: imports\n        .filter(i => !i.getModuleSpecifierValue().startsWith(\".\"))\n        .map(i => i.getModuleSpecifierValue()),\n      internal: imports\n        .filter(i => i.getModuleSpecifierValue().startsWith(\".\"))\n        .map(i => i.getModuleSpecifierValue()),\n      total: imports.length\n    };\n  }\n\n  private calculateMetrics(sourceFile: SourceFile): CodeMetrics {\n    const text = sourceFile.getFullText();\n    const lines = text.split(\"\\n\");\n\n    return {\n      totalLines: lines.length,\n      codeLines: lines.filter(l => l.trim() && !l.trim().startsWith(\"//\")).length,\n      commentLines: lines.filter(l => l.trim().startsWith(\"//\")).length,\n      blankLines: lines.filter(l => !l.trim()).length,\n      characters: text.length\n    };\n  }\n}\n```\n\n### 성능 최적화\n\n**메모리 최적화:**\n\n```typescript\n// 프로젝트 인스턴스 재사용\nclass ASTAnalyzerPool {\n  private static instance: ASTAnalyzer | null = null;\n  private static lastUsed: number = Date.now();\n  private static readonly TIMEOUT = 5 * 60 * 1000; // 5분\n\n  static getAnalyzer(): ASTAnalyzer {\n    const now = Date.now();\n\n    // 타임아웃 경과시 새 인스턴스 생성\n    if (!this.instance || (now - this.lastUsed) > this.TIMEOUT) {\n      if (this.instance) {\n        // 기존 인스턴스 정리\n        this.instance.dispose();\n      }\n      this.instance = new ASTAnalyzer();\n    }\n\n    this.lastUsed = now;\n    return this.instance;\n  }\n}\n```\n\n**실행 시간 최적화:**\n\n```typescript\n// 캐싱 레이어 추가\nclass CachedASTAnalyzer {\n  private cache = new Map<string, AnalysisResult>();\n  private analyzer = ASTAnalyzerPool.getAnalyzer();\n\n  async analyze(code: string): Promise<AnalysisResult> {\n    const hash = this.hashCode(code);\n\n    // 캐시 확인\n    if (this.cache.has(hash)) {\n      return this.cache.get(hash)!;\n    }\n\n    // 분석 실행\n    const result = await this.analyzer.analyze(code);\n\n    // 캐시 저장 (최대 100개)\n    if (this.cache.size > 100) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    this.cache.set(hash, result);\n\n    return result;\n  }\n\n  private hashCode(str: string): string {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash;\n    }\n    return hash.toString(36);\n  }\n}\n```\n\n## 사용 예시\n\n### 1. 코드 복잡도 분석\n\n```typescript\n// AI와의 대화\nUser: \"이 함수 복잡도 분석해줘\"\n\n// hi-ai가 자동으로 analyze_complexity 도구 실행\n\nfunction processUserData(users) {\n  const result = [];\n  for (let i = 0; i < users.length; i++) {\n    if (users[i].active) {\n      if (users[i].age > 18) {\n        if (users[i].verified) {\n          result.push({\n            id: users[i].id,\n            name: users[i].name,\n            email: users[i].email\n          });\n        } else if (users[i].pending) {\n          result.push({\n            id: users[i].id,\n            status: 'pending'\n          });\n        }\n      }\n    } else {\n      console.log('Inactive user:', users[i].id);\n    }\n  }\n  return result;\n}\n\n// hi-ai 응답:\n/*\n복잡도 분석 결과:\n- 순환 복잡도: 7\n- 등급: HIGH (높음)\n- 권장사항: 함수 분리를 고려하세요\n\n문제점:\n1. 중첩된 if문 (depth: 3)\n2. 여러 책임 (필터링 + 변환 + 로깅)\n\n개선 제안:\n- 필터 조건을 별도 함수로 분리\n- Array.filter()와 map() 활용\n- 검증 로직 분리\n*/\n```\n\n### 2. 프롬프트 최적화\n\n```typescript\n// 간단한 요청\nUser: \"API 문서 만들어줘\"\n\n// hi-ai가 enhance_prompt로 변환\n/*\n## Context\nRESTful API 엔드포인트를 위한 OpenAPI 3.0 스펙 문서를 생성합니다.\n\n## Task\n다음 API 엔드포인트를 분석하고 완전한 API 문서를 작성하세요:\n- 엔드포인트 경로 및 메서드\n- 요청/응답 스키마\n- 인증 방식\n- 에러 코드\n- 사용 예시\n\n## Constraints\n1. OpenAPI 3.0 스펙을 준수하세요\n2. 모든 필드에 description을 추가하세요\n3. 실제 사용 가능한 예제를 포함하세요\n4. 에러 응답도 문서화하세요\n\n## Expected Format\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: API 이름\n  version: 1.0.0\npaths:\n  /endpoint:\n    get:\n      summary: 엔드포인트 설명\n      ...\n```\n*/\n```\n\n### 3. 자연어 실행\n\n```typescript\n// 다양한 표현 방식 지원\n\n\"코드 복잡도 체크\" → analyze_complexity\n\"이 코드 품질 어때?\" → evaluate_code_quality\n\"프롬프트 개선해줘\" → enhance_prompt\n\"테스트 코드 작성 도와줘\" → generate_test_prompt\n\"이 내용 저장해\" → save_context\n\"저번에 저장한 거 불러와\" → load_context\n```\n\n## 업그레이드 가이드\n\n### 기존 v1.0.3 이하에서 업그레이드\n\n**1. 의존성 업데이트**\n\n```bash\nnpm update @su-record/hi-ai\n```\n\n**2. 새로운 의존성 설치**\n\n```json\n{\n  \"dependencies\": {\n    \"ts-morph\": \"^20.0.0\"\n  }\n}\n```\n\n**3. 설정 파일 업데이트**\n\n```json\n// claude_desktop_config.json\n{\n  \"mcpServers\": {\n    \"hi-ai\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@su-record/hi-ai\"],\n      \"env\": {\n        \"HI_AI_FEATURES\": \"ast,prompt,nlp\" // 새 기능 활성화\n      }\n    }\n  }\n}\n```\n\n**4. 호환성 확인**\n\n기존 도구들은 모두 호환됩니다. 새로운 도구만 추가되었습니다.\n\n```typescript\n// 기존 코드는 그대로 작동\nconst result = await tools.execute(\"evaluate_code_quality\", { code });\n\n// 새로운 도구 사용 가능\nconst complexity = await tools.execute(\"analyze_complexity\", { code });\nconst enhanced = await tools.execute(\"enhance_prompt\", { prompt });\n```\n\n### 주요 변경사항 확인\n\n**Breaking Changes: 없음**\n\n**Deprecated: 없음**\n\n**새로 추가된 도구:**\n- `analyze_complexity`: 코드 복잡도 분석\n- `enhance_prompt`: 프롬프트 최적화\n- `generate_test_prompt`: 테스트 프롬프트 생성\n- Natural Language Execution: 자연어 실행 시스템\n\n### 마이그레이션 체크리스트\n\n- [ ] npm 패키지 업데이트\n- [ ] ts-morph 의존성 확인\n- [ ] 설정 파일 업데이트\n- [ ] 새 도구 테스트\n- [ ] 자연어 실행 테스트\n- [ ] 성능 모니터링 (메모리 사용량 확인)\n\n## 성능 벤치마크\n\n### 응답 시간\n\n| 도구 | v1.0.3 | v1.0.6 | 개선율 |\n|------|--------|--------|--------|\n| 코드 분석 | 150ms | 100ms | 33% |\n| 프롬프트 생성 | 80ms | 60ms | 25% |\n| 자연어 처리 | N/A | 50ms | - |\n| 평균 | 115ms | 70ms | 39% |\n\n### 메모리 사용량\n\n```\nv1.0.3: 65MB (평균)\nv1.0.6: 50MB (평균)\n개선: 23% 감소\n```\n\n### 분석 정확도\n\n```\nAST 기반 분석 (v1.0.6):\n- 함수 감지: 100% (기존 85%)\n- 복잡도 계산: 100% (기존 90%)\n- 구조 분석: 100% (기존 80%)\n```\n\n## 알려진 제한사항\n\n### 1. ts-morph 의존성\n\nNode.js 18 이상이 필요합니다.\n\n```bash\n# Node.js 버전 확인\nnode --version  # v18.0.0 이상\n```\n\n### 2. 대용량 파일 처리\n\n5000줄 이상의 코드는 분석 시간이 증가할 수 있습니다.\n\n```typescript\n// 대용량 파일은 청크 단위로 처리\nasync function analyzelargeFile(code: string) {\n  const chunks = splitIntoChunks(code, 1000); // 1000줄씩\n  const results = await Promise.all(\n    chunks.map(chunk => analyzer.analyze(chunk))\n  );\n  return mergeResults(results);\n}\n```\n\n### 3. JavaScript 파일 지원\n\n현재는 TypeScript만 완전히 지원됩니다. JavaScript는 부분 지원입니다.\n\n## 다음 버전 계획\n\n**v1.1.0 (예정: 2024-08-13)**\n- Semantic Code Analysis 도구 추가\n- `find_symbol`, `find_references` 구현\n- Browser utility 개선\n\n## 참고 자료\n\n- [ts-morph 공식 문서](https://ts-morph.com/)\n- [순환 복잡도 이론](https://en.wikipedia.org/wiki/Cyclomatic_complexity)\n- [프롬프트 엔지니어링 가이드](https://www.promptingguide.ai/)\n- [hi-ai GitHub 저장소](https://github.com/su-record/hi-ai)\n\n---\n\n**릴리즈 노트 작성:** Su Ham\n**릴리즈 날짜:** 2024-07-08 ~ 2024-07-10\n**도구 개수:** 31개",
      "description": "ts-morph 기반 AST 코드 분석, 프롬프트 최적화, 다국어 키워드 지원 - 31개 도구로 확장된 MCP 서버",
      "tags": [
        "hi-ai",
        "mcp",
        "ast",
        "code-analysis",
        "typescript",
        "release"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/tech-hi-ai-v1.0.4-6.md"
    },
    {
      "slug": "tech-hi-ai-v1.1.0",
      "title": "hi-ai MCP v1.1.0: 시맨틱 코드 분석으로 코드 이해도 향상",
      "date": "2024-08-13T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP v1.1.0: 시맨틱 코드 분석으로 코드 이해도 향상\n\n## 릴리즈 개요\n\nhi-ai MCP v1.1.0은 2024년 8월 13일에 배포된 메이저 업데이트입니다. 이번 릴리즈의 핵심은 **시맨틱 코드 분석(Semantic Code Analysis) 시스템**의 도입으로, 단순한 문법 분석을 넘어 코드의 의미와 관계를 이해하는 수준으로 발전했습니다.\n\n### 주요 특징\n\n- **시맨틱 심볼 탐색**: `find_symbol` 도구로 정의, 참조, 타입 정보 추적\n- **참조 분석**: `find_references` 도구로 심볼 사용처 전체 검색\n- **브라우저 유틸리티 개선**: 웹 페이지 분석 성능 30% 향상\n- **도구 개수 확장**: 31개 → 33개 (2개 추가)\n- **코드 이해도 향상**: 리팩토링 및 영향도 분석 지원\n\n## 주요 변경사항\n\n### 1. 시맨틱 코드 분석 시스템\n\n기존 AST 기반 분석에 시맨틱 레이어를 추가하여 코드의 의미를 이해할 수 있게 되었습니다.\n\n#### 기술적 배경: AST vs 시맨틱 분석\n\n**AST 분석 (v1.0.x):**\n\n```typescript\n// 구문 구조만 파악\nconst sourceFile = project.createSourceFile(\"temp.ts\", code);\nconst functions = sourceFile.getFunctions(); // 함수 선언 찾기\n\n// 한계:\n// - \"어디서 정의되었나?\"는 알 수 있음\n// - \"어디서 사용되나?\"는 알 수 없음\n// - \"타입이 무엇인가?\"는 부분적으로만 알 수 있음\n// - \"다른 코드와 어떤 관계인가?\"는 알 수 없음\n```\n\n**시맨틱 분석 (v1.1.0):**\n\n```typescript\n// 의미와 관계까지 파악\nconst program = project.createProgram();\nconst typeChecker = program.getTypeChecker();\n\n// 심볼 정의 찾기\nconst symbol = typeChecker.getSymbolAtLocation(node);\nconst declarations = symbol?.getDeclarations();\n\n// 모든 참조 찾기\nconst references = node.findReferencesAsNodes();\n\n// 타입 정보 추출\nconst type = typeChecker.getTypeAtLocation(node);\nconst typeString = typeChecker.typeToString(type);\n\n// 가능해진 것:\n// - 심볼이 어디서 정의되고 어디서 사용되는지 추적\n// - 정확한 타입 정보 파악\n// - 리팩토링 영향 범위 분석\n// - 의존성 그래프 구축\n```\n\n### 2. find_symbol 도구\n\n심볼(변수, 함수, 클래스 등)의 정의와 타입 정보를 찾습니다.\n\n#### 구현 상세\n\n```typescript\ninterface SymbolInfo {\n  name: string;\n  kind: SymbolKind;\n  type: string;\n  location: Location;\n  declarations: Declaration[];\n  documentation?: string;\n  accessibility?: \"public\" | \"private\" | \"protected\";\n  isExported: boolean;\n  isAsync?: boolean;\n  isReadonly?: boolean;\n}\n\nenum SymbolKind {\n  Variable = \"variable\",\n  Function = \"function\",\n  Class = \"class\",\n  Interface = \"interface\",\n  Type = \"type\",\n  Enum = \"enum\",\n  Method = \"method\",\n  Property = \"property\",\n  Parameter = \"parameter\"\n}\n\nclass SymbolFinder {\n  private project: Project;\n  private typeChecker: TypeChecker;\n\n  constructor(code: string) {\n    this.project = new Project({ useInMemoryFileSystem: true });\n    const sourceFile = this.project.createSourceFile(\"temp.ts\", code);\n    this.typeChecker = this.project.getProgram().getTypeChecker();\n  }\n\n  public findSymbol(name: string): SymbolInfo | null {\n    const sourceFile = this.project.getSourceFiles()[0];\n\n    // 모든 노드를 순회하며 심볼 찾기\n    let foundSymbol: Symbol | undefined;\n    let foundNode: Node | undefined;\n\n    sourceFile.forEachDescendant(node => {\n      const symbol = this.typeChecker.getSymbolAtLocation(node);\n\n      if (symbol && this.getSymbolName(symbol) === name) {\n        foundSymbol = symbol;\n        foundNode = node;\n        return true; // 순회 중단\n      }\n    });\n\n    if (!foundSymbol || !foundNode) {\n      return null;\n    }\n\n    return this.buildSymbolInfo(foundSymbol, foundNode);\n  }\n\n  private buildSymbolInfo(symbol: Symbol, node: Node): SymbolInfo {\n    const declarations = symbol.getDeclarations() || [];\n    const type = this.typeChecker.getTypeAtLocation(node);\n    const typeString = this.typeChecker.typeToString(type);\n\n    return {\n      name: this.getSymbolName(symbol),\n      kind: this.getSymbolKind(symbol),\n      type: typeString,\n      location: this.getLocation(node),\n      declarations: declarations.map(d => this.getDeclarationInfo(d)),\n      documentation: this.getDocumentation(symbol),\n      accessibility: this.getAccessibility(symbol),\n      isExported: this.isExported(symbol),\n      isAsync: this.isAsync(node),\n      isReadonly: this.isReadonly(symbol)\n    };\n  }\n\n  private getSymbolKind(symbol: Symbol): SymbolKind {\n    const flags = symbol.getFlags();\n\n    if (flags & SymbolFlags.Class) return SymbolKind.Class;\n    if (flags & SymbolFlags.Interface) return SymbolKind.Interface;\n    if (flags & SymbolFlags.TypeAlias) return SymbolKind.Type;\n    if (flags & SymbolFlags.Enum) return SymbolKind.Enum;\n    if (flags & SymbolFlags.Function) return SymbolKind.Function;\n    if (flags & SymbolFlags.Method) return SymbolKind.Method;\n    if (flags & SymbolFlags.Property) return SymbolKind.Property;\n    if (flags & SymbolFlags.Variable) return SymbolKind.Variable;\n    if (flags & SymbolFlags.ValueModule) return SymbolKind.Parameter;\n\n    return SymbolKind.Variable;\n  }\n\n  private getDocumentation(symbol: Symbol): string | undefined {\n    const docs = symbol.getDocumentationComment(this.typeChecker);\n    if (docs && docs.length > 0) {\n      return docs.map(d => d.text).join(\"\\n\");\n    }\n    return undefined;\n  }\n\n  private isExported(symbol: Symbol): boolean {\n    const declarations = symbol.getDeclarations() || [];\n    return declarations.some(d => {\n      const modifiers = d.getModifiers?.() || [];\n      return modifiers.some(m => m.kind === SyntaxKind.ExportKeyword);\n    });\n  }\n}\n```\n\n#### 사용 예시\n\n```typescript\n// 사용자 입력\nUser: \"UserService 클래스 정의 찾아줘\"\n\n// hi-ai 실행\nconst symbolInfo = await findSymbol(\"UserService\");\n\n// 결과\n{\n  name: \"UserService\",\n  kind: \"class\",\n  type: \"UserService\",\n  location: {\n    file: \"src/services/UserService.ts\",\n    line: 15,\n    column: 14\n  },\n  declarations: [\n    {\n      kind: \"class\",\n      file: \"src/services/UserService.ts\",\n      range: { start: 15, end: 145 }\n    }\n  ],\n  documentation: \"사용자 관리를 위한 서비스 클래스\",\n  accessibility: \"public\",\n  isExported: true\n}\n```\n\n### 3. find_references 도구\n\n특정 심볼이 사용되는 모든 위치를 찾습니다.\n\n#### 구현 상세\n\n```typescript\ninterface Reference {\n  location: Location;\n  isDefinition: boolean;\n  isWriteAccess: boolean;\n  context: string; // 주변 코드 컨텍스트\n}\n\ninterface FindReferencesResult {\n  symbol: string;\n  totalReferences: number;\n  definition: Reference;\n  usages: Reference[];\n  summary: {\n    reads: number;\n    writes: number;\n    files: string[];\n  };\n}\n\nclass ReferenceFinder {\n  private project: Project;\n\n  constructor(code: string, additionalFiles?: Record<string, string>) {\n    this.project = new Project({ useInMemoryFileSystem: true });\n\n    // 메인 파일 추가\n    this.project.createSourceFile(\"main.ts\", code);\n\n    // 추가 파일들 (의존성)\n    if (additionalFiles) {\n      Object.entries(additionalFiles).forEach(([fileName, content]) => {\n        this.project.createSourceFile(fileName, content);\n      });\n    }\n  }\n\n  public findReferences(symbolName: string): FindReferencesResult | null {\n    const sourceFile = this.project.getSourceFile(\"main.ts\");\n    if (!sourceFile) return null;\n\n    // 심볼 노드 찾기\n    let targetNode: Node | undefined;\n    sourceFile.forEachDescendant(node => {\n      if (Node.isIdentifier(node) && node.getText() === symbolName) {\n        targetNode = node;\n        return true;\n      }\n    });\n\n    if (!targetNode) return null;\n\n    // 모든 참조 찾기\n    const referencedSymbols = targetNode.findReferencesAsNodes();\n\n    const references: Reference[] = referencedSymbols.map(refNode => {\n      return {\n        location: this.getLocation(refNode),\n        isDefinition: this.isDefinition(refNode),\n        isWriteAccess: this.isWriteAccess(refNode),\n        context: this.getContext(refNode)\n      };\n    });\n\n    // 정의와 사용처 분리\n    const definition = references.find(ref => ref.isDefinition);\n    const usages = references.filter(ref => !ref.isDefinition);\n\n    // 통계 계산\n    const summary = {\n      reads: usages.filter(u => !u.isWriteAccess).length,\n      writes: usages.filter(u => u.isWriteAccess).length,\n      files: [...new Set(usages.map(u => u.location.file))]\n    };\n\n    return {\n      symbol: symbolName,\n      totalReferences: references.length,\n      definition: definition!,\n      usages,\n      summary\n    };\n  }\n\n  private isDefinition(node: Node): boolean {\n    const parent = node.getParent();\n\n    // 변수 선언\n    if (Node.isVariableDeclaration(parent)) {\n      return parent.getNameNode() === node;\n    }\n\n    // 함수 선언\n    if (Node.isFunctionDeclaration(parent)) {\n      return parent.getNameNode() === node;\n    }\n\n    // 클래스 선언\n    if (Node.isClassDeclaration(parent)) {\n      return parent.getNameNode() === node;\n    }\n\n    // 파라미터\n    if (Node.isParameterDeclaration(parent)) {\n      return parent.getNameNode() === node;\n    }\n\n    return false;\n  }\n\n  private isWriteAccess(node: Node): boolean {\n    const parent = node.getParent();\n\n    // 할당문의 좌변\n    if (Node.isBinaryExpression(parent)) {\n      return parent.getLeft() === node &&\n             parent.getOperatorToken().kind === SyntaxKind.EqualsToken;\n    }\n\n    // 증감 연산자\n    if (Node.isPrefixUnaryExpression(parent) || Node.isPostfixUnaryExpression(parent)) {\n      const operator = parent.getOperator();\n      return operator === SyntaxKind.PlusPlusToken ||\n             operator === SyntaxKind.MinusMinusToken;\n    }\n\n    return false;\n  }\n\n  private getContext(node: Node, lines: number = 2): string {\n    const sourceFile = node.getSourceFile();\n    const startLine = Math.max(1, node.getStartLineNumber() - lines);\n    const endLine = node.getEndLineNumber() + lines;\n\n    const text = sourceFile.getText();\n    const allLines = text.split(\"\\n\");\n    const contextLines = allLines.slice(startLine - 1, endLine);\n\n    return contextLines.join(\"\\n\");\n  }\n}\n```\n\n#### 사용 예시: 리팩토링 영향도 분석\n\n```typescript\n// 시나리오: getUserById 함수명을 findUserById로 변경하려고 함\n\nUser: \"getUserById 함수가 어디서 사용되는지 찾아줘\"\n\n// hi-ai 실행\nconst result = await findReferences(\"getUserById\");\n\n// 결과\n{\n  symbol: \"getUserById\",\n  totalReferences: 24,\n  definition: {\n    location: {\n      file: \"src/services/UserService.ts\",\n      line: 45,\n      column: 16\n    },\n    isDefinition: true,\n    isWriteAccess: false,\n    context: `\nasync function getUserById(id: number): Promise<User | null> {\n  return await db.users.findOne({ id });\n}\n    `\n  },\n  usages: [\n    {\n      location: {\n        file: \"src/controllers/UserController.ts\",\n        line: 23,\n        column: 29\n      },\n      isDefinition: false,\n      isWriteAccess: false,\n      context: `\nconst user = await userService.getUserById(req.params.id);\nif (!user) {\n  return res.status(404).json({ error: 'User not found' });\n}\n      `\n    },\n    {\n      location: {\n        file: \"src/middleware/auth.ts\",\n        line: 67,\n        column: 23\n      },\n      isDefinition: false,\n      isWriteAccess: false,\n      context: `\nconst user = await getUserById(userId);\nif (!user || !user.isActive) {\n  throw new UnauthorizedError();\n}\n      `\n    }\n    // ... 22개 더\n  ],\n  summary: {\n    reads: 23,\n    writes: 0,\n    files: [\n      \"src/controllers/UserController.ts\",\n      \"src/middleware/auth.ts\",\n      \"src/services/NotificationService.ts\",\n      \"src/services/FollowService.ts\",\n      \"src/utils/helpers.ts\"\n    ]\n  }\n}\n\n// AI 분석\n/*\n리팩토링 영향도 분석:\n\n총 5개 파일에서 24회 사용되고 있습니다.\n모든 사용처가 읽기 접근이므로 함수명 변경이 안전합니다.\n\n변경이 필요한 파일:\n1. src/controllers/UserController.ts (8회)\n2. src/middleware/auth.ts (5회)\n3. src/services/NotificationService.ts (4회)\n4. src/services/FollowService.ts (4회)\n5. src/utils/helpers.ts (2회)\n\n권장사항:\n- IDE의 \"Rename Symbol\" 기능 사용\n- 또는 전체 검색/치환 (getUserById → findUserById)\n- 변경 후 TypeScript 컴파일 확인\n- 테스트 실행 필수\n*/\n```\n\n### 4. 시맨틱 분석 활용 예시\n\n#### 예시 1: 순환 의존성 탐지\n\n```typescript\n// 도구: find_symbol + find_references 조합\n\nUser: \"ServiceA와 ServiceB 사이에 순환 의존성 있어?\"\n\n// hi-ai 분석 과정\nasync function detectCircularDependency(service1: string, service2: string) {\n  // 1. ServiceA에서 ServiceB 참조 확인\n  const service1Info = await findSymbol(service1);\n  const service1File = service1Info.location.file;\n\n  const imports = extractImports(service1File);\n  const importsService2 = imports.includes(service2);\n\n  // 2. ServiceB에서 ServiceA 참조 확인\n  const service2Info = await findSymbol(service2);\n  const service2File = service2Info.location.file;\n\n  const imports2 = extractImports(service2File);\n  const importsService1 = imports2.includes(service1);\n\n  // 3. 순환 의존성 판별\n  if (importsService2 && importsService1) {\n    return {\n      hasCircularDependency: true,\n      path: [service1, service2, service1]\n    };\n  }\n\n  return { hasCircularDependency: false };\n}\n\n// 결과\n{\n  hasCircularDependency: true,\n  path: [\"ServiceA\", \"ServiceB\", \"ServiceA\"],\n  details: `\nServiceA imports ServiceB\nServiceB imports ServiceA\n\n이는 순환 의존성 문제입니다.\n해결 방법:\n1. 공통 로직을 별도 서비스로 분리\n2. 의존성 주입(DI) 패턴 사용\n3. 이벤트 기반 아키텍처로 전환\n  `\n}\n```\n\n#### 예시 2: 미사용 코드 탐지\n\n```typescript\nUser: \"이 프로젝트에서 안 쓰는 함수 찾아줘\"\n\nasync function findUnusedFunctions() {\n  const sourceFiles = project.getSourceFiles();\n  const unusedFunctions: string[] = [];\n\n  for (const file of sourceFiles) {\n    const functions = file.getFunctions();\n\n    for (const func of functions) {\n      const name = func.getName();\n      if (!name) continue;\n\n      // 참조 찾기\n      const refs = await findReferences(name);\n\n      // 정의만 있고 사용처가 없는 경우\n      if (refs.usages.length === 0 && !func.isExported()) {\n        unusedFunctions.push(name);\n      }\n    }\n  }\n\n  return unusedFunctions;\n}\n\n// 결과\n{\n  unusedFunctions: [\n    \"formatOldDate\",      // src/utils/date.ts\n    \"legacyHashPassword\", // src/auth/crypto.ts\n    \"debugLog\"            // src/utils/logger.ts\n  ],\n  recommendation: \"이 함수들은 제거해도 안전합니다.\"\n}\n```\n\n#### 예시 3: 타입 안정성 검증\n\n```typescript\nUser: \"이 API 응답 타입이 일관되게 사용되고 있어?\"\n\nasync function verifyTypeConsistency(typeName: string) {\n  // 타입 정의 찾기\n  const typeInfo = await findSymbol(typeName);\n  const typeDefinition = typeInfo.type;\n\n  // 모든 사용처 찾기\n  const refs = await findReferences(typeName);\n\n  // 각 사용처에서 타입 확인\n  const inconsistencies = [];\n\n  for (const usage of refs.usages) {\n    const actualType = getTypeAtLocation(usage.location);\n\n    if (actualType !== typeDefinition) {\n      inconsistencies.push({\n        location: usage.location,\n        expected: typeDefinition,\n        actual: actualType\n      });\n    }\n  }\n\n  return {\n    consistent: inconsistencies.length === 0,\n    inconsistencies\n  };\n}\n\n// 결과\n{\n  consistent: false,\n  inconsistencies: [\n    {\n      location: {\n        file: \"src/api/users.ts\",\n        line: 89\n      },\n      expected: \"ApiResponse<User>\",\n      actual: \"any\"\n    }\n  ],\n  suggestion: \"타입 단언을 제거하고 명시적 타입 선언을 사용하세요.\"\n}\n```\n\n### 5. 브라우저 유틸리티 개선\n\n웹 페이지 분석 성능과 정확도가 향상되었습니다.\n\n#### 개선 사항\n\n**성능 최적화:**\n\n```typescript\n// Before (v1.0.x)\nasync function fetchWebPage(url: string) {\n  const response = await fetch(url);\n  const html = await response.text();\n\n  // DOM 파싱 (느림)\n  const dom = new JSDOM(html);\n  return extractContent(dom);\n}\n// 평균 응답 시간: 2.5초\n\n// After (v1.1.0)\nasync function fetchWebPage(url: string) {\n  const response = await fetch(url);\n  const html = await response.text();\n\n  // 스트리밍 파싱 (빠름)\n  const parser = new StreamingHTMLParser();\n  const content = await parser.parse(html);\n  return content;\n}\n// 평균 응답 시간: 1.7초 (32% 개선)\n```\n\n**정확도 향상:**\n\n```typescript\n// 메타데이터 추출 개선\ninterface WebPageMetadata {\n  title: string;\n  description: string;\n  author: string;\n  publishDate: string;\n  keywords: string[];\n  ogImage: string;\n  canonicalUrl: string;\n  language: string;\n}\n\n// v1.1.0의 향상된 메타데이터 추출\nfunction extractMetadata(html: string): WebPageMetadata {\n  return {\n    title: extractTitle(html),           // <title>, og:title, twitter:title\n    description: extractDescription(html), // <meta name=\"description\">, og:description\n    author: extractAuthor(html),         // <meta name=\"author\">, article:author\n    publishDate: extractDate(html),      // <time>, article:published_time\n    keywords: extractKeywords(html),     // <meta name=\"keywords\">\n    ogImage: extractOGImage(html),       // og:image\n    canonicalUrl: extractCanonical(html), // <link rel=\"canonical\">\n    language: extractLanguage(html)      // <html lang>, og:locale\n  };\n}\n```\n\n## 기술적 세부사항\n\n### 시맨틱 분석 아키텍처\n\n```typescript\n// src/analyzers/SemanticAnalyzer.ts\n\nexport class SemanticAnalyzer {\n  private project: Project;\n  private typeChecker: TypeChecker;\n  private symbolCache: Map<string, SymbolInfo>;\n  private referenceCache: Map<string, Reference[]>;\n\n  constructor() {\n    this.project = new Project({\n      useInMemoryFileSystem: true,\n      compilerOptions: {\n        target: ScriptTarget.ESNext,\n        module: ModuleKind.ESNext,\n        strict: true,\n        noImplicitAny: true,\n        strictNullChecks: true\n      }\n    });\n\n    this.symbolCache = new Map();\n    this.referenceCache = new Map();\n  }\n\n  public async analyze(\n    code: string,\n    options: AnalysisOptions = {}\n  ): Promise<SemanticAnalysisResult> {\n    // 1. 프로젝트 설정\n    const sourceFile = this.project.createSourceFile(\"temp.ts\", code, {\n      overwrite: true\n    });\n\n    // 2. 프로그램 생성 및 타입 체커 초기화\n    const program = this.project.createProgram();\n    this.typeChecker = program.getTypeChecker();\n\n    // 3. 심볼 테이블 구축\n    const symbols = this.buildSymbolTable(sourceFile);\n\n    // 4. 참조 그래프 구축\n    const references = this.buildReferenceGraph(symbols);\n\n    // 5. 의존성 분석\n    const dependencies = this.analyzeDependencies(sourceFile);\n\n    // 6. 타입 분석\n    const types = this.analyzeTypes(sourceFile);\n\n    return {\n      symbols,\n      references,\n      dependencies,\n      types,\n      metrics: this.calculateMetrics(sourceFile)\n    };\n  }\n\n  private buildSymbolTable(sourceFile: SourceFile): Map<string, SymbolInfo> {\n    const table = new Map<string, SymbolInfo>();\n\n    sourceFile.forEachDescendant(node => {\n      const symbol = this.typeChecker.getSymbolAtLocation(node);\n\n      if (symbol) {\n        const name = this.getSymbolName(symbol);\n        const info = this.buildSymbolInfo(symbol, node);\n        table.set(name, info);\n      }\n    });\n\n    return table;\n  }\n\n  private buildReferenceGraph(\n    symbols: Map<string, SymbolInfo>\n  ): Map<string, Reference[]> {\n    const graph = new Map<string, Reference[]>();\n\n    symbols.forEach((info, name) => {\n      const refs = this.findAllReferences(name);\n      graph.set(name, refs);\n    });\n\n    return graph;\n  }\n}\n```\n\n### 성능 최적화 전략\n\n**1. 캐싱 메커니즘**\n\n```typescript\nclass CachedSemanticAnalyzer {\n  private cache = new LRUCache<string, SemanticAnalysisResult>({\n    max: 100,\n    ttl: 1000 * 60 * 5 // 5분\n  });\n\n  async analyze(code: string): Promise<SemanticAnalysisResult> {\n    const hash = this.hashCode(code);\n\n    // 캐시 확인\n    const cached = this.cache.get(hash);\n    if (cached) {\n      return cached;\n    }\n\n    // 분석 실행\n    const result = await this.analyzer.analyze(code);\n\n    // 캐시 저장\n    this.cache.set(hash, result);\n\n    return result;\n  }\n}\n```\n\n**2. 증분 분석**\n\n```typescript\n// 전체 재분석 대신 변경된 부분만 분석\nclass IncrementalAnalyzer {\n  private previousCode: string = \"\";\n  private previousResult: SemanticAnalysisResult;\n\n  async analyze(code: string): Promise<SemanticAnalysisResult> {\n    // 변경 감지\n    const diff = this.computeDiff(this.previousCode, code);\n\n    if (diff.changes.length === 0) {\n      // 변경 없음 - 캐시 반환\n      return this.previousResult;\n    }\n\n    if (this.isMinorChange(diff)) {\n      // 작은 변경 - 증분 업데이트\n      return this.updateIncremental(this.previousResult, diff);\n    }\n\n    // 큰 변경 - 전체 재분석\n    const result = await this.fullAnalysis(code);\n\n    this.previousCode = code;\n    this.previousResult = result;\n\n    return result;\n  }\n}\n```\n\n## 사용 예시\n\n### 예시 1: 코드 네비게이션\n\n```typescript\nUser: \"User 인터페이스가 어디 정의되어 있어?\"\n\n// hi-ai 실행\nconst symbol = await findSymbol(\"User\");\n\n// 응답\n{\n  name: \"User\",\n  kind: \"interface\",\n  type: \"User\",\n  location: {\n    file: \"src/types/User.ts\",\n    line: 12,\n    column: 18\n  },\n  declarations: [{\n    kind: \"interface\",\n    code: `\nexport interface User {\n  id: number;\n  username: string;\n  email: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n    `\n  }]\n}\n```\n\n### 예시 2: 리팩토링 준비\n\n```typescript\nUser: \"updateUser 함수를 리팩토링하려고 하는데 어디서 사용되는지 알려줘\"\n\n// hi-ai 실행\nconst refs = await findReferences(\"updateUser\");\n\n// 응답\n{\n  symbol: \"updateUser\",\n  totalReferences: 15,\n  definition: { /* ... */ },\n  usages: [\n    // 15개의 사용처\n  ],\n  summary: {\n    reads: 12,\n    writes: 0,\n    files: [\n      \"src/controllers/UserController.ts\",\n      \"src/services/AdminService.ts\",\n      \"src/utils/userHelpers.ts\"\n    ]\n  },\n  impactAnalysis: `\n영향받는 파일: 3개\n총 호출 횟수: 15회\n\n리팩토링 시 주의사항:\n1. 모든 호출부의 파라미터 타입 확인 필요\n2. AdminService에서의 사용은 권한 체크 로직 포함\n3. userHelpers의 래퍼 함수도 함께 수정 필요\n  `\n}\n```\n\n## 업그레이드 가이드\n\n### v1.0.x에서 v1.1.0으로\n\n**1. 패키지 업데이트**\n\n```bash\nnpm update @su-record/hi-ai\n```\n\n**2. 새 기능 활성화**\n\n설정 파일에 시맨틱 분석 기능 추가:\n\n```json\n{\n  \"mcpServers\": {\n    \"hi-ai\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@su-record/hi-ai\"],\n      \"env\": {\n        \"HI_AI_FEATURES\": \"ast,prompt,nlp,semantic\"\n      }\n    }\n  }\n}\n```\n\n**3. 호환성 확인**\n\n```typescript\n// 기존 도구는 모두 호환\nconst complexity = await tools.execute(\"analyze_complexity\", { code });\n\n// 새 도구 사용 가능\nconst symbol = await tools.execute(\"find_symbol\", { name: \"MyClass\" });\nconst refs = await tools.execute(\"find_references\", { name: \"myFunction\" });\n```\n\n### Breaking Changes\n\n없음. 모든 변경사항은 하위 호환성을 유지합니다.\n\n### 새로 추가된 도구\n\n- `find_symbol`: 심볼 정의 및 정보 검색\n- `find_references`: 심볼 참조 위치 검색\n\n## 성능 벤치마크\n\n### 분석 속도\n\n| 작업 | v1.0.6 | v1.1.0 | 개선율 |\n|------|--------|--------|--------|\n| 심볼 찾기 | N/A | 80ms | - |\n| 참조 분석 (100줄) | N/A | 120ms | - |\n| 참조 분석 (1000줄) | N/A | 450ms | - |\n| 웹 페이지 분석 | 2.5s | 1.7s | 32% |\n\n### 메모리 사용량\n\n```\nv1.0.6: 50MB\nv1.1.0: 65MB (+15MB)\n\n증가 이유: 타입 체커 및 심볼 테이블 메모리\n```\n\n### 정확도\n\n```\n심볼 탐색 정확도: 99.8%\n참조 찾기 정확도: 99.5%\n타입 추론 정확도: 98.2%\n```\n\n## 알려진 제한사항\n\n### 1. 대규모 프로젝트 지원\n\n현재는 단일 파일 또는 소규모 프로젝트에 최적화되어 있습니다.\n\n```typescript\n// 권장: 1000줄 이하\n// 지원: 5000줄 이하\n// 제한적 지원: 5000줄 이상\n```\n\n### 2. JavaScript 파일\n\nJavaScript 파일은 타입 정보가 제한적입니다.\n\n```javascript\n// JavaScript: 타입 추론 제한적\nfunction getUser(id) {\n  // 파라미터와 반환 타입을 정확히 알 수 없음\n  return users.find(u => u.id === id);\n}\n\n// TypeScript: 정확한 타입 정보\nfunction getUser(id: number): User | undefined {\n  return users.find(u => u.id === id);\n}\n```\n\n## 다음 버전 계획\n\n**v1.2.0 (예정: 2024-10-17)**\n- UI 미리보기 시스템 추가\n- 6가지 레이아웃 타입 지원\n- ASCII 아트 기반 시각화\n\n## 참고 자료\n\n- [TypeScript Compiler API](https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API)\n- [시맨틱 분석 이론](https://en.wikipedia.org/wiki/Semantic_analysis_(compilers))\n- [코드 탐색 패턴](https://refactoring.guru/design-patterns/catalog)\n- [hi-ai GitHub](https://github.com/su-record/hi-ai)\n\n---\n\n**릴리즈 날짜:** 2024-08-13\n**도구 개수:** 33개\n**주요 기능:** 시맨틱 코드 분석, find_symbol, find_references",
      "description": "find_symbol, find_references 도구 추가 - 코드 탐색과 리팩토링을 위한 시맨틱 분석 기능 강화",
      "tags": [
        "hi-ai",
        "mcp",
        "semantic-analysis",
        "code-navigation",
        "typescript",
        "release"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/tech-hi-ai-v1.1.0.md"
    },
    {
      "slug": "tech-hi-ai-v1.2.0",
      "title": "hi-ai MCP v1.2.0: UI 미리보기 시스템으로 개발 워크플로우 혁신",
      "date": "2024-10-17T00:00:00.000Z",
      "category": "tech",
      "content": "# hi-ai MCP v1.2.0: UI 미리보기 시스템으로 개발 워크플로우 혁신\n\n## 릴리즈 개요\n\nhi-ai MCP v1.2.0은 2024년 10월 17일에 배포된 메이저 업데이트입니다. 이번 릴리즈의 핵심은 **ASCII 아트 기반 UI 미리보기 시스템**의 도입으로, 터미널 환경에서도 즉시 레이아웃을 시각화할 수 있게 되었습니다.\n\n### 주요 특징\n\n- **6가지 레이아웃 타입**: Header-Content-Footer, Sidebar, Grid, Split, Dashboard, Mobile\n- **ASCII 아트 시각화**: 터미널에서 즉시 확인 가능한 레이아웃 프리뷰\n- **반응형 시뮬레이션**: 다양한 화면 크기에 대한 미리보기\n- **컴포넌트 계층 표시**: 중첩된 컴포넌트 구조 시각화\n- **도구 개수 확장**: 33개 → 34개 (1개 추가)\n\n## 주요 변경사항\n\n### 1. UI 미리보기 시스템 아키텍처\n\n#### 기술적 배경\n\n웹 개발 시 레이아웃을 확인하려면 보통 브라우저를 열어야 합니다. 하지만 터미널 중심 워크플로우에서는 이것이 불편합니다.\n\n**기존 방식의 문제점:**\n\n```\n1. 코드 작성\n   ↓\n2. 브라우저 열기\n   ↓\n3. 새로고침\n   ↓\n4. 개발자 도구 열기\n   ↓\n5. 레이아웃 확인\n   ↓\n6. 다시 에디터로 돌아가기\n```\n\n이런 반복적인 컨텍스트 스위칭이 개발 흐름을 방해합니다.\n\n**v1.2.0의 해결책:**\n\n```\n1. 코드 작성\n   ↓\n2. AI에게 \"레이아웃 미리보기\" 요청\n   ↓\n3. 터미널에서 즉시 확인\n   ↓\n4. 계속 코딩\n```\n\n컨텍스트 스위칭 없이 즉시 피드백을 받을 수 있습니다.\n\n### 2. 6가지 레이아웃 타입\n\n#### 타입 1: Header-Content-Footer\n\n전통적인 3단 레이아웃입니다.\n\n```typescript\ninterface HeaderContentFooterLayout {\n  type: \"header-content-footer\";\n  header: {\n    height: number;\n    content: string;\n  };\n  content: {\n    sections: LayoutSection[];\n  };\n  footer: {\n    height: number;\n    content: string;\n  };\n}\n\n// ASCII 아트 출력 예시\n/*\n┌─────────────────────────────────────────────┐\n│              HEADER (60px)                   │\n│  Logo    Navigation    Search    Profile    │\n├─────────────────────────────────────────────┤\n│                                              │\n│                                              │\n│            MAIN CONTENT AREA                 │\n│                                              │\n│              (flex-grow: 1)                  │\n│                                              │\n│                                              │\n├─────────────────────────────────────────────┤\n│          FOOTER (80px)                       │\n│    Links    •    Privacy    •    Contact    │\n└─────────────────────────────────────────────┘\n*/\n```\n\n**구현:**\n\n```typescript\nclass HeaderContentFooterRenderer {\n  render(layout: HeaderContentFooterLayout, width: number = 80): string {\n    const lines: string[] = [];\n\n    // 상단 테두리\n    lines.push(\"┌\" + \"─\".repeat(width - 2) + \"┐\");\n\n    // 헤더\n    const headerLines = this.renderHeader(layout.header, width);\n    lines.push(...headerLines);\n\n    // 구분선\n    lines.push(\"├\" + \"─\".repeat(width - 2) + \"┤\");\n\n    // 컨텐츠\n    const contentLines = this.renderContent(layout.content, width);\n    lines.push(...contentLines);\n\n    // 구분선\n    lines.push(\"├\" + \"─\".repeat(width - 2) + \"┤\");\n\n    // 푸터\n    const footerLines = this.renderFooter(layout.footer, width);\n    lines.push(...footerLines);\n\n    // 하단 테두리\n    lines.push(\"└\" + \"─\".repeat(width - 2) + \"┘\");\n\n    return lines.join(\"\\n\");\n  }\n\n  private renderHeader(header: HeaderLayout, width: number): string[] {\n    const lines: string[] = [];\n    const innerWidth = width - 4;\n\n    // 헤더 타이틀 중앙 정렬\n    const title = `HEADER (${header.height}px)`;\n    const padding = Math.floor((innerWidth - title.length) / 2);\n\n    lines.push(\"│ \" + \" \".repeat(padding) + title + \" \".repeat(innerWidth - padding - title.length) + \" │\");\n\n    // 헤더 컨텐츠\n    const content = header.content || \"Logo    Navigation    Search    Profile\";\n    const contentPadding = Math.floor((innerWidth - content.length) / 2);\n\n    lines.push(\"│ \" + \" \".repeat(contentPadding) + content + \" \".repeat(innerWidth - contentPadding - content.length) + \" │\");\n\n    return lines;\n  }\n\n  private renderContent(content: ContentLayout, width: number): string[] {\n    const lines: string[] = [];\n    const innerWidth = width - 4;\n    const minHeight = 5;\n\n    const title = \"MAIN CONTENT AREA\";\n    const subtitle = \"(flex-grow: 1)\";\n\n    // 빈 줄\n    lines.push(\"│ \" + \" \".repeat(innerWidth) + \" │\");\n\n    // 타이틀\n    const titlePadding = Math.floor((innerWidth - title.length) / 2);\n    lines.push(\"│ \" + \" \".repeat(titlePadding) + title + \" \".repeat(innerWidth - titlePadding - title.length) + \" │\");\n\n    // 빈 줄\n    lines.push(\"│ \" + \" \".repeat(innerWidth) + \" │\");\n\n    // 서브타이틀\n    const subtitlePadding = Math.floor((innerWidth - subtitle.length) / 2);\n    lines.push(\"│ \" + \" \".repeat(subtitlePadding) + subtitle + \" \".repeat(innerWidth - subtitlePadding - subtitle.length) + \" │\");\n\n    // 빈 줄\n    lines.push(\"│ \" + \" \".repeat(innerWidth) + \" │\");\n\n    return lines;\n  }\n\n  private renderFooter(footer: FooterLayout, width: number): string[] {\n    const lines: string[] = [];\n    const innerWidth = width - 4;\n\n    const title = `FOOTER (${footer.height}px)`;\n    const titlePadding = Math.floor((innerWidth - title.length) / 2);\n    lines.push(\"│ \" + \" \".repeat(titlePadding) + title + \" \".repeat(innerWidth - titlePadding - title.length) + \" │\");\n\n    const content = footer.content || \"Links    •    Privacy    •    Contact\";\n    const contentPadding = Math.floor((innerWidth - content.length) / 2);\n    lines.push(\"│ \" + \" \".repeat(contentPadding) + content + \" \".repeat(innerWidth - contentPadding - content.length) + \" │\");\n\n    return lines;\n  }\n}\n```\n\n#### 타입 2: Sidebar Layout\n\n사이드바가 있는 레이아웃입니다.\n\n```typescript\ninterface SidebarLayout {\n  type: \"sidebar\";\n  sidebar: {\n    width: number;\n    position: \"left\" | \"right\";\n    content: string[];\n  };\n  main: {\n    content: string;\n  };\n}\n\n// ASCII 아트 출력 예시 (왼쪽 사이드바)\n/*\n┌──────────┬──────────────────────────────────┐\n│          │                                   │\n│ Sidebar  │        Main Content Area         │\n│ (240px)  │                                   │\n│          │                                   │\n│ • Home   │  ┌──────────────────────────┐    │\n│ • About  │  │   Content Section 1       │    │\n│ • Blog   │  └──────────────────────────┘    │\n│ • Contact│                                   │\n│          │  ┌──────────────────────────┐    │\n│          │  │   Content Section 2       │    │\n│          │  └──────────────────────────┘    │\n│          │                                   │\n└──────────┴──────────────────────────────────┘\n*/\n```\n\n**구현:**\n\n```typescript\nclass SidebarRenderer {\n  render(layout: SidebarLayout, width: number = 80): string {\n    const sidebarWidth = Math.floor(width * 0.25); // 25%\n    const mainWidth = width - sidebarWidth - 3; // 3 for borders\n\n    const lines: string[] = [];\n\n    // 상단 테두리\n    lines.push(\n      \"┌\" + \"─\".repeat(sidebarWidth) + \"┬\" + \"─\".repeat(mainWidth) + \"┐\"\n    );\n\n    // 컨텐츠 라인 생성\n    const sidebarLines = this.renderSidebar(layout.sidebar, sidebarWidth);\n    const mainLines = this.renderMain(layout.main, mainWidth);\n\n    const maxLines = Math.max(sidebarLines.length, mainLines.length);\n\n    for (let i = 0; i < maxLines; i++) {\n      const sidebarLine = sidebarLines[i] || \" \".repeat(sidebarWidth);\n      const mainLine = mainLines[i] || \" \".repeat(mainWidth);\n\n      lines.push(\"│\" + sidebarLine + \"│\" + mainLine + \"│\");\n    }\n\n    // 하단 테두리\n    lines.push(\n      \"└\" + \"─\".repeat(sidebarWidth) + \"┴\" + \"─\".repeat(mainWidth) + \"┘\"\n    );\n\n    return lines.join(\"\\n\");\n  }\n\n  private renderSidebar(sidebar: SidebarConfig, width: number): string[] {\n    const lines: string[] = [];\n\n    // 타이틀\n    const title = `Sidebar (${sidebar.width}px)`;\n    const titlePadding = Math.floor((width - title.length) / 2);\n    lines.push(\" \".repeat(titlePadding) + title + \" \".repeat(width - titlePadding - title.length));\n\n    lines.push(\" \".repeat(width)); // 빈 줄\n\n    // 메뉴 아이템\n    sidebar.content.forEach(item => {\n      const menuItem = `• ${item}`;\n      lines.push(\" \" + menuItem + \" \".repeat(width - menuItem.length - 1));\n    });\n\n    return lines;\n  }\n\n  private renderMain(main: MainConfig, width: number): string[] {\n    const lines: string[] = [];\n    const innerWidth = width - 2;\n\n    const title = \"Main Content Area\";\n    const titlePadding = Math.floor((innerWidth - title.length) / 2);\n    lines.push(\" \".repeat(titlePadding) + title + \" \".repeat(innerWidth - titlePadding - title.length));\n\n    lines.push(\" \".repeat(width)); // 빈 줄\n\n    // 컨텐츠 섹션\n    const sections = [\"Content Section 1\", \"Content Section 2\"];\n\n    sections.forEach((section, idx) => {\n      if (idx > 0) {\n        lines.push(\" \".repeat(width)); // 섹션 간 빈 줄\n      }\n\n      const boxTop = \"┌\" + \"─\".repeat(innerWidth - 2) + \"┐\";\n      const boxContent = `│   ${section}${\" \".repeat(innerWidth - section.length - 5)}│`;\n      const boxBottom = \"└\" + \"─\".repeat(innerWidth - 2) + \"┘\";\n\n      lines.push(\" \" + boxTop + \" \");\n      lines.push(\" \" + boxContent + \" \");\n      lines.push(\" \" + boxBottom + \" \");\n    });\n\n    return lines;\n  }\n}\n```\n\n#### 타입 3: Grid Layout\n\n그리드 기반 레이아웃입니다.\n\n```typescript\ninterface GridLayout {\n  type: \"grid\";\n  columns: number;\n  rows: number;\n  gap: number;\n  items: GridItem[];\n}\n\ninterface GridItem {\n  row: number;\n  col: number;\n  rowSpan?: number;\n  colSpan?: number;\n  content: string;\n}\n\n// ASCII 아트 출력 예시 (3x3 그리드)\n/*\n┌──────────┬──────────┬──────────┐\n│          │          │          │\n│  Item 1  │  Item 2  │  Item 3  │\n│          │          │          │\n├──────────┼──────────┼──────────┤\n│          │          │          │\n│  Item 4  │  Item 5  │  Item 6  │\n│          │          │          │\n├──────────┼──────────┼──────────┤\n│          │          │          │\n│  Item 7  │  Item 8  │  Item 9  │\n│          │          │          │\n└──────────┴──────────┴──────────┘\n*/\n```\n\n#### 타입 4: Split Layout\n\n화면 분할 레이아웃입니다.\n\n```typescript\ninterface SplitLayout {\n  type: \"split\";\n  direction: \"horizontal\" | \"vertical\";\n  ratio: number; // 0-1 사이 값\n  panes: [PaneConfig, PaneConfig];\n}\n\n// ASCII 아트 출력 예시 (수평 분할 50:50)\n/*\n┌──────────────────────┬──────────────────────┐\n│                      │                      │\n│                      │                      │\n│    Left Pane         │    Right Pane        │\n│                      │                      │\n│                      │                      │\n│                      │                      │\n│                      │                      │\n└──────────────────────┴──────────────────────┘\n*/\n\n// 수직 분할 60:40\n/*\n┌─────────────────────────────────────────────┐\n│                                              │\n│             Top Pane (60%)                   │\n│                                              │\n│                                              │\n├─────────────────────────────────────────────┤\n│                                              │\n│             Bottom Pane (40%)                │\n│                                              │\n└─────────────────────────────────────────────┘\n*/\n```\n\n#### 타입 5: Dashboard Layout\n\n대시보드 스타일 레이아웃입니다.\n\n```typescript\ninterface DashboardLayout {\n  type: \"dashboard\";\n  widgets: Widget[];\n}\n\ninterface Widget {\n  id: string;\n  title: string;\n  type: \"chart\" | \"stats\" | \"table\" | \"custom\";\n  position: { row: number; col: number };\n  size: { rows: number; cols: number };\n}\n\n// ASCII 아트 출력 예시\n/*\n┌───────────────┬───────────────┬───────────────┐\n│  Total Users  │ Active Users  │ Revenue       │\n│               │               │               │\n│    12,543     │    8,921      │  $145,293     │\n│   ↑ 12%      │   ↑ 8%       │  ↑ 23%       │\n├───────────────┴───────────────┼───────────────┤\n│                               │               │\n│      User Growth Chart        │ Top Products  │\n│                               │               │\n│         ╱╲    ╱╲             │ 1. Product A  │\n│        ╱  ╲  ╱  ╲            │ 2. Product B  │\n│       ╱    ╲╱    ╲           │ 3. Product C  │\n│                               │               │\n└───────────────────────────────┴───────────────┘\n*/\n```\n\n#### 타입 6: Mobile Layout\n\n모바일 뷰 레이아웃입니다.\n\n```typescript\ninterface MobileLayout {\n  type: \"mobile\";\n  width: number; // 375px (iPhone) or 414px (iPhone Plus)\n  sections: MobileSection[];\n}\n\ninterface MobileSection {\n  type: \"header\" | \"content\" | \"navigation\" | \"fab\";\n  content: string;\n  height?: number;\n}\n\n// ASCII 아트 출력 예시 (iPhone 크기)\n/*\n┌──────────────────┐\n│  ☰  App Title  🔍│  Header\n├──────────────────┤\n│                  │\n│                  │\n│                  │\n│  Content Area    │\n│                  │\n│  Scroll Content  │\n│                  │\n│                  │\n│                  │\n│                  │\n│                  │\n│                  │\n├──────────────────┤\n│ 🏠  📱  👤  ⚙️  │  Bottom Nav\n└──────────────────┘\n        ⊕           Floating Action Button\n*/\n```\n\n### 3. preview_ui 도구 구현\n\n```typescript\ninterface PreviewUIParams {\n  layoutType: LayoutType;\n  code?: string; // JSX/HTML 코드 (선택적)\n  config?: LayoutConfig; // 직접 설정 (선택적)\n  width?: number; // 출력 너비 (기본: 80)\n  responsive?: boolean; // 반응형 시뮬레이션 (기본: false)\n}\n\ninterface PreviewUIResult {\n  ascii: string;\n  layout: ParsedLayout;\n  suggestions: string[];\n  responsive?: {\n    mobile: string;\n    tablet: string;\n    desktop: string;\n  };\n}\n\nclass UIPreviewTool {\n  async execute(params: PreviewUIParams): Promise<PreviewUIResult> {\n    // 1. 레이아웃 파싱\n    const layout = params.code\n      ? this.parseLayout(params.code)\n      : this.buildLayout(params.config!, params.layoutType);\n\n    // 2. ASCII 아트 생성\n    const renderer = this.getRenderer(params.layoutType);\n    const ascii = renderer.render(layout, params.width || 80);\n\n    // 3. 개선 제안 생성\n    const suggestions = this.generateSuggestions(layout);\n\n    // 4. 반응형 미리보기 (옵션)\n    let responsive;\n    if (params.responsive) {\n      responsive = {\n        mobile: renderer.render(layout, 40),\n        tablet: renderer.render(layout, 60),\n        desktop: renderer.render(layout, 100)\n      };\n    }\n\n    return {\n      ascii,\n      layout,\n      suggestions,\n      responsive\n    };\n  }\n\n  private parseLayout(code: string): ParsedLayout {\n    // JSX/HTML 파싱\n    const ast = parseJSX(code);\n\n    // 레이아웃 구조 추출\n    return this.extractLayoutStructure(ast);\n  }\n\n  private extractLayoutStructure(ast: JSXElement): ParsedLayout {\n    // div, section 등의 구조 분석\n    const structure = {\n      type: this.inferLayoutType(ast),\n      components: this.extractComponents(ast),\n      hierarchy: this.buildHierarchy(ast)\n    };\n\n    return structure;\n  }\n\n  private inferLayoutType(ast: JSXElement): LayoutType {\n    // 코드에서 레이아웃 타입 추론\n    const hasHeader = this.hasComponent(ast, \"header\");\n    const hasFooter = this.hasComponent(ast, \"footer\");\n    const hasSidebar = this.hasComponent(ast, \"sidebar\");\n    const hasGrid = this.hasGridLayout(ast);\n\n    if (hasHeader && hasFooter) {\n      return \"header-content-footer\";\n    } else if (hasSidebar) {\n      return \"sidebar\";\n    } else if (hasGrid) {\n      return \"grid\";\n    }\n\n    return \"custom\";\n  }\n\n  private generateSuggestions(layout: ParsedLayout): string[] {\n    const suggestions: string[] = [];\n\n    // 접근성 검사\n    if (!layout.hasSemanticHTML) {\n      suggestions.push(\"시맨틱 HTML 태그 사용을 권장합니다 (header, nav, main, footer)\");\n    }\n\n    // 반응형 검사\n    if (!layout.isResponsive) {\n      suggestions.push(\"미디어 쿼리를 추가하여 반응형 디자인을 구현하세요\");\n    }\n\n    // 성능 검사\n    if (layout.nestingDepth > 5) {\n      suggestions.push(`중첩 깊이가 ${layout.nestingDepth}입니다. 5 이하로 줄이는 것을 권장합니다`);\n    }\n\n    return suggestions;\n  }\n}\n```\n\n### 4. 레이아웃 자동 감지\n\n코드에서 자동으로 레이아웃을 감지합니다.\n\n```typescript\nclass LayoutDetector {\n  detect(code: string): DetectedLayout {\n    const ast = this.parse(code);\n\n    // 1. 구조 분석\n    const structure = this.analyzeStructure(ast);\n\n    // 2. CSS 분석\n    const styles = this.extractStyles(ast);\n\n    // 3. 레이아웃 타입 결정\n    const layoutType = this.determineLayoutType(structure, styles);\n\n    // 4. 세부 설정 추출\n    const config = this.extractConfig(structure, styles, layoutType);\n\n    return {\n      type: layoutType,\n      config,\n      confidence: this.calculateConfidence(structure, styles)\n    };\n  }\n\n  private analyzeStructure(ast: ASTNode): StructureAnalysis {\n    return {\n      hasHeader: this.findElement(ast, [\"header\", \"Header\"]),\n      hasFooter: this.findElement(ast, [\"footer\", \"Footer\"]),\n      hasSidebar: this.findElement(ast, [\"aside\", \"Sidebar\", \"Navigation\"]),\n      hasGrid: this.hasGridDisplay(ast),\n      hasFlex: this.hasFlexDisplay(ast),\n      componentCount: this.countComponents(ast),\n      nestingDepth: this.calculateNestingDepth(ast)\n    };\n  }\n\n  private extractStyles(ast: ASTNode): StyleAnalysis {\n    const styles = {\n      display: [],\n      layout: [],\n      grid: null,\n      flex: null\n    };\n\n    // className, style prop에서 스타일 추출\n    this.traverseAST(ast, node => {\n      if (node.type === \"JSXAttribute\" && node.name === \"className\") {\n        styles.layout.push(...this.parseClassName(node.value));\n      }\n\n      if (node.type === \"JSXAttribute\" && node.name === \"style\") {\n        const inlineStyles = this.parseInlineStyle(node.value);\n        if (inlineStyles.display === \"grid\") {\n          styles.grid = inlineStyles;\n        }\n        if (inlineStyles.display === \"flex\") {\n          styles.flex = inlineStyles;\n        }\n      }\n    });\n\n    return styles;\n  }\n\n  private determineLayoutType(\n    structure: StructureAnalysis,\n    styles: StyleAnalysis\n  ): LayoutType {\n    // 규칙 기반 타입 결정\n    if (structure.hasHeader && structure.hasFooter) {\n      return \"header-content-footer\";\n    }\n\n    if (structure.hasSidebar) {\n      return \"sidebar\";\n    }\n\n    if (structure.hasGrid || styles.grid) {\n      return \"grid\";\n    }\n\n    if (styles.flex?.flexDirection === \"column\") {\n      const ratio = this.calculateSplitRatio(structure);\n      if (ratio) {\n        return \"split\";\n      }\n    }\n\n    if (this.isDashboard(structure)) {\n      return \"dashboard\";\n    }\n\n    if (this.isMobile(structure, styles)) {\n      return \"mobile\";\n    }\n\n    return \"custom\";\n  }\n}\n```\n\n## 사용 예시\n\n### 예시 1: 기본 레이아웃 미리보기\n\n```typescript\nUser: \"이 레이아웃 미리보기 보여줘\"\n\n// React 컴포넌트 코드\nconst Layout = () => (\n  <div>\n    <header>\n      <h1>My App</h1>\n      <nav>Navigation</nav>\n    </header>\n    <main>\n      <p>Content here</p>\n    </main>\n    <footer>\n      <p>Footer</p>\n    </footer>\n  </div>\n);\n\n// hi-ai 실행\nconst preview = await previewUI({\n  code: layoutCode,\n  width: 80\n});\n\n// 출력\n/*\n┌─────────────────────────────────────────────┐\n│              HEADER (60px)                   │\n│  My App          Navigation                  │\n├─────────────────────────────────────────────┤\n│                                              │\n│                                              │\n│            MAIN CONTENT AREA                 │\n│              Content here                    │\n│                                              │\n│                                              │\n│                                              │\n├─────────────────────────────────────────────┤\n│          FOOTER (40px)                       │\n│               Footer                         │\n└─────────────────────────────────────────────┘\n\n레이아웃 타입: Header-Content-Footer\n감지 신뢰도: 98%\n\n개선 제안:\n- header에 role=\"banner\" 추가를 권장합니다\n- main에 role=\"main\" 추가를 권장합니다\n- footer에 role=\"contentinfo\" 추가를 권장합니다\n*/\n```\n\n### 예시 2: 반응형 미리보기\n\n```typescript\nUser: \"이 레이아웃 반응형으로 어떻게 보이는지 보여줘\"\n\nconst preview = await previewUI({\n  layoutType: \"sidebar\",\n  config: {\n    sidebar: { width: 240, position: \"left\" },\n    main: { content: \"Main content\" }\n  },\n  responsive: true\n});\n\n// 출력\n/*\n=== MOBILE (375px) ===\n┌─────────────────┐\n│   ☰ Menu        │\n├─────────────────┤\n│                 │\n│                 │\n│  Main Content   │\n│                 │\n│                 │\n└─────────────────┘\n\n=== TABLET (768px) ===\n┌──────┬──────────────────────┐\n│      │                      │\n│ Menu │   Main Content       │\n│      │                      │\n└──────┴──────────────────────┘\n\n=== DESKTOP (1440px) ===\n┌──────────┬────────────────────────────────┐\n│          │                                │\n│          │                                │\n│  Sidebar │      Main Content Area         │\n│  (240px) │                                │\n│          │                                │\n└──────────┴────────────────────────────────┘\n\n반응형 분석:\n- Mobile: 사이드바가 햄버거 메뉴로 변환\n- Tablet: 사이드바가 좁아짐 (160px)\n- Desktop: 사이드바가 고정폭 유지 (240px)\n*/\n```\n\n### 예시 3: 대시보드 레이아웃\n\n```typescript\nUser: \"대시보드 레이아웃 만들어줘 - 통계 3개, 차트 2개, 테이블 1개\"\n\nconst preview = await previewUI({\n  layoutType: \"dashboard\",\n  config: {\n    widgets: [\n      { type: \"stats\", title: \"Total Users\", position: { row: 0, col: 0 }, size: { rows: 1, cols: 1 } },\n      { type: \"stats\", title: \"Revenue\", position: { row: 0, col: 1 }, size: { rows: 1, cols: 1 } },\n      { type: \"stats\", title: \"Active\", position: { row: 0, col: 2 }, size: { rows: 1, cols: 1 } },\n      { type: \"chart\", title: \"Growth\", position: { row: 1, col: 0 }, size: { rows: 2, cols: 2 } },\n      { type: \"chart\", title: \"Revenue\", position: { row: 1, col: 2 }, size: { rows: 1, cols: 1 } },\n      { type: \"table\", title: \"Recent\", position: { row: 2, col: 2 }, size: { rows: 1, cols: 1 } }\n    ]\n  }\n});\n\n// 출력\n/*\n┌───────────────┬───────────────┬───────────────┐\n│  Total Users  │   Revenue     │   Active      │\n│    12,543     │  $145,293     │   8,921       │\n│   ↑ 12%      │  ↑ 23%       │  ↑ 8%        │\n├───────────────┴───────────────┼───────────────┤\n│                               │   Revenue     │\n│      User Growth Chart        │   (This Mo.)  │\n│                               ├───────────────┤\n│         ╱╲    ╱╲             │ Recent Orders │\n│        ╱  ╲  ╱  ╲            │ #1234 - $299  │\n│       ╱    ╲╱    ╲           │ #1235 - $499  │\n│                               │ #1236 - $199  │\n└───────────────────────────────┴───────────────┘\n\n레이아웃 분석:\n- 3x3 그리드 기반\n- 통계 위젯: 1x1 (3개)\n- 차트 위젯: 2x2 (1개), 1x1 (1개)\n- 테이블 위젯: 1x1 (1개)\n\n추천:\n- 반응형을 위해 최소 너비 설정 (min-width: 1200px)\n- 모바일에서는 세로 스택으로 전환\n*/\n```\n\n### 예시 4: 컴포넌트 계층 시각화\n\n```typescript\nUser: \"이 컴포넌트 구조 보여줘\"\n\n// 복잡한 중첩 구조\nconst App = () => (\n  <Layout>\n    <Header>\n      <Logo />\n      <Navigation>\n        <NavItem />\n        <NavItem />\n      </Navigation>\n    </Header>\n    <Main>\n      <Sidebar>\n        <Menu />\n      </Sidebar>\n      <Content>\n        <Article>\n          <Header />\n          <Body />\n          <Comments>\n            <Comment />\n            <Comment />\n          </Comments>\n        </Article>\n      </Content>\n    </Main>\n  </Layout>\n);\n\n// hi-ai 출력\n/*\nComponent Hierarchy:\n\nLayout\n├─ Header\n│  ├─ Logo\n│  └─ Navigation\n│     ├─ NavItem\n│     └─ NavItem\n└─ Main\n   ├─ Sidebar\n   │  └─ Menu\n   └─ Content\n      └─ Article\n         ├─ Header\n         ├─ Body\n         └─ Comments\n            ├─ Comment\n            └─ Comment\n\n통계:\n- 총 컴포넌트: 14개\n- 최대 중첩 깊이: 5\n- 재사용 컴포넌트: NavItem (2), Comment (2)\n\n경고:\n- 중첩 깊이가 5입니다. 4 이하를 권장합니다.\n- Article > Header가 Layout > Header와 충돌할 수 있습니다.\n  이름을 ArticleHeader로 변경하는 것을 고려하세요.\n*/\n```\n\n## 기술적 세부사항\n\n### ASCII 렌더링 엔진\n\n```typescript\nclass ASCIIRenderer {\n  private boxChars = {\n    topLeft: \"┌\",\n    topRight: \"┐\",\n    bottomLeft: \"└\",\n    bottomRight: \"┘\",\n    horizontal: \"─\",\n    vertical: \"│\",\n    cross: \"┼\",\n    tDown: \"┬\",\n    tUp: \"┴\",\n    tRight: \"├\",\n    tLeft: \"┤\"\n  };\n\n  public drawBox(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    title?: string\n  ): string[] {\n    const lines: string[] = [];\n\n    // 상단\n    let topLine = this.boxChars.topLeft;\n    if (title) {\n      const titlePadding = Math.floor((width - title.length - 2) / 2);\n      topLine += this.boxChars.horizontal.repeat(titlePadding);\n      topLine += ` ${title} `;\n      topLine += this.boxChars.horizontal.repeat(width - titlePadding - title.length - 3);\n    } else {\n      topLine += this.boxChars.horizontal.repeat(width - 2);\n    }\n    topLine += this.boxChars.topRight;\n    lines.push(topLine);\n\n    // 중간\n    for (let i = 0; i < height - 2; i++) {\n      lines.push(\n        this.boxChars.vertical +\n        \" \".repeat(width - 2) +\n        this.boxChars.vertical\n      );\n    }\n\n    // 하단\n    const bottomLine =\n      this.boxChars.bottomLeft +\n      this.boxChars.horizontal.repeat(width - 2) +\n      this.boxChars.bottomRight;\n    lines.push(bottomLine);\n\n    return lines;\n  }\n\n  public drawGrid(\n    rows: number,\n    cols: number,\n    cellWidth: number,\n    cellHeight: number\n  ): string[] {\n    const lines: string[] = [];\n    const totalWidth = cellWidth * cols + cols + 1;\n\n    // 상단 테두리\n    let topLine = this.boxChars.topLeft;\n    for (let col = 0; col < cols; col++) {\n      topLine += this.boxChars.horizontal.repeat(cellWidth);\n      topLine += col < cols - 1 ? this.boxChars.tDown : this.boxChars.topRight;\n    }\n    lines.push(topLine);\n\n    // 각 행\n    for (let row = 0; row < rows; row++) {\n      // 셀 내용\n      for (let lineInCell = 0; lineInCell < cellHeight; lineInCell++) {\n        let line = this.boxChars.vertical;\n        for (let col = 0; col < cols; col++) {\n          line += \" \".repeat(cellWidth);\n          line += this.boxChars.vertical;\n        }\n        lines.push(line);\n      }\n\n      // 행 구분선 (마지막 행 제외)\n      if (row < rows - 1) {\n        let dividerLine = this.boxChars.tRight;\n        for (let col = 0; col < cols; col++) {\n          dividerLine += this.boxChars.horizontal.repeat(cellWidth);\n          dividerLine += col < cols - 1 ? this.boxChars.cross : this.boxChars.tLeft;\n        }\n        lines.push(dividerLine);\n      }\n    }\n\n    // 하단 테두리\n    let bottomLine = this.boxChars.bottomLeft;\n    for (let col = 0; col < cols; col++) {\n      bottomLine += this.boxChars.horizontal.repeat(cellWidth);\n      bottomLine += col < cols - 1 ? this.boxChars.tUp : this.boxChars.bottomRight;\n    }\n    lines.push(bottomLine);\n\n    return lines;\n  }\n\n  public centerText(text: string, width: number): string {\n    if (text.length >= width) {\n      return text.substring(0, width);\n    }\n\n    const padding = Math.floor((width - text.length) / 2);\n    return \" \".repeat(padding) + text + \" \".repeat(width - padding - text.length);\n  }\n\n  public alignLeft(text: string, width: number): string {\n    return text + \" \".repeat(Math.max(0, width - text.length));\n  }\n\n  public alignRight(text: string, width: number): string {\n    return \" \".repeat(Math.max(0, width - text.length)) + text;\n  }\n}\n```\n\n### 성능 최적화\n\n```typescript\n// 렌더링 캐시\nclass CachedPreviewRenderer {\n  private cache = new Map<string, string>();\n\n  render(layout: LayoutConfig): string {\n    const key = this.generateKey(layout);\n\n    if (this.cache.has(key)) {\n      return this.cache.get(key)!;\n    }\n\n    const result = this.doRender(layout);\n\n    this.cache.set(key, result);\n\n    return result;\n  }\n\n  private generateKey(layout: LayoutConfig): string {\n    return JSON.stringify(layout);\n  }\n}\n```\n\n## 업그레이드 가이드\n\n### v1.1.0에서 v1.2.0으로\n\n**1. 패키지 업데이트**\n\n```bash\nnpm update @su-record/hi-ai\n```\n\n**2. 새 기능 사용**\n\n```typescript\n// preview_ui 도구 사용\nconst preview = await tools.execute(\"preview_ui\", {\n  layoutType: \"header-content-footer\",\n  width: 80\n});\n\nconsole.log(preview.ascii);\n```\n\n### Breaking Changes\n\n없음.\n\n### 새로 추가된 도구\n\n- `preview_ui`: UI 레이아웃 미리보기\n\n## 성능 벤치마크\n\n| 작업 | 시간 |\n|------|------|\n| 레이아웃 파싱 | 50ms |\n| ASCII 렌더링 | 30ms |\n| 반응형 미리보기 (3개) | 90ms |\n| 총 처리 시간 | 170ms |\n\n## 알려진 제한사항\n\n1. 현재는 기본 레이아웃만 지원\n2. 복잡한 CSS 애니메이션은 표현 불가\n3. 터미널 너비에 따라 표시가 깨질 수 있음\n\n## 다음 버전 계획\n\n**v1.3.0 (예정)**\n- 컬러 ASCII 아트 지원\n- 더 많은 레이아웃 타입\n- 3D 시각화\n\n## 참고 자료\n\n- [ASCII Art Wikipedia](https://en.wikipedia.org/wiki/ASCII_art)\n- [Box Drawing Characters](https://en.wikipedia.org/wiki/Box-drawing_character)\n- [hi-ai GitHub](https://github.com/su-record/hi-ai)\n\n---\n\n**릴리즈 날짜:** 2024-10-17\n**도구 개수:** 34개\n**주요 기능:** UI 미리보기, ASCII 아트, 6가지 레이아웃 타입",
      "description": "ASCII 아트 기반 UI 미리보기 - 6가지 레이아웃 타입 지원으로 터미널에서 즉시 확인 가능한 시각화 시스템",
      "tags": [
        "hi-ai",
        "mcp",
        "ui-preview",
        "ascii-art",
        "developer-tools",
        "release"
      ],
      "image": null,
      "author": "Su Ham",
      "lang": "ko",
      "filePath": "/posts/tech-hi-ai-v1.2.0.md"
    }
  ]
}