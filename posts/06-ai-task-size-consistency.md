---
title: "AI 개발 방법론 6 - 전체를 먼저 보는 개발"
date: "2025-12-30"
category: "methodology"
description: "작은 태스크의 함정, 일관성을 지키기 위한 전체 우선 접근법. 베타 런칭 전 점검에서 얻은 교훈"
tags: ["ai-first", "methodology", "consistency", "vibe-coding", "task-size"]
author: "Su"
lang: "ko"
---

# 전체를 먼저 보는 개발

> 이전 편: [AI 개발 방법론 5 - 완성, SpecKit과 그 너머](05-ai-completion-speckit.md)

## 일반적인 조언

AI 바이브 코딩에 대해 검색하면 대부분 비슷한 조언이 나옵니다.

"태스크를 작게 나눠라." "한 번에 너무 많이 요청하지 마라." "작은 단위로 검증하면서 진행하라."

틀린 말은 아닙니다. 복잡한 작업을 작은 단위로 나누면 AI가 더 정확하게 처리할 수 있다고 합니다. Google Cloud 가이드에서도, 여러 개발 블로그에서도 비슷한 내용을 찾을 수 있습니다.

저도 처음에는 그렇게 했습니다.

---

## 작은 태스크의 함정

fallingo 개발 초기, 작은 태스크 단위로 개발을 진행했습니다.

"사용자 모델 만들어줘." "피드 API 만들어줘." "댓글 기능 추가해줘."

각각의 결과물은 괜찮았습니다. AI가 깔끔하게 코드를 생성했고, 단위별 테스트도 통과했습니다. 문제는 이것들을 합칠 때 발생했습니다.

### 데이터 타입 불일치

사용자 모델에서는 `user_id`를 `int`로 정의했는데, 피드 API에서는 `string`으로 받고 있었습니다. 댓글 기능에서는 또 다른 형태로 처리했습니다. 각각 독립적으로 만들어졌기 때문에 서로의 맥락을 모르는 상태였습니다.

### 네이밍 불일치

어떤 곳에서는 `created_at`, 다른 곳에서는 `createdAt`, 또 다른 곳에서는 `create_date`. 같은 개념인데 표현이 달랐습니다. 작은 태스크마다 새로운 세션에서 작업했기 때문에, AI는 매번 자기 나름의 컨벤션을 적용했습니다.

### 비즈니스 로직 충돌

피드 삭제 시 댓글도 함께 삭제되어야 하는데, 각각 독립적으로 만들어진 기능들이라 이런 연결 고리가 누락되어 있었습니다. 나중에 발견하고 수정하려 했지만, 이미 여러 곳에 영향을 미치는 상태였습니다.

---

## 효율의 착각

작은 태스크 단위 개발이 효율적으로 보이는 이유가 있습니다.

빠르게 결과물이 나옵니다. "완료"라는 느낌을 자주 받습니다. 진행 상황이 눈에 보입니다.

하지만 착각이었습니다.

통합 과정에서 불일치를 발견하고, 수정하고, 또 다른 불일치를 발견하고, 수정하는 과정이 반복되었습니다. 결국 처음부터 다시 만드는 것만 못한 상황이 여러 번 발생했습니다.

50,000줄 이상 시스템에서 AI 생성 코드 디버깅에 41% 더 많은 시간이 소요된다는 연구 결과도 있습니다. 작은 단위로 빠르게 만들었지만, 통합과 디버깅에서 그 시간을 다 돌려받는 셈입니다.

---

## 내가 찾은 방법

베타 런칭을 앞두고 전체 점검을 하면서 깨달은 것이 있습니다.

### 전체를 먼저 요청한다

fallingo는 스펙 주도 개발로 진행했습니다. SpecKit으로 앱 서비스 전체의 명세를 먼저 완성하고, 그 스펙을 기반으로 개발을 요청합니다.

"이 스펙대로 백엔드 전체를 구현해줘." "이 스펙대로 프론트엔드를 만들어줘."

기능 단위가 아니라 서비스 전체 단위입니다. 그래야 스키마와 모델이 일관성을 가집니다. AI가 전체 스펙을 파악한 상태에서 코드를 생성하기 때문에, 데이터 타입, 네이밍, 비즈니스 로직이 하나의 스펙 안에서 이미 정의되어 있고, AI는 그것을 따릅니다.

### 이후 페이지/기능별로 점검한다

전체가 만들어진 후, 화면 단위로 작업 분량을 지정하고 점검합니다.

먼저 AI가 해당 화면의 소스코드를 파악하게 합니다. 그리고 그 안에서 기능 단위별 점검에 대한 플랜을 만들어서 작업을 진행합니다.

이 과정에서 가장 많이 발견된 문제는 실제 API가 있음에도 mock 데이터를 반환하거나, TODO 표기로 로그만 출력하는 부분들이었습니다. 전체를 한 번에 만들다 보니 AI가 일부 구현을 미뤄둔 것입니다. 이런 부분들을 화면별 점검에서 잡아냅니다.

이때는 이미 전체 구조가 잡혀있으므로, 수정이 일관성을 해치지 않습니다. mock을 실제 API로 연결하고, TODO를 실제 구현으로 채워도 스키마와 모델은 그대로입니다.

이 방식의 장점은 점검과 동시에 개선이나 변경 작업을 시도할 수 있다는 것입니다. 전체 구조가 잡혀있으니 스키마 변경이 필요해도 부담이 없었습니다. 어디를 수정해야 하는지 명확하고, 변경의 영향 범위도 파악하기 쉬웠습니다.

가장 중요한 장점은 각 기능별 주석 표기에 유리하다는 것입니다. 화면 단위로 점검하면서 해당 기능이 무엇을 하는지, 왜 이렇게 구현했는지를 주석으로 남기기 좋습니다. 전체 맥락을 알고 있는 상태에서 부분을 보기 때문에, 주석도 일관되고 의미 있게 작성됩니다.

이런 과정이 향후 유지보수에 유리한 점이 될 거라 생각합니다.

---

## 오히려 더 빠르다

"전체를 만들고, 다시 부분별로 점검하면 두 번 일하는 거 아닌가?"

그렇게 보일 수 있습니다. 하지만 작은 태스크 방식과 비교하면 이야기가 달라집니다.

작은 태스크로 나눠서 개발하면 각각 만드는 건 빠릅니다. 문제는 그 다음입니다. 통합 단계에서 데이터 타입이 안 맞고, 네이밍이 다르고, 비즈니스 로직이 충돌합니다. 수정하면 다른 곳에서 또 문제가 생깁니다. 이 과정이 끝없이 반복됩니다.

전체 우선 접근은 다릅니다. 처음에 시간이 좀 더 걸리지만, 점검 단계에서 발견되는 문제는 대부분 mock 데이터 연결이나 TODO 구현 같은 것들입니다. 구조적인 문제가 아닙니다. 수정해도 다른 곳에 영향을 주지 않습니다.

최근 개발일지들이 그 증거입니다. OAuth 인증 플로우 안정화, 다국어 처리 확대, UI/UX 개선. 모두 기존 구조 위에서 다듬는 작업들이었습니다. 구조 자체를 뒤엎어야 하는 상황은 한 번도 발생하지 않았습니다.

---

## 일관성 시리즈의 연장선

이 방법론 시리즈는 처음부터 일관성에 대한 이야기였습니다.

3편에서 "AI는 너무 유능해서 문제"라고 했습니다. A를 요청하면 B와 C를 덧붙여서 ABC로 만들어버린다고요. 4편에서 "문서에 없는 내용을 임의로 추가하지 말 것"이라는 핵심 규칙을 세웠습니다. 5편에서 SpecKit을 도입해 구조적 일관성을 확보했습니다.

태스크 크기에 대한 이번 이야기도 같은 맥락입니다.

작은 태스크로 나누면 각 태스크마다 AI가 독립적으로 판단합니다. 전체 맥락 없이 자기 나름의 최선을 만들어냅니다. 그 결과가 불일치입니다.

전체를 먼저 보여주면 AI가 하나의 맥락 안에서 일관되게 작업합니다. 이후 부분 점검은 그 일관성을 유지한 채로 품질을 높이는 과정입니다.

---

## 나만의 방법을 찾아라

정답은 없습니다. 프로젝트 규모에 따라, 팀 구성에 따라, 개인의 성향에 따라 다릅니다.

하지만 저는 이 방법에 확신을 가지고 있습니다.

수십 번의 리셋과 수백 시간의 고민 끝에 찾은 방법입니다. 그 결과로 fallingo는 베타 런칭을 앞두고 있습니다. 백엔드 API, 프론트엔드 UI, 다국어 지원, OAuth 인증까지. 모두 이 방식으로 만들었고, 구조적인 문제 없이 여기까지 왔습니다.

"태스크를 작게 나눠라"는 일반적인 조언이 저에게는 오히려 문제를 만들었습니다. 반대로, 제 방법이 다른 사람에게는 비효율적일 수 있습니다. 그래도 괜찮습니다.

중요한 것은 계속 시도하고, 실패하고, 배우면서 자기만의 방법을 찾아가는 것입니다.

여러분도 찾을 수 있습니다.

---

> 이전 편: [AI 개발 방법론 1 - AI와의 첫 만남, 그리고 시작](01-ai-journey-start.md)

**fallingo 베타 런칭이 다가오고 있습니다.**
